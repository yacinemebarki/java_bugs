Hash,Message,Type,Old_Code,New_Code
7a55ce48a93f004c7acc0b51c04bb39be2c6b733,"Handle CancellationException in JdkClientHttpRequest

Handle CancellationException in order to throw an HttpTimeoutException
when the timeout handler caused the cancellation.

See gh-34721

Signed-off-by: giampaolo <giampaorr@gmail.com>

fix: use timeoutHandler with a flag isTimeout

    Closes gh-33973

    Signed-off-by: giampaolo <giampaorr@gmail.com>",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.http.client;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.HttpTimeoutException;
import java.nio.ByteBuffer;
import java.time.Duration;
import java.util.Collections;
import java.util.Locale;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Flow;
import java.util.concurrent.TimeUnit;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.lang.Nullable;
import org.springframework.util.StreamUtils;
import org.springframework.util.StringUtils;

/**
 * {@link ClientHttpRequest} implementation based the Java {@link HttpClient}.
 * Created via the {@link JdkClientHttpRequestFactory}.
 *
 * @author Marten Deinum
 * @author Arjen Poutsma
 * @since 6.1
 */
class JdkClientHttpRequest extends AbstractStreamingClientHttpRequest {

	private static final OutputStreamPublisher.ByteMapper<ByteBuffer> BYTE_MAPPER = new ByteBufferMapper();

	private static final Set<String> DISALLOWED_HEADERS = disallowedHeaders();


	private final HttpClient httpClient;

	private final HttpMethod method;

	private final URI uri;

	private final Executor executor;

	@Nullable
	private final Duration timeout;


	public JdkClientHttpRequest(HttpClient httpClient, URI uri, HttpMethod method, Executor executor,
			@Nullable Duration readTimeout) {

		this.httpClient = httpClient;
		this.uri = uri;
		this.method = method;
		this.executor = executor;
		this.timeout = readTimeout;
	}


	@Override
	public HttpMethod getMethod() {
		return this.method;
	}

	@Override
	public URI getURI() {
		return this.uri;
	}


	@Override
	@SuppressWarnings(""NullAway"")
	protected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body) throws IOException {
		CompletableFuture<HttpResponse<InputStream>> responseFuture = null;
		try {
			HttpRequest request = buildRequest(headers, body);
			responseFuture = this.httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofInputStream());

			if (this.timeout != null) {
				TimeoutHandler timeoutHandler = new TimeoutHandler(responseFuture, this.timeout);
				HttpResponse<InputStream> response = responseFuture.get();
				InputStream inputStream = timeoutHandler.wrapInputStream(response);
				return new JdkClientHttpResponse(response, inputStream);
			}
			else {
				HttpResponse<InputStream> response = responseFuture.get();
				return new JdkClientHttpResponse(response, response.body());
			}
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
			responseFuture.cancel(true);
			throw new IOException(""Request was interrupted: "" + ex.getMessage(), ex);
		}
		catch (ExecutionException ex) {
			Throwable cause = ex.getCause();

			if (cause instanceof CancellationException) {
				throw new HttpTimeoutException(""Request timed out"");
			}
			if (cause instanceof UncheckedIOException uioEx) {
				throw uioEx.getCause();
			}
			if (cause instanceof RuntimeException rtEx) {
				throw rtEx;
			}
			else if (cause instanceof IOException ioEx) {
				throw ioEx;
			}
			else {
				throw new IOException(cause.getMessage(), cause);
			}
		}
	}

	private HttpRequest buildRequest(HttpHeaders headers, @Nullable Body body) {
		HttpRequest.Builder builder = HttpRequest.newBuilder().uri(this.uri);

		headers.forEach((headerName, headerValues) -> {
			if (!DISALLOWED_HEADERS.contains(headerName.toLowerCase(Locale.ROOT))) {
				for (String headerValue : headerValues) {
					builder.header(headerName, headerValue);
				}
			}
		});

		if (body != null) {
			builder.method(this.method.name(), bodyPublisher(headers, body));
		}
		else {
			switch (this.method.name()) {
				case ""GET"" :
					builder.GET();
					break;
				case ""DELETE"" :
					builder.DELETE();
					break;
				default :
					builder.method(this.method.name(), HttpRequest.BodyPublishers.noBody());
			}
		}
		return builder.build();
	}

	private HttpRequest.BodyPublisher bodyPublisher(HttpHeaders headers, Body body) {
		Flow.Publisher<ByteBuffer> publisher = new OutputStreamPublisher<>(
				os -> body.writeTo(StreamUtils.nonClosing(os)), BYTE_MAPPER, this.executor, null);

		long contentLength = headers.getContentLength();
		if (contentLength > 0) {
			return HttpRequest.BodyPublishers.fromPublisher(publisher, contentLength);
		}
		else if (contentLength == 0) {
			return HttpRequest.BodyPublishers.noBody();
		}
		else {
			return HttpRequest.BodyPublishers.fromPublisher(publisher);
		}
	}

	/**
	 * By default, {@link HttpRequest} does not allow {@code Connection},
	 * {@code Content-Length}, {@code Expect}, {@code Host}, or {@code Upgrade}
	 * headers to be set, but this can be overridden with the
	 * {@code jdk.httpclient.allowRestrictedHeaders} system property.
	 * @see jdk.internal.net.http.common.Utils#getDisallowedHeaders()
	 */
	private static Set<String> disallowedHeaders() {
		TreeSet<String> headers = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
		headers.addAll(Set.of(""connection"", ""content-length"", ""expect"", ""host"", ""upgrade""));

		String headersToAllow = System.getProperty(""jdk.httpclient.allowRestrictedHeaders"");
		if (headersToAllow != null) {
			Set<String> toAllow = StringUtils.commaDelimitedListToSet(headersToAllow);
			headers.removeAll(toAllow);
		}
		return Collections.unmodifiableSet(headers);
	}


	private static final class ByteBufferMapper implements OutputStreamPublisher.ByteMapper<ByteBuffer> {

		@Override
		public ByteBuffer map(int b) {
			ByteBuffer byteBuffer = ByteBuffer.allocate(1);
			byteBuffer.put((byte) b);
			byteBuffer.flip();
			return byteBuffer;
		}

		@Override
		public ByteBuffer map(byte[] b, int off, int len) {
			ByteBuffer byteBuffer = ByteBuffer.allocate(len);
			byteBuffer.put(b, off, len);
			byteBuffer.flip();
			return byteBuffer;
		}
	}


	/**
	 * Temporary workaround to use instead of {@link HttpRequest.Builder#timeout(Duration)}
	 * until <a href=""https://bugs.openjdk.org/browse/JDK-8258397"">JDK-8258397</a>
	 * is fixed. Essentially, create a future wiht a timeout handler, and use it
	 * to close the response.
	 * @see <a href=""https://mail.openjdk.org/pipermail/net-dev/2021-October/016672.html"">OpenJDK discussion thread</a>
	 */
	private static final class TimeoutHandler {

		private final CompletableFuture<Void> timeoutFuture;

		private TimeoutHandler(CompletableFuture<HttpResponse<InputStream>> future, Duration timeout) {

			this.timeoutFuture = new CompletableFuture<Void>()
					.completeOnTimeout(null, timeout.toMillis(), TimeUnit.MILLISECONDS);

			this.timeoutFuture.thenRun(() -> {
				if (future.cancel(true) || future.isCompletedExceptionally() || !future.isDone()) {
					return;
				}
				try {
					future.get().body().close();
				}
				catch (Exception ex) {
					// ignore
				}
			});

		}

		@Nullable
		public InputStream wrapInputStream(HttpResponse<InputStream> response) {
			InputStream body = response.body();
			if (body == null) {
				return body;
			}
			return new FilterInputStream(body) {

				@Override
				public void close() throws IOException {
					TimeoutHandler.this.timeoutFuture.cancel(false);
					super.close();
				}
			};
		}
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.http.client;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.HttpTimeoutException;
import java.nio.ByteBuffer;
import java.time.Duration;
import java.util.Collections;
import java.util.Locale;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Flow;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.lang.Nullable;
import org.springframework.util.StreamUtils;
import org.springframework.util.StringUtils;

/**
 * {@link ClientHttpRequest} implementation based the Java {@link HttpClient}.
 * Created via the {@link JdkClientHttpRequestFactory}.
 *
 * @author Marten Deinum
 * @author Arjen Poutsma
 * @since 6.1
 */
class JdkClientHttpRequest extends AbstractStreamingClientHttpRequest {

	private static final OutputStreamPublisher.ByteMapper<ByteBuffer> BYTE_MAPPER = new ByteBufferMapper();

	private static final Set<String> DISALLOWED_HEADERS = disallowedHeaders();


	private final HttpClient httpClient;

	private final HttpMethod method;

	private final URI uri;

	private final Executor executor;

	@Nullable
	private final Duration timeout;


	public JdkClientHttpRequest(HttpClient httpClient, URI uri, HttpMethod method, Executor executor,
			@Nullable Duration readTimeout) {

		this.httpClient = httpClient;
		this.uri = uri;
		this.method = method;
		this.executor = executor;
		this.timeout = readTimeout;
	}


	@Override
	public HttpMethod getMethod() {
		return this.method;
	}

	@Override
	public URI getURI() {
		return this.uri;
	}


	@Override
	@SuppressWarnings(""NullAway"")
	protected ClientHttpResponse executeInternal(HttpHeaders headers, @Nullable Body body) throws IOException {
		CompletableFuture<HttpResponse<InputStream>> responseFuture = null;
		TimeoutHandler timeoutHandler = null;
		try {
			HttpRequest request = buildRequest(headers, body);
			responseFuture = this.httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofInputStream());

			if (this.timeout != null) {
				timeoutHandler = new TimeoutHandler(responseFuture, this.timeout);
				HttpResponse<InputStream> response = responseFuture.get();
				InputStream inputStream = timeoutHandler.wrapInputStream(response);
				return new JdkClientHttpResponse(response, inputStream);
			}
			else {
				HttpResponse<InputStream> response = responseFuture.get();
				return new JdkClientHttpResponse(response, response.body());
			}
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
			responseFuture.cancel(true);
			throw new IOException(""Request was interrupted: "" + ex.getMessage(), ex);
		}
		catch (ExecutionException ex) {
			Throwable cause = ex.getCause();

			if (cause instanceof CancellationException) {
				if (timeoutHandler != null && timeoutHandler.isTimeout()) {
					throw new HttpTimeoutException(""Request timed out"");
				}
				throw new IOException(""Request was cancelled"");
			}
			if (cause instanceof UncheckedIOException uioEx) {
				throw uioEx.getCause();
			}
			if (cause instanceof RuntimeException rtEx) {
				throw rtEx;
			}
			else if (cause instanceof IOException ioEx) {
				throw ioEx;
			}
			else {
				throw new IOException(cause.getMessage(), cause);
			}
		}
		catch (CancellationException ex) {
			if (timeoutHandler != null && timeoutHandler.isTimeout()) {
				throw new HttpTimeoutException(""Request timed out"");
			}
			throw new IOException(""Request was cancelled"");
		}
	}

	private HttpRequest buildRequest(HttpHeaders headers, @Nullable Body body) {
		HttpRequest.Builder builder = HttpRequest.newBuilder().uri(this.uri);

		headers.forEach((headerName, headerValues) -> {
			if (!DISALLOWED_HEADERS.contains(headerName.toLowerCase(Locale.ROOT))) {
				for (String headerValue : headerValues) {
					builder.header(headerName, headerValue);
				}
			}
		});

		if (body != null) {
			builder.method(this.method.name(), bodyPublisher(headers, body));
		}
		else {
			switch (this.method.name()) {
				case ""GET"" :
					builder.GET();
					break;
				case ""DELETE"" :
					builder.DELETE();
					break;
				default :
					builder.method(this.method.name(), HttpRequest.BodyPublishers.noBody());
			}
		}
		return builder.build();
	}

	private HttpRequest.BodyPublisher bodyPublisher(HttpHeaders headers, Body body) {
		Flow.Publisher<ByteBuffer> publisher = new OutputStreamPublisher<>(
				os -> body.writeTo(StreamUtils.nonClosing(os)), BYTE_MAPPER, this.executor, null);

		long contentLength = headers.getContentLength();
		if (contentLength > 0) {
			return HttpRequest.BodyPublishers.fromPublisher(publisher, contentLength);
		}
		else if (contentLength == 0) {
			return HttpRequest.BodyPublishers.noBody();
		}
		else {
			return HttpRequest.BodyPublishers.fromPublisher(publisher);
		}
	}

	/**
	 * By default, {@link HttpRequest} does not allow {@code Connection},
	 * {@code Content-Length}, {@code Expect}, {@code Host}, or {@code Upgrade}
	 * headers to be set, but this can be overridden with the
	 * {@code jdk.httpclient.allowRestrictedHeaders} system property.
	 * @see jdk.internal.net.http.common.Utils#getDisallowedHeaders()
	 */
	private static Set<String> disallowedHeaders() {
		TreeSet<String> headers = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
		headers.addAll(Set.of(""connection"", ""content-length"", ""expect"", ""host"", ""upgrade""));

		String headersToAllow = System.getProperty(""jdk.httpclient.allowRestrictedHeaders"");
		if (headersToAllow != null) {
			Set<String> toAllow = StringUtils.commaDelimitedListToSet(headersToAllow);
			headers.removeAll(toAllow);
		}
		return Collections.unmodifiableSet(headers);
	}


	private static final class ByteBufferMapper implements OutputStreamPublisher.ByteMapper<ByteBuffer> {

		@Override
		public ByteBuffer map(int b) {
			ByteBuffer byteBuffer = ByteBuffer.allocate(1);
			byteBuffer.put((byte) b);
			byteBuffer.flip();
			return byteBuffer;
		}

		@Override
		public ByteBuffer map(byte[] b, int off, int len) {
			ByteBuffer byteBuffer = ByteBuffer.allocate(len);
			byteBuffer.put(b, off, len);
			byteBuffer.flip();
			return byteBuffer;
		}
	}


	/**
	 * Temporary workaround to use instead of {@link HttpRequest.Builder#timeout(Duration)}
	 * until <a href=""https://bugs.openjdk.org/browse/JDK-8258397"">JDK-8258397</a>
	 * is fixed. Essentially, create a future wiht a timeout handler, and use it
	 * to close the response.
	 * @see <a href=""https://mail.openjdk.org/pipermail/net-dev/2021-October/016672.html"">OpenJDK discussion thread</a>
	 */
	private static final class TimeoutHandler {

		private final CompletableFuture<Void> timeoutFuture;
		private final AtomicBoolean isTimeout = new AtomicBoolean(false);

		private TimeoutHandler(CompletableFuture<HttpResponse<InputStream>> future, Duration timeout) {

			this.timeoutFuture = new CompletableFuture<Void>()
					.completeOnTimeout(null, timeout.toMillis(), TimeUnit.MILLISECONDS);

			this.timeoutFuture.thenRun(() -> {
				if (future.cancel(true) || future.isCompletedExceptionally() || !future.isDone()) {
					isTimeout.set(true);
					return;
				}
				try {
					future.get().body().close();
				}
				catch (Exception ex) {
					// ignore
				}
			});

		}

		@Nullable
		public InputStream wrapInputStream(HttpResponse<InputStream> response) {
			InputStream body = response.body();
			if (body == null) {
				return body;
			}
			return new FilterInputStream(body) {

				@Override
				public void close() throws IOException {
					TimeoutHandler.this.timeoutFuture.cancel(false);
					super.close();
				}
			};
		}

		public boolean isTimeout() {
			return isTimeout.get();
		}
	}

}
"
7a55ce48a93f004c7acc0b51c04bb39be2c6b733,"Handle CancellationException in JdkClientHttpRequest

Handle CancellationException in order to throw an HttpTimeoutException
when the timeout handler caused the cancellation.

See gh-34721

Signed-off-by: giampaolo <giampaorr@gmail.com>

fix: use timeoutHandler with a flag isTimeout

    Closes gh-33973

    Signed-off-by: giampaolo <giampaorr@gmail.com>",ADD,,"package org.springframework.http.client;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.HttpTimeoutException;
import java.time.Duration;
import java.util.concurrent.*;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;

class JdkClientHttpRequestTest {

	private HttpClient mockHttpClient;
	private URI uri = URI.create(""http://example.com"");
	private HttpMethod method = HttpMethod.GET;

	private ExecutorService executor;

	@BeforeEach
	void setup() {
		mockHttpClient = mock(HttpClient.class);
		executor = Executors.newSingleThreadExecutor();
	}

	@AfterEach
	void tearDown() {
		executor.shutdownNow();
	}

	@Test
	void executeInternal_withTimeout_shouldThrowHttpTimeoutException() throws Exception {
		Duration timeout = Duration.ofMillis(10);

		JdkClientHttpRequest request = new JdkClientHttpRequest(mockHttpClient, uri, method, executor, timeout);

		CompletableFuture<HttpResponse<InputStream>> future = new CompletableFuture<>();

		when(mockHttpClient.sendAsync(any(HttpRequest.class), any(HttpResponse.BodyHandler.class)))
				.thenReturn(future);

		HttpHeaders headers = new HttpHeaders();

		CountDownLatch startLatch = new CountDownLatch(1);

		// Cancellation thread waits for startLatch, then cancels the future after a delay
		Thread canceller = new Thread(() -> {
			try {
				startLatch.await();
				Thread.sleep(500);
				future.cancel(true);
			} catch (InterruptedException ignored) {
			}
		});
		canceller.start();

		IOException ex = assertThrows(IOException.class, () -> {
			startLatch.countDown();
			request.executeInternal(headers, null);
		});

		assertThat(ex)
				.isInstanceOf(HttpTimeoutException.class)
				.hasMessage(""Request timed out"");

		canceller.join();
	}

	@Test
	void executeInternal_withTimeout_shouldThrowIOException() throws Exception {
		Duration timeout = Duration.ofMillis(500);

		JdkClientHttpRequest request = new JdkClientHttpRequest(mockHttpClient, uri, method, executor, timeout);

		CompletableFuture<HttpResponse<InputStream>> future = new CompletableFuture<>();

		when(mockHttpClient.sendAsync(any(HttpRequest.class), any(HttpResponse.BodyHandler.class)))
				.thenReturn(future);

		HttpHeaders headers = new HttpHeaders();

		CountDownLatch startLatch = new CountDownLatch(1);

		Thread canceller = new Thread(() -> {
			try {
				startLatch.await();
				Thread.sleep(10);
				future.cancel(true);
			} catch (InterruptedException ignored) {
			}
		});
		canceller.start();

		IOException ex = assertThrows(IOException.class, () -> {
			startLatch.countDown();
			request.executeInternal(headers, null);
		});

		assertThat(ex)
				.isInstanceOf(IOException.class)
				.hasMessage(""Request was cancelled"");

		canceller.join();
	}

}
"
ffc785471bbe579aaef282720baef00a44d46435,Fix checkstyle error,MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.http.client;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.HttpTimeoutException;
import java.time.Duration;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;

import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Unit tests for {@link JdkClientHttpRequest}.
 */
class JdkClientHttpRequestTests {

	private final HttpClient client = mock(HttpClient.class);

	private ExecutorService executor;


	@BeforeEach
	void setup() {
		executor = Executors.newSingleThreadExecutor();
	}

	@AfterEach
	void tearDown() {
		executor.shutdownNow();
	}


	@Test
	void futureCancelledAfterTimeout() {
		CompletableFuture<HttpResponse<InputStream>> future = new CompletableFuture<>();
		when(client.sendAsync(any(HttpRequest.class), any(HttpResponse.BodyHandler.class))).thenReturn(future);

		assertThatThrownBy(() -> createRequest(Duration.ofMillis(10)).executeInternal(new HttpHeaders(), null))
				.isExactlyInstanceOf(HttpTimeoutException.class);
	}

	@Test
	void futureCancelled() {
		CompletableFuture<HttpResponse<InputStream>> future = new CompletableFuture<>();
		future.cancel(true);
		when(client.sendAsync(any(HttpRequest.class), any(HttpResponse.BodyHandler.class))).thenReturn(future);

		assertThatThrownBy(() -> createRequest(null).executeInternal(new HttpHeaders(), null))
				.isExactlyInstanceOf(IOException.class);
	}

	private JdkClientHttpRequest createRequest(Duration timeout) {
		return new JdkClientHttpRequest(client, URI.create(""http://abc.com""), HttpMethod.GET, executor, timeout);
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.http.client;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.HttpTimeoutException;
import java.time.Duration;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;

import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Unit tests for {@link JdkClientHttpRequest}.
 */
class JdkClientHttpRequestTests {

	private final HttpClient client = mock(HttpClient.class);

	private ExecutorService executor;


	@BeforeEach
	void setup() {
		executor = Executors.newSingleThreadExecutor();
	}

	@AfterEach
	void tearDown() {
		executor.shutdownNow();
	}


	@Test
	void futureCancelledAfterTimeout() {
		CompletableFuture<HttpResponse<InputStream>> future = new CompletableFuture<>();
		when(client.sendAsync(any(HttpRequest.class), any(HttpResponse.BodyHandler.class))).thenReturn(future);

		assertThatThrownBy(() -> createRequest(Duration.ofMillis(10)).executeInternal(new HttpHeaders(), null))
				.isExactlyInstanceOf(HttpTimeoutException.class);
	}

	@Test
	void futureCancelled() {
		CompletableFuture<HttpResponse<InputStream>> future = new CompletableFuture<>();
		future.cancel(true);
		when(client.sendAsync(any(HttpRequest.class), any(HttpResponse.BodyHandler.class))).thenReturn(future);

		assertThatThrownBy(() -> createRequest(null).executeInternal(new HttpHeaders(), null))
				.isExactlyInstanceOf(IOException.class);
	}

	private JdkClientHttpRequest createRequest(Duration timeout) {
		return new JdkClientHttpRequest(client, URI.create(""https://abc.com""), HttpMethod.GET, executor, timeout);
	}

}
"
2b7f88ee449fb37c81f2e3649beaa643f9537357,"Fix annotation arrays support in ClassFile metadata

As of gh-33616, Spring now supports metadata reading with the ClassFile
API on JDK 24+ runtimes. This commit fixes a bug where
`ArrayStoreException` were thrown when reading annotation attribute
values for arrays.

Fixes gh-35252",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type.classreading;


import java.lang.classfile.Annotation;
import java.lang.classfile.AnnotationElement;
import java.lang.classfile.AnnotationValue;
import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;
import java.lang.constant.ClassDesc;
import java.lang.reflect.Array;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.jspecify.annotations.Nullable;

import org.springframework.core.annotation.AnnotationFilter;
import org.springframework.core.annotation.MergedAnnotation;
import org.springframework.core.annotation.MergedAnnotations;
import org.springframework.util.ClassUtils;

/**
 * Parse {@link RuntimeVisibleAnnotationsAttribute} into {@link MergedAnnotations}
 * instances.
 * @author Brian Clozel
 */
abstract class ClassFileAnnotationMetadata {

	static MergedAnnotations createMergedAnnotations(String className, RuntimeVisibleAnnotationsAttribute annotationAttribute, @Nullable ClassLoader classLoader) {
		Set<MergedAnnotation<?>> annotations = annotationAttribute.annotations()
				.stream()
				.map(ann -> createMergedAnnotation(className, ann, classLoader))
				.filter(Objects::nonNull)
				.collect(Collectors.toSet());
		return MergedAnnotations.of(annotations);
	}

	@SuppressWarnings(""unchecked"")
	private static <A extends java.lang.annotation.Annotation> @Nullable MergedAnnotation<A> createMergedAnnotation(String className, Annotation annotation, @Nullable ClassLoader classLoader) {
		String typeName = fromTypeDescriptor(annotation.className().stringValue());
		if (AnnotationFilter.PLAIN.matches(typeName)) {
			return null;
		}
		Map<String, Object> attributes = new LinkedHashMap<>(4);
		try {
			for (AnnotationElement element : annotation.elements()) {
				Object annotationValue = readAnnotationValue(className, element.value(), classLoader);
				if (annotationValue != null) {
					attributes.put(element.name().stringValue(), annotationValue);
				}
			}
			Map<String, Object> compactedAttributes = (attributes.isEmpty() ? Collections.emptyMap() : attributes);
			Class<A> annotationType = (Class<A>) ClassUtils.forName(typeName, classLoader);
			return MergedAnnotation.of(classLoader, new Source(annotation), annotationType, compactedAttributes);
		}
		catch (ClassNotFoundException | LinkageError ex) {
			return null;
		}
	}

	private static @Nullable Object readAnnotationValue(String className, AnnotationValue elementValue, @Nullable ClassLoader classLoader) {
		switch (elementValue) {
			case AnnotationValue.OfConstant constantValue -> {
				return constantValue.resolvedValue();
			}
			case AnnotationValue.OfAnnotation annotationValue -> {
				return createMergedAnnotation(className, annotationValue.annotation(), classLoader);
			}
			case AnnotationValue.OfClass classValue -> {
				return fromTypeDescriptor(classValue.className().stringValue());
			}
			case AnnotationValue.OfEnum enumValue -> {
				return parseEnum(enumValue, classLoader);
			}
			case AnnotationValue.OfArray arrayValue -> {
				return parseArrayValue(className, classLoader, arrayValue);
			}
		}
	}

	private static String fromTypeDescriptor(String descriptor) {
		ClassDesc classDesc = ClassDesc.ofDescriptor(descriptor);
		return classDesc.isPrimitive() ? classDesc.displayName() :
		classDesc.packageName() + ""."" + classDesc.displayName();
	}

	private static Object parseArrayValue(String className, @Nullable ClassLoader classLoader, AnnotationValue.OfArray arrayValue) {
		if (arrayValue.values().isEmpty()) {
			return new Object[0];
		}
		Stream<AnnotationValue> stream = arrayValue.values().stream();
		switch (arrayValue.values().getFirst()) {
			case AnnotationValue.OfInt _ -> {
				return stream.map(AnnotationValue.OfInt.class::cast).mapToInt(AnnotationValue.OfInt::intValue).toArray();
			}
			case AnnotationValue.OfDouble _ -> {
				return stream.map(AnnotationValue.OfDouble.class::cast).mapToDouble(AnnotationValue.OfDouble::doubleValue).toArray();
			}
			case AnnotationValue.OfLong _ -> {
				return stream.map(AnnotationValue.OfLong.class::cast).mapToLong(AnnotationValue.OfLong::longValue).toArray();
			}
			default -> {
				Object firstResolvedValue = readAnnotationValue(className, arrayValue.values().getFirst(), classLoader);
				return stream
						.map(rawValue -> readAnnotationValue(className, rawValue, classLoader))
						.toArray(s -> (Object[]) Array.newInstance(firstResolvedValue.getClass(), s));
			}
		}
	}

	@SuppressWarnings(""unchecked"")
	private static @Nullable <E extends Enum<E>> Enum<E> parseEnum(AnnotationValue.OfEnum enumValue, @Nullable ClassLoader classLoader) {
		String enumClassName = fromTypeDescriptor(enumValue.className().stringValue());
		try {
			Class<E> enumClass = (Class<E>) ClassUtils.forName(enumClassName, classLoader);
			return Enum.valueOf(enumClass, enumValue.constantName().stringValue());
		}
		catch (ClassNotFoundException | LinkageError ex) {
			return null;
		}
	}

	record Source(Annotation entryName) {

	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type.classreading;


import java.lang.classfile.Annotation;
import java.lang.classfile.AnnotationElement;
import java.lang.classfile.AnnotationValue;
import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;
import java.lang.constant.ClassDesc;
import java.lang.reflect.Array;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.jspecify.annotations.Nullable;

import org.springframework.core.annotation.AnnotationFilter;
import org.springframework.core.annotation.MergedAnnotation;
import org.springframework.core.annotation.MergedAnnotations;
import org.springframework.util.ClassUtils;

/**
 * Parse {@link RuntimeVisibleAnnotationsAttribute} into {@link MergedAnnotations}
 * instances.
 * @author Brian Clozel
 */
abstract class ClassFileAnnotationMetadata {

	static MergedAnnotations createMergedAnnotations(String className, RuntimeVisibleAnnotationsAttribute annotationAttribute, @Nullable ClassLoader classLoader) {
		Set<MergedAnnotation<?>> annotations = annotationAttribute.annotations()
				.stream()
				.map(ann -> createMergedAnnotation(className, ann, classLoader))
				.filter(Objects::nonNull)
				.collect(Collectors.toSet());
		return MergedAnnotations.of(annotations);
	}

	@SuppressWarnings(""unchecked"")
	private static <A extends java.lang.annotation.Annotation> @Nullable MergedAnnotation<A> createMergedAnnotation(String className, Annotation annotation, @Nullable ClassLoader classLoader) {
		String typeName = fromTypeDescriptor(annotation.className().stringValue());
		if (AnnotationFilter.PLAIN.matches(typeName)) {
			return null;
		}
		Map<String, Object> attributes = new LinkedHashMap<>(4);
		try {
			for (AnnotationElement element : annotation.elements()) {
				Object annotationValue = readAnnotationValue(className, element.value(), classLoader);
				if (annotationValue != null) {
					attributes.put(element.name().stringValue(), annotationValue);
				}
			}
			Map<String, Object> compactedAttributes = (attributes.isEmpty() ? Collections.emptyMap() : attributes);
			Class<A> annotationType = (Class<A>) ClassUtils.forName(typeName, classLoader);
			return MergedAnnotation.of(classLoader, new Source(annotation), annotationType, compactedAttributes);
		}
		catch (ClassNotFoundException | LinkageError ex) {
			return null;
		}
	}

	private static @Nullable Object readAnnotationValue(String className, AnnotationValue elementValue, @Nullable ClassLoader classLoader) {
		switch (elementValue) {
			case AnnotationValue.OfConstant constantValue -> {
				return constantValue.resolvedValue();
			}
			case AnnotationValue.OfAnnotation annotationValue -> {
				return createMergedAnnotation(className, annotationValue.annotation(), classLoader);
			}
			case AnnotationValue.OfClass classValue -> {
				return loadClass(classValue.className().stringValue(), classLoader);
			}
			case AnnotationValue.OfEnum enumValue -> {
				return parseEnum(enumValue, classLoader);
			}
			case AnnotationValue.OfArray arrayValue -> {
				return parseArrayValue(className, classLoader, arrayValue);
			}
		}
	}

	private static String fromTypeDescriptor(String descriptor) {
		ClassDesc classDesc = ClassDesc.ofDescriptor(descriptor);
		return classDesc.isPrimitive() ? classDesc.displayName() :
		classDesc.packageName() + ""."" + classDesc.displayName();
	}

	private static Class<?> loadClass(String className, @Nullable ClassLoader classLoader) {
		try {
			String name = fromTypeDescriptor(className);
			return ClassUtils.forName(name, classLoader);
		}
		catch (ClassNotFoundException ex) {
			return Object.class;
		}
	}

	private static Object parseArrayValue(String className, @Nullable ClassLoader classLoader, AnnotationValue.OfArray arrayValue) {
		if (arrayValue.values().isEmpty()) {
			return new Object[0];
		}
		Stream<AnnotationValue> stream = arrayValue.values().stream();
		switch (arrayValue.values().getFirst()) {
			case AnnotationValue.OfInt _ -> {
				return stream.map(AnnotationValue.OfInt.class::cast).mapToInt(AnnotationValue.OfInt::intValue).toArray();
			}
			case AnnotationValue.OfDouble _ -> {
				return stream.map(AnnotationValue.OfDouble.class::cast).mapToDouble(AnnotationValue.OfDouble::doubleValue).toArray();
			}
			case AnnotationValue.OfLong _ -> {
				return stream.map(AnnotationValue.OfLong.class::cast).mapToLong(AnnotationValue.OfLong::longValue).toArray();
			}
			default -> {
				Class<?> arrayElementType = resolveArrayElementType(arrayValue.values(), classLoader);
				return stream
						.map(rawValue -> readAnnotationValue(className, rawValue, classLoader))
						.toArray(s -> (Object[]) Array.newInstance(arrayElementType, s));
			}
		}
	}

	@SuppressWarnings(""unchecked"")
	private static @Nullable <E extends Enum<E>> Enum<E> parseEnum(AnnotationValue.OfEnum enumValue, @Nullable ClassLoader classLoader) {
		String enumClassName = fromTypeDescriptor(enumValue.className().stringValue());
		try {
			Class<E> enumClass = (Class<E>) ClassUtils.forName(enumClassName, classLoader);
			return Enum.valueOf(enumClass, enumValue.constantName().stringValue());
		}
		catch (ClassNotFoundException | LinkageError ex) {
			return null;
		}
	}

	private static Class<?> resolveArrayElementType(List<AnnotationValue> values, @Nullable ClassLoader classLoader) {
		AnnotationValue firstValue = values.getFirst();
		switch (firstValue) {
			case AnnotationValue.OfConstant constantValue -> {
				return constantValue.resolvedValue().getClass();
			}
			case AnnotationValue.OfAnnotation _ -> {
				return MergedAnnotation.class;
			}
			case AnnotationValue.OfClass _ -> {
				return Class.class;
			}
			case AnnotationValue.OfEnum enumValue -> {
				return loadClass(enumValue.className().stringValue(), classLoader);
			}
			default -> {
				return Object.class;
			}
		}
	}


	record Source(Annotation entryName) {

	}

}
"
2b7f88ee449fb37c81f2e3649beaa643f9537357,"Fix annotation arrays support in ClassFile metadata

As of gh-33616, Spring now supports metadata reading with the ClassFile
API on JDK 24+ runtimes. This commit fixes a bug where
`ArrayStoreException` were thrown when reading annotation attribute
values for arrays.

Fixes gh-35252",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type;

import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.Arrays;
import java.util.List;

import kotlin.Metadata;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import org.springframework.core.annotation.MergedAnnotation;
import org.springframework.util.MultiValueMap;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.entry;

/**
 * Base class for {@link AnnotationMetadata} tests.
 *
 * @author Phillip Webb
 * @author Sam Brannen
 * @author Brian Clozel
 */
public abstract class AbstractAnnotationMetadataTests {

	protected abstract AnnotationMetadata get(Class<?> source);

	@Nested
	class TypeTests {

		@Test
		void classEquals() {
			AnnotationMetadata testClass1 = get(TestClass.class);
			AnnotationMetadata testClass2 = get(TestClass.class);

			assertThat(testClass1).isEqualTo(testClass1);
			assertThat(testClass2).isEqualTo(testClass2);
			assertThat(testClass1).isEqualTo(testClass2);
			assertThat(testClass2).isEqualTo(testClass1);
		}

		@Test
		void memberClassEquals() {
			AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);
			AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);

			assertThat(testMemberClass1).isEqualTo(testMemberClass1);
			assertThat(testMemberClass2).isEqualTo(testMemberClass2);
			assertThat(testMemberClass1).isEqualTo(testMemberClass2);
			assertThat(testMemberClass2).isEqualTo(testMemberClass1);
		}

		@Test
		void classHashCode() {
			AnnotationMetadata testClass1 = get(TestClass.class);
			AnnotationMetadata testClass2 = get(TestClass.class);

			assertThat(testClass1).hasSameHashCodeAs(testClass2);
		}

		@Test
		void memberClassHashCode() {
			AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);
			AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);

			assertThat(testMemberClass1).hasSameHashCodeAs(testMemberClass2);
		}

		@Test
		void classToString() {
			assertThat(get(TestClass.class).toString()).isEqualTo(TestClass.class.getName());
		}

		@Test
		void getClassNameReturnsClassName() {
			assertThat(get(TestClass.class).getClassName()).isEqualTo(TestClass.class.getName());
		}

		@Test
		void isInterfaceWhenInterfaceReturnsTrue() {
			assertThat(get(TestInterface.class).isInterface()).isTrue();
			assertThat(get(TestAnnotation.class).isInterface()).isTrue();
		}

		@Test
		void isInterfaceWhenNotInterfaceReturnsFalse() {
			assertThat(get(TestClass.class).isInterface()).isFalse();
		}

		@Test
		void isAnnotationWhenAnnotationReturnsTrue() {
			assertThat(get(TestAnnotation.class).isAnnotation()).isTrue();
		}

		@Test
		void isAnnotationWhenNotAnnotationReturnsFalse() {
			assertThat(get(TestClass.class).isAnnotation()).isFalse();
			assertThat(get(TestInterface.class).isAnnotation()).isFalse();
		}

		@Test
		void isFinalWhenFinalReturnsTrue() {
			assertThat(get(TestFinalClass.class).isFinal()).isTrue();
		}

		@Test
		void isFinalWhenNonFinalReturnsFalse() {
			assertThat(get(TestClass.class).isFinal()).isFalse();
		}

		@Test
		void isIndependentWhenIndependentReturnsTrue() {
			assertThat(get(AbstractAnnotationMetadataTests.class).isIndependent()).isTrue();
			assertThat(get(TestClass.class).isIndependent()).isTrue();
		}

		@Test
		void isIndependentWhenNotIndependentReturnsFalse() {
			assertThat(get(TestNonStaticInnerClass.class).isIndependent()).isFalse();
		}

		@Test
		void getEnclosingClassNameWhenHasEnclosingClassReturnsEnclosingClass() {
			assertThat(get(TestClass.class).getEnclosingClassName()).isEqualTo(
					AbstractAnnotationMetadataTests.TypeTests.class.getName());
		}

		@Test
		void getEnclosingClassNameWhenHasNoEnclosingClassReturnsNull() {
			assertThat(get(AbstractAnnotationMetadataTests.class).getEnclosingClassName()).isNull();
		}

		@Test
		void getSuperClassNameWhenHasSuperClassReturnsName() {
			assertThat(get(TestSubclass.class).getSuperClassName()).isEqualTo(TestClass.class.getName());
			assertThat(get(TestClass.class).getSuperClassName()).isEqualTo(Object.class.getName());
		}

		@Test
		void getSuperClassNameWhenHasNoSuperClassReturnsNull() {
			assertThat(get(Object.class).getSuperClassName()).isNull();
			assertThat(get(TestInterface.class).getSuperClassName()).isIn(null, ""java.lang.Object"");
			assertThat(get(TestSubInterface.class).getSuperClassName()).isIn(null, ""java.lang.Object"");
		}

		@Test
		void getSuperClassNameWhenPackageInfoReturnsNull() throws Exception {
			Class<?> packageClass = Class.forName(getClass().getPackageName() + "".package-info"");
			assertThat(get(packageClass).getSuperClassName()).isNull();
		}

		@Test
		void getInterfaceNamesWhenHasInterfacesReturnsNames() {
			assertThat(get(TestSubclass.class).getInterfaceNames()).containsExactly(TestInterface.class.getName());
			assertThat(get(TestSubInterface.class).getInterfaceNames()).containsExactly(TestInterface.class.getName());
		}

		@Test
		void getInterfaceNamesWhenHasNoInterfacesReturnsEmptyArray() {
			assertThat(get(TestClass.class).getInterfaceNames()).isEmpty();
		}

		@Test
		void getMemberClassNamesWhenHasMemberClassesReturnsNames() {
			assertThat(get(TestMemberClass.class).getMemberClassNames()).containsExactlyInAnyOrder(
					TestMemberClass.TestMemberClassInnerClass.class.getName(), TestMemberClass.TestMemberClassInnerInterface.class.getName());
		}

		@Test
		void getMemberClassNamesWhenHasNestedMemberClassesReturnsOnlyFirstLevel() {
			assertThat(get(TestNestedMemberClass.class).getMemberClassNames()).containsOnly(
					TestNestedMemberClass.TestMemberClassInnerClassA.class.getName(),
					TestNestedMemberClass.TestMemberClassInnerClassB.class.getName());
		}

		@Test
		void getMemberClassNamesWhenHasNoMemberClassesReturnsEmptyArray() {
			assertThat(get(TestClass.class).getMemberClassNames()).isEmpty();
		}

		public static class TestClass {
		}

		public interface TestInterface {
		}

		public interface TestSubInterface extends TestInterface {
		}

		public @interface TestAnnotation {
		}

		public static final class TestFinalClass {
		}

		public class TestNonStaticInnerClass {
		}

		public static class TestSubclass extends TestClass implements TestInterface {
		}

		public static class TestMemberClass {

			public static class TestMemberClassInnerClass {
			}

			interface TestMemberClassInnerInterface {
			}

		}

		public static class TestNestedMemberClass {

			public static class TestMemberClassInnerClassA {

				public static class TestMemberClassInnerClassAA {

				}

			}

			public static class TestMemberClassInnerClassB {

			}

		}

	}

	@Nested
	class AnnotationTests {

		@Test
		void getAnnotationsReturnsDirectAnnotations() {
			assertThat(get(WithDirectAnnotations.class).getAnnotations().stream())
					.filteredOn(MergedAnnotation::isDirectlyPresent)
					.extracting(a -> a.getType().getName())
					.containsExactlyInAnyOrder(DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());
		}

		@Test
		void isAnnotatedWhenMatchesDirectAnnotationReturnsTrue() {
			assertThat(get(WithDirectAnnotations.class).isAnnotated(DirectAnnotation1.class.getName())).isTrue();
		}

		@Test
		void isAnnotatedWhenMatchesMetaAnnotationReturnsTrue() {
			assertThat(get(WithMetaAnnotations.class).isAnnotated(MetaAnnotation2.class.getName())).isTrue();
		}

		@Test
		void isAnnotatedWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
			assertThat(get(NoAnnotationClass.class).isAnnotated(DirectAnnotation1.class.getName())).isFalse();
		}

		@Test
		void getAnnotationAttributesReturnsAttributes() {
			assertThat(get(WithAnnotationAttributes.class).getAnnotationAttributes(AnnotationAttributes.class.getName()))
					.containsOnly(entry(""name"", ""test""), entry(""size"", 1));
		}

		@Test
		void getAllAnnotationAttributesReturnsAllAttributes() {
			MultiValueMap<String, Object> attributes =
					get(WithMetaAnnotationAttributes.class).getAllAnnotationAttributes(AnnotationAttributes.class.getName());
			assertThat(attributes).containsOnlyKeys(""name"", ""size"");
			assertThat(attributes.get(""name"")).containsExactlyInAnyOrder(""m1"", ""m2"");
			assertThat(attributes.get(""size"")).containsExactlyInAnyOrder(1, 2);
		}

		@Test
		void getComplexAttributeTypesReturnsAll() {
			MultiValueMap<String, Object> attributes =
					get(WithComplexAttributeTypes.class).getAllAnnotationAttributes(ComplexAttributes.class.getName());
			assertThat(attributes).containsOnlyKeys(""names"", ""count"", ""type"", ""subAnnotation"");
			assertThat(attributes.get(""names"")).hasSize(1);
			assertThat(attributes.get(""names"").get(0)).isEqualTo(new String[]{""first"", ""second""});
			assertThat(attributes.get(""count"")).containsExactlyInAnyOrder(TestEnum.ONE);
			assertThat(attributes.get(""type"")).containsExactlyInAnyOrder(TestEnum.class);
			assertThat(attributes.get(""subAnnotation"")).hasSize(1);
		}

		@Test
		void getComplexAttributeTypesReturnsAllWithKotlinMetadata() {
			MultiValueMap<String, Object> attributes =
					get(WithComplexAttributeTypes.class).getAllAnnotationAttributes(Metadata.class.getName());
			assertThat(attributes).containsKeys(""k"", ""mv"");
			int[] values = {42};
			assertThat(attributes.get(""mv"")).hasSize(1);
			assertThat(attributes.get(""mv"").get(0)).isEqualTo(values);
		}

		@Test
		void getAnnotationAttributeIntType() {
			MultiValueMap<String, Object> attributes =
					get(WithIntType.class).getAllAnnotationAttributes(ComplexAttributes.class.getName());
			assertThat(attributes).containsOnlyKeys(""names"", ""count"", ""type"", ""subAnnotation"");
			assertThat(attributes.get(""type"")).contains(int.class);
		}

		@Test
		void getRepeatableReturnsAttributes() {
			MultiValueMap<String, Object> attributes =
					get(WithRepeatableAnnotations.class).getAllAnnotationAttributes(RepeatableAnnotations.class.getName());
			assertThat(attributes).containsKeys(""value"");
			assertThat(attributes.get(""value"")).hasSize(1);
		}

		@Test
		void getAnnotationTypesReturnsDirectAnnotations() {
			AnnotationMetadata metadata = get(WithDirectAnnotations.class);
			assertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(
					DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());
		}

		@Test
		void getMetaAnnotationTypesReturnsMetaAnnotations() {
			AnnotationMetadata metadata = get(WithMetaAnnotations.class);
			assertThat(metadata.getMetaAnnotationTypes(MetaAnnotationRoot.class.getName()))
					.containsExactlyInAnyOrder(MetaAnnotation1.class.getName(), MetaAnnotation2.class.getName());
		}

		@Test
		void hasAnnotationWhenMatchesDirectAnnotationReturnsTrue() {
			assertThat(get(WithDirectAnnotations.class).hasAnnotation(DirectAnnotation1.class.getName())).isTrue();
		}

		@Test
		void hasAnnotationWhenMatchesMetaAnnotationReturnsFalse() {
			assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation1.class.getName())).isFalse();
			assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation2.class.getName())).isFalse();
		}

		@Test
		void hasAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
			assertThat(get(NoAnnotationClass.class).hasAnnotation(DirectAnnotation1.class.getName())).isFalse();
		}

		@Test
		void hasMetaAnnotationWhenMatchesDirectReturnsFalse() {
			assertThat(get(WithDirectAnnotations.class).hasMetaAnnotation(DirectAnnotation1.class.getName())).isFalse();
		}

		@Test
		void hasMetaAnnotationWhenMatchesMetaAnnotationReturnsTrue() {
			assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isTrue();
			assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation2.class.getName())).isTrue();
		}

		@Test
		void hasMetaAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
			assertThat(get(NoAnnotationClass.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isFalse();
		}

		@Test
		void hasAnnotatedMethodsWhenMatchesDirectAnnotationReturnsTrue() {
			assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isTrue();
		}

		@Test
		void hasAnnotatedMethodsWhenMatchesMetaAnnotationReturnsTrue() {
			assertThat(get(WithMetaAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isTrue();
		}

		@Test
		void hasAnnotatedMethodsWhenDoesNotMatchAnyAnnotationReturnsFalse() {
			assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isFalse();
			assertThat(get(WithNonAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isFalse();
		}

		@Test
		void getAnnotatedMethodsReturnsMatchingAnnotatedAndMetaAnnotatedMethods() {
			assertThat(get(WithDirectAndMetaAnnotatedMethods.class).getAnnotatedMethods(MetaAnnotation2.class.getName()))
					.extracting(MethodMetadata::getMethodName)
					.containsExactlyInAnyOrder(""direct"", ""meta"");
		}

		public static class WithAnnotatedMethod {

			@DirectAnnotation1
			public void test() {
			}

		}

		public static class WithMetaAnnotatedMethod {

			@MetaAnnotationRoot
			public void test() {
			}

		}

		public static class WithNonAnnotatedMethod {

		}

		public static class WithDirectAndMetaAnnotatedMethods {

			@MetaAnnotation2
			public void direct() {
			}

			@MetaAnnotationRoot
			public void meta() {
			}

		}

		@AnnotationAttributes(name = ""test"", size = 1)
		public static class WithAnnotationAttributes {
		}

		@MetaAnnotationAttributes1
		@MetaAnnotationAttributes2
		public static class WithMetaAnnotationAttributes {
		}

		@Retention(RetentionPolicy.RUNTIME)
		@AnnotationAttributes(name = ""m1"", size = 1)
		public @interface MetaAnnotationAttributes1 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		@AnnotationAttributes(name = ""m2"", size = 2)
		public @interface MetaAnnotationAttributes2 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface AnnotationAttributes {

			String name();

			int size();

		}


		@ComplexAttributes(names = {""first"", ""second""}, count = TestEnum.ONE,
				type = TestEnum.class, subAnnotation = @SubAnnotation(name=""spring""))
		@Metadata(mv = {42})
		public static class WithComplexAttributeTypes {
		}

		@ComplexAttributes(names = ""void"", count = TestEnum.ONE, type = int.class,
				subAnnotation = @SubAnnotation(name=""spring""))
		public static class WithIntType {

		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface ComplexAttributes {

			String[] names();

			TestEnum count();

			Class<?> type();

			SubAnnotation subAnnotation();
		}

		public @interface SubAnnotation {

			String name();
		}

		public enum TestEnum {
			ONE, TWO, THREE
		}

		@RepeatableAnnotation(name = ""first"")
		@RepeatableAnnotation(name = ""second"")
		public static class WithRepeatableAnnotations {

		}

		@Retention(RetentionPolicy.RUNTIME)
		@Repeatable(RepeatableAnnotations.class)
		public @interface RepeatableAnnotation {

			String name();

		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface RepeatableAnnotations {

			RepeatableAnnotation[] value();

		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface DirectAnnotation1 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface DirectAnnotation2 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		@MetaAnnotation1
		public @interface MetaAnnotationRoot {
		}

		@Retention(RetentionPolicy.RUNTIME)
		@MetaAnnotation2
		public @interface MetaAnnotation1 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface MetaAnnotation2 {
		}

		@DirectAnnotation1
		@DirectAnnotation2
		public static class WithDirectAnnotations {
		}

		@MetaAnnotationRoot
		public static class WithMetaAnnotations {
		}

		static class NoAnnotationClass {

		}

	}

	@Nested
	class MethodTests {

		@Test
		void declaredMethodsToString() {
			List<String> methods = get(TestMethods.class).getDeclaredMethods().stream().map(Object::toString).toList();
			List<String> expected = Arrays.stream(TestMethods.class.getDeclaredMethods()).map(Object::toString).toList();
			assertThat(methods).containsExactlyInAnyOrderElementsOf(expected);
		}

		static class TestMethods {
			public String test1(String argument) {
				return ""test"";
			}

			public String test2(String argument) {
				return ""test"";
			}

			public String test3(String argument) {
				return ""test"";
			}
		}

	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type;

import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.Arrays;
import java.util.List;

import kotlin.Metadata;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import org.springframework.core.annotation.MergedAnnotation;
import org.springframework.util.MultiValueMap;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.entry;

/**
 * Base class for {@link AnnotationMetadata} tests.
 *
 * @author Phillip Webb
 * @author Sam Brannen
 * @author Brian Clozel
 */
public abstract class AbstractAnnotationMetadataTests {

	protected abstract AnnotationMetadata get(Class<?> source);

	@Nested
	class TypeTests {

		@Test
		void classEquals() {
			AnnotationMetadata testClass1 = get(TestClass.class);
			AnnotationMetadata testClass2 = get(TestClass.class);

			assertThat(testClass1).isEqualTo(testClass1);
			assertThat(testClass2).isEqualTo(testClass2);
			assertThat(testClass1).isEqualTo(testClass2);
			assertThat(testClass2).isEqualTo(testClass1);
		}

		@Test
		void memberClassEquals() {
			AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);
			AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);

			assertThat(testMemberClass1).isEqualTo(testMemberClass1);
			assertThat(testMemberClass2).isEqualTo(testMemberClass2);
			assertThat(testMemberClass1).isEqualTo(testMemberClass2);
			assertThat(testMemberClass2).isEqualTo(testMemberClass1);
		}

		@Test
		void classHashCode() {
			AnnotationMetadata testClass1 = get(TestClass.class);
			AnnotationMetadata testClass2 = get(TestClass.class);

			assertThat(testClass1).hasSameHashCodeAs(testClass2);
		}

		@Test
		void memberClassHashCode() {
			AnnotationMetadata testMemberClass1 = get(TestMemberClass.class);
			AnnotationMetadata testMemberClass2 = get(TestMemberClass.class);

			assertThat(testMemberClass1).hasSameHashCodeAs(testMemberClass2);
		}

		@Test
		void classToString() {
			assertThat(get(TestClass.class).toString()).isEqualTo(TestClass.class.getName());
		}

		@Test
		void getClassNameReturnsClassName() {
			assertThat(get(TestClass.class).getClassName()).isEqualTo(TestClass.class.getName());
		}

		@Test
		void isInterfaceWhenInterfaceReturnsTrue() {
			assertThat(get(TestInterface.class).isInterface()).isTrue();
			assertThat(get(TestAnnotation.class).isInterface()).isTrue();
		}

		@Test
		void isInterfaceWhenNotInterfaceReturnsFalse() {
			assertThat(get(TestClass.class).isInterface()).isFalse();
		}

		@Test
		void isAnnotationWhenAnnotationReturnsTrue() {
			assertThat(get(TestAnnotation.class).isAnnotation()).isTrue();
		}

		@Test
		void isAnnotationWhenNotAnnotationReturnsFalse() {
			assertThat(get(TestClass.class).isAnnotation()).isFalse();
			assertThat(get(TestInterface.class).isAnnotation()).isFalse();
		}

		@Test
		void isFinalWhenFinalReturnsTrue() {
			assertThat(get(TestFinalClass.class).isFinal()).isTrue();
		}

		@Test
		void isFinalWhenNonFinalReturnsFalse() {
			assertThat(get(TestClass.class).isFinal()).isFalse();
		}

		@Test
		void isIndependentWhenIndependentReturnsTrue() {
			assertThat(get(AbstractAnnotationMetadataTests.class).isIndependent()).isTrue();
			assertThat(get(TestClass.class).isIndependent()).isTrue();
		}

		@Test
		void isIndependentWhenNotIndependentReturnsFalse() {
			assertThat(get(TestNonStaticInnerClass.class).isIndependent()).isFalse();
		}

		@Test
		void getEnclosingClassNameWhenHasEnclosingClassReturnsEnclosingClass() {
			assertThat(get(TestClass.class).getEnclosingClassName()).isEqualTo(
					AbstractAnnotationMetadataTests.TypeTests.class.getName());
		}

		@Test
		void getEnclosingClassNameWhenHasNoEnclosingClassReturnsNull() {
			assertThat(get(AbstractAnnotationMetadataTests.class).getEnclosingClassName()).isNull();
		}

		@Test
		void getSuperClassNameWhenHasSuperClassReturnsName() {
			assertThat(get(TestSubclass.class).getSuperClassName()).isEqualTo(TestClass.class.getName());
			assertThat(get(TestClass.class).getSuperClassName()).isEqualTo(Object.class.getName());
		}

		@Test
		void getSuperClassNameWhenHasNoSuperClassReturnsNull() {
			assertThat(get(Object.class).getSuperClassName()).isNull();
			assertThat(get(TestInterface.class).getSuperClassName()).isIn(null, ""java.lang.Object"");
			assertThat(get(TestSubInterface.class).getSuperClassName()).isIn(null, ""java.lang.Object"");
		}

		@Test
		void getSuperClassNameWhenPackageInfoReturnsNull() throws Exception {
			Class<?> packageClass = Class.forName(getClass().getPackageName() + "".package-info"");
			assertThat(get(packageClass).getSuperClassName()).isNull();
		}

		@Test
		void getInterfaceNamesWhenHasInterfacesReturnsNames() {
			assertThat(get(TestSubclass.class).getInterfaceNames()).containsExactly(TestInterface.class.getName());
			assertThat(get(TestSubInterface.class).getInterfaceNames()).containsExactly(TestInterface.class.getName());
		}

		@Test
		void getInterfaceNamesWhenHasNoInterfacesReturnsEmptyArray() {
			assertThat(get(TestClass.class).getInterfaceNames()).isEmpty();
		}

		@Test
		void getMemberClassNamesWhenHasMemberClassesReturnsNames() {
			assertThat(get(TestMemberClass.class).getMemberClassNames()).containsExactlyInAnyOrder(
					TestMemberClass.TestMemberClassInnerClass.class.getName(), TestMemberClass.TestMemberClassInnerInterface.class.getName());
		}

		@Test
		void getMemberClassNamesWhenHasNestedMemberClassesReturnsOnlyFirstLevel() {
			assertThat(get(TestNestedMemberClass.class).getMemberClassNames()).containsOnly(
					TestNestedMemberClass.TestMemberClassInnerClassA.class.getName(),
					TestNestedMemberClass.TestMemberClassInnerClassB.class.getName());
		}

		@Test
		void getMemberClassNamesWhenHasNoMemberClassesReturnsEmptyArray() {
			assertThat(get(TestClass.class).getMemberClassNames()).isEmpty();
		}

		public static class TestClass {
		}

		public interface TestInterface {
		}

		public interface TestSubInterface extends TestInterface {
		}

		public @interface TestAnnotation {
		}

		public static final class TestFinalClass {
		}

		public class TestNonStaticInnerClass {
		}

		public static class TestSubclass extends TestClass implements TestInterface {
		}

		public static class TestMemberClass {

			public static class TestMemberClassInnerClass {
			}

			interface TestMemberClassInnerInterface {
			}

		}

		public static class TestNestedMemberClass {

			public static class TestMemberClassInnerClassA {

				public static class TestMemberClassInnerClassAA {

				}

			}

			public static class TestMemberClassInnerClassB {

			}

		}

	}

	@Nested
	class AnnotationTests {

		@Test
		void getAnnotationsReturnsDirectAnnotations() {
			assertThat(get(WithDirectAnnotations.class).getAnnotations().stream())
					.filteredOn(MergedAnnotation::isDirectlyPresent)
					.extracting(a -> a.getType().getName())
					.containsExactlyInAnyOrder(DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());
		}

		@Test
		void isAnnotatedWhenMatchesDirectAnnotationReturnsTrue() {
			assertThat(get(WithDirectAnnotations.class).isAnnotated(DirectAnnotation1.class.getName())).isTrue();
		}

		@Test
		void isAnnotatedWhenMatchesMetaAnnotationReturnsTrue() {
			assertThat(get(WithMetaAnnotations.class).isAnnotated(MetaAnnotation2.class.getName())).isTrue();
		}

		@Test
		void isAnnotatedWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
			assertThat(get(NoAnnotationClass.class).isAnnotated(DirectAnnotation1.class.getName())).isFalse();
		}

		@Test
		void getAnnotationAttributesReturnsAttributes() {
			assertThat(get(WithAnnotationAttributes.class).getAnnotationAttributes(AnnotationAttributes.class.getName()))
					.containsOnly(entry(""name"", ""test""), entry(""size"", 1));
		}

		@Test
		void getAllAnnotationAttributesReturnsAllAttributes() {
			MultiValueMap<String, Object> attributes =
					get(WithMetaAnnotationAttributes.class).getAllAnnotationAttributes(AnnotationAttributes.class.getName());
			assertThat(attributes).containsOnlyKeys(""name"", ""size"");
			assertThat(attributes.get(""name"")).containsExactlyInAnyOrder(""m1"", ""m2"");
			assertThat(attributes.get(""size"")).containsExactlyInAnyOrder(1, 2);
		}

		@Test
		void getComplexAttributeTypesReturnsAll() {
			MultiValueMap<String, Object> attributes =
					get(WithComplexAttributeTypes.class).getAllAnnotationAttributes(ComplexAttributes.class.getName());
			assertThat(attributes).containsOnlyKeys(""names"", ""count"", ""types"", ""subAnnotation"");
			assertThat(attributes.get(""names"")).hasSize(1);
			assertThat(attributes.get(""names"").get(0)).isEqualTo(new String[]{""first"", ""second""});
			assertThat(attributes.get(""count"").get(0)).isEqualTo(new TestEnum[]{TestEnum.ONE, TestEnum.TWO});
			assertThat(attributes.get(""types"").get(0)).isEqualTo(new Class[]{TestEnum.class});
			assertThat(attributes.get(""subAnnotation"")).hasSize(1);
		}

		@Test
		void getComplexAttributeTypesReturnsAllWithKotlinMetadata() {
			MultiValueMap<String, Object> attributes =
					get(WithComplexAttributeTypes.class).getAllAnnotationAttributes(Metadata.class.getName());
			assertThat(attributes).containsKeys(""k"", ""mv"");
			int[] values = {42};
			assertThat(attributes.get(""mv"")).hasSize(1);
			assertThat(attributes.get(""mv"").get(0)).isEqualTo(values);
		}

		@Test
		void getAnnotationAttributeIntType() {
			MultiValueMap<String, Object> attributes =
					get(WithIntType.class).getAllAnnotationAttributes(ComplexAttributes.class.getName());
			assertThat(attributes).containsOnlyKeys(""names"", ""count"", ""types"", ""subAnnotation"");
			assertThat(attributes.get(""types"").get(0)).isEqualTo(new Class[]{int.class});
		}

		@Test
		void getRepeatableReturnsAttributes() {
			MultiValueMap<String, Object> attributes =
					get(WithRepeatableAnnotations.class).getAllAnnotationAttributes(RepeatableAnnotations.class.getName());
			assertThat(attributes).containsKeys(""value"");
			assertThat(attributes.get(""value"")).hasSize(1);
		}

		@Test
		void getAnnotationTypesReturnsDirectAnnotations() {
			AnnotationMetadata metadata = get(WithDirectAnnotations.class);
			assertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(
					DirectAnnotation1.class.getName(), DirectAnnotation2.class.getName());
		}

		@Test
		void getMetaAnnotationTypesReturnsMetaAnnotations() {
			AnnotationMetadata metadata = get(WithMetaAnnotations.class);
			assertThat(metadata.getMetaAnnotationTypes(MetaAnnotationRoot.class.getName()))
					.containsExactlyInAnyOrder(MetaAnnotation1.class.getName(), MetaAnnotation2.class.getName());
		}

		@Test
		void hasAnnotationWhenMatchesDirectAnnotationReturnsTrue() {
			assertThat(get(WithDirectAnnotations.class).hasAnnotation(DirectAnnotation1.class.getName())).isTrue();
		}

		@Test
		void hasAnnotationWhenMatchesMetaAnnotationReturnsFalse() {
			assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation1.class.getName())).isFalse();
			assertThat(get(WithMetaAnnotations.class).hasAnnotation(MetaAnnotation2.class.getName())).isFalse();
		}

		@Test
		void hasAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
			assertThat(get(NoAnnotationClass.class).hasAnnotation(DirectAnnotation1.class.getName())).isFalse();
		}

		@Test
		void hasMetaAnnotationWhenMatchesDirectReturnsFalse() {
			assertThat(get(WithDirectAnnotations.class).hasMetaAnnotation(DirectAnnotation1.class.getName())).isFalse();
		}

		@Test
		void hasMetaAnnotationWhenMatchesMetaAnnotationReturnsTrue() {
			assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isTrue();
			assertThat(get(WithMetaAnnotations.class).hasMetaAnnotation(MetaAnnotation2.class.getName())).isTrue();
		}

		@Test
		void hasMetaAnnotationWhenDoesNotMatchDirectOrMetaAnnotationReturnsFalse() {
			assertThat(get(NoAnnotationClass.class).hasMetaAnnotation(MetaAnnotation1.class.getName())).isFalse();
		}

		@Test
		void hasAnnotatedMethodsWhenMatchesDirectAnnotationReturnsTrue() {
			assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isTrue();
		}

		@Test
		void hasAnnotatedMethodsWhenMatchesMetaAnnotationReturnsTrue() {
			assertThat(get(WithMetaAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isTrue();
		}

		@Test
		void hasAnnotatedMethodsWhenDoesNotMatchAnyAnnotationReturnsFalse() {
			assertThat(get(WithAnnotatedMethod.class).hasAnnotatedMethods(MetaAnnotation2.class.getName())).isFalse();
			assertThat(get(WithNonAnnotatedMethod.class).hasAnnotatedMethods(DirectAnnotation1.class.getName())).isFalse();
		}

		@Test
		void getAnnotatedMethodsReturnsMatchingAnnotatedAndMetaAnnotatedMethods() {
			assertThat(get(WithDirectAndMetaAnnotatedMethods.class).getAnnotatedMethods(MetaAnnotation2.class.getName()))
					.extracting(MethodMetadata::getMethodName)
					.containsExactlyInAnyOrder(""direct"", ""meta"");
		}

		public static class WithAnnotatedMethod {

			@DirectAnnotation1
			public void test() {
			}

		}

		public static class WithMetaAnnotatedMethod {

			@MetaAnnotationRoot
			public void test() {
			}

		}

		public static class WithNonAnnotatedMethod {

		}

		public static class WithDirectAndMetaAnnotatedMethods {

			@MetaAnnotation2
			public void direct() {
			}

			@MetaAnnotationRoot
			public void meta() {
			}

		}

		@AnnotationAttributes(name = ""test"", size = 1)
		public static class WithAnnotationAttributes {
		}

		@MetaAnnotationAttributes1
		@MetaAnnotationAttributes2
		public static class WithMetaAnnotationAttributes {
		}

		@Retention(RetentionPolicy.RUNTIME)
		@AnnotationAttributes(name = ""m1"", size = 1)
		public @interface MetaAnnotationAttributes1 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		@AnnotationAttributes(name = ""m2"", size = 2)
		public @interface MetaAnnotationAttributes2 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface AnnotationAttributes {

			String name();

			int size();

		}


		@ComplexAttributes(names = {""first"", ""second""}, count = {TestEnum.ONE, TestEnum.TWO},
				types = {TestEnum.class}, subAnnotation = @SubAnnotation(name=""spring""))
		@Metadata(mv = {42})
		public static class WithComplexAttributeTypes {
		}

		@ComplexAttributes(names = ""void"", count = TestEnum.ONE, types = int.class,
				subAnnotation = @SubAnnotation(name=""spring""))
		public static class WithIntType {

		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface ComplexAttributes {

			String[] names();

			TestEnum[] count();

			Class<?>[] types();

			SubAnnotation subAnnotation();
		}

		public @interface SubAnnotation {

			String name();
		}

		public enum TestEnum {
			ONE {

			},
			TWO {

			},
			THREE {

			}
		}

		@RepeatableAnnotation(name = ""first"")
		@RepeatableAnnotation(name = ""second"")
		public static class WithRepeatableAnnotations {

		}

		@Retention(RetentionPolicy.RUNTIME)
		@Repeatable(RepeatableAnnotations.class)
		public @interface RepeatableAnnotation {

			String name();

		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface RepeatableAnnotations {

			RepeatableAnnotation[] value();

		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface DirectAnnotation1 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface DirectAnnotation2 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		@MetaAnnotation1
		public @interface MetaAnnotationRoot {
		}

		@Retention(RetentionPolicy.RUNTIME)
		@MetaAnnotation2
		public @interface MetaAnnotation1 {
		}

		@Retention(RetentionPolicy.RUNTIME)
		public @interface MetaAnnotation2 {
		}

		@DirectAnnotation1
		@DirectAnnotation2
		public static class WithDirectAnnotations {
		}

		@MetaAnnotationRoot
		public static class WithMetaAnnotations {
		}

		static class NoAnnotationClass {

		}

	}

	@Nested
	class MethodTests {

		@Test
		void declaredMethodsToString() {
			List<String> methods = get(TestMethods.class).getDeclaredMethods().stream().map(Object::toString).toList();
			List<String> expected = Arrays.stream(TestMethods.class.getDeclaredMethods()).map(Object::toString).toList();
			assertThat(methods).containsExactlyInAnyOrderElementsOf(expected);
		}

		static class TestMethods {
			public String test1(String argument) {
				return ""test"";
			}

			public String test2(String argument) {
				return ""test"";
			}

			public String test3(String argument) {
				return ""test"";
			}
		}

	}

}
"
81b4020fc6392025e5e55b2d26b7cd5bac1ca7fe,"Do not load concrete types in annotation metadata

This change fixes a regression introduced in the previous commit.

Closes gh-35252",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type.classreading;


import java.lang.classfile.Annotation;
import java.lang.classfile.AnnotationElement;
import java.lang.classfile.AnnotationValue;
import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;
import java.lang.constant.ClassDesc;
import java.lang.reflect.Array;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.jspecify.annotations.Nullable;

import org.springframework.core.annotation.AnnotationFilter;
import org.springframework.core.annotation.MergedAnnotation;
import org.springframework.core.annotation.MergedAnnotations;
import org.springframework.util.ClassUtils;

/**
 * Parse {@link RuntimeVisibleAnnotationsAttribute} into {@link MergedAnnotations}
 * instances.
 * @author Brian Clozel
 */
abstract class ClassFileAnnotationMetadata {

	static MergedAnnotations createMergedAnnotations(String className, RuntimeVisibleAnnotationsAttribute annotationAttribute, @Nullable ClassLoader classLoader) {
		Set<MergedAnnotation<?>> annotations = annotationAttribute.annotations()
				.stream()
				.map(ann -> createMergedAnnotation(className, ann, classLoader))
				.filter(Objects::nonNull)
				.collect(Collectors.toSet());
		return MergedAnnotations.of(annotations);
	}

	@SuppressWarnings(""unchecked"")
	private static <A extends java.lang.annotation.Annotation> @Nullable MergedAnnotation<A> createMergedAnnotation(String className, Annotation annotation, @Nullable ClassLoader classLoader) {
		String typeName = fromTypeDescriptor(annotation.className().stringValue());
		if (AnnotationFilter.PLAIN.matches(typeName)) {
			return null;
		}
		Map<String, Object> attributes = new LinkedHashMap<>(4);
		try {
			for (AnnotationElement element : annotation.elements()) {
				Object annotationValue = readAnnotationValue(className, element.value(), classLoader);
				if (annotationValue != null) {
					attributes.put(element.name().stringValue(), annotationValue);
				}
			}
			Map<String, Object> compactedAttributes = (attributes.isEmpty() ? Collections.emptyMap() : attributes);
			Class<A> annotationType = (Class<A>) ClassUtils.forName(typeName, classLoader);
			return MergedAnnotation.of(classLoader, new Source(annotation), annotationType, compactedAttributes);
		}
		catch (ClassNotFoundException | LinkageError ex) {
			return null;
		}
	}

	private static @Nullable Object readAnnotationValue(String className, AnnotationValue elementValue, @Nullable ClassLoader classLoader) {
		switch (elementValue) {
			case AnnotationValue.OfConstant constantValue -> {
				return constantValue.resolvedValue();
			}
			case AnnotationValue.OfAnnotation annotationValue -> {
				return createMergedAnnotation(className, annotationValue.annotation(), classLoader);
			}
			case AnnotationValue.OfClass classValue -> {
				return loadClass(classValue.className().stringValue(), classLoader);
			}
			case AnnotationValue.OfEnum enumValue -> {
				return parseEnum(enumValue, classLoader);
			}
			case AnnotationValue.OfArray arrayValue -> {
				return parseArrayValue(className, classLoader, arrayValue);
			}
		}
	}

	private static String fromTypeDescriptor(String descriptor) {
		ClassDesc classDesc = ClassDesc.ofDescriptor(descriptor);
		return classDesc.isPrimitive() ? classDesc.displayName() :
		classDesc.packageName() + ""."" + classDesc.displayName();
	}

	private static Class<?> loadClass(String className, @Nullable ClassLoader classLoader) {
		try {
			String name = fromTypeDescriptor(className);
			return ClassUtils.forName(name, classLoader);
		}
		catch (ClassNotFoundException ex) {
			return Object.class;
		}
	}

	private static Object parseArrayValue(String className, @Nullable ClassLoader classLoader, AnnotationValue.OfArray arrayValue) {
		if (arrayValue.values().isEmpty()) {
			return new Object[0];
		}
		Stream<AnnotationValue> stream = arrayValue.values().stream();
		switch (arrayValue.values().getFirst()) {
			case AnnotationValue.OfInt _ -> {
				return stream.map(AnnotationValue.OfInt.class::cast).mapToInt(AnnotationValue.OfInt::intValue).toArray();
			}
			case AnnotationValue.OfDouble _ -> {
				return stream.map(AnnotationValue.OfDouble.class::cast).mapToDouble(AnnotationValue.OfDouble::doubleValue).toArray();
			}
			case AnnotationValue.OfLong _ -> {
				return stream.map(AnnotationValue.OfLong.class::cast).mapToLong(AnnotationValue.OfLong::longValue).toArray();
			}
			default -> {
				Class<?> arrayElementType = resolveArrayElementType(arrayValue.values(), classLoader);
				return stream
						.map(rawValue -> readAnnotationValue(className, rawValue, classLoader))
						.toArray(s -> (Object[]) Array.newInstance(arrayElementType, s));
			}
		}
	}

	@SuppressWarnings(""unchecked"")
	private static @Nullable <E extends Enum<E>> Enum<E> parseEnum(AnnotationValue.OfEnum enumValue, @Nullable ClassLoader classLoader) {
		String enumClassName = fromTypeDescriptor(enumValue.className().stringValue());
		try {
			Class<E> enumClass = (Class<E>) ClassUtils.forName(enumClassName, classLoader);
			return Enum.valueOf(enumClass, enumValue.constantName().stringValue());
		}
		catch (ClassNotFoundException | LinkageError ex) {
			return null;
		}
	}

	private static Class<?> resolveArrayElementType(List<AnnotationValue> values, @Nullable ClassLoader classLoader) {
		AnnotationValue firstValue = values.getFirst();
		switch (firstValue) {
			case AnnotationValue.OfConstant constantValue -> {
				return constantValue.resolvedValue().getClass();
			}
			case AnnotationValue.OfAnnotation _ -> {
				return MergedAnnotation.class;
			}
			case AnnotationValue.OfClass _ -> {
				return Class.class;
			}
			case AnnotationValue.OfEnum enumValue -> {
				return loadClass(enumValue.className().stringValue(), classLoader);
			}
			default -> {
				return Object.class;
			}
		}
	}


	record Source(Annotation entryName) {

	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type.classreading;


import java.lang.classfile.Annotation;
import java.lang.classfile.AnnotationElement;
import java.lang.classfile.AnnotationValue;
import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;
import java.lang.constant.ClassDesc;
import java.lang.reflect.Array;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.jspecify.annotations.Nullable;

import org.springframework.core.annotation.AnnotationFilter;
import org.springframework.core.annotation.MergedAnnotation;
import org.springframework.core.annotation.MergedAnnotations;
import org.springframework.util.ClassUtils;

/**
 * Parse {@link RuntimeVisibleAnnotationsAttribute} into {@link MergedAnnotations}
 * instances.
 * @author Brian Clozel
 */
abstract class ClassFileAnnotationMetadata {

	static MergedAnnotations createMergedAnnotations(String className, RuntimeVisibleAnnotationsAttribute annotationAttribute, @Nullable ClassLoader classLoader) {
		Set<MergedAnnotation<?>> annotations = annotationAttribute.annotations()
				.stream()
				.map(ann -> createMergedAnnotation(className, ann, classLoader))
				.filter(Objects::nonNull)
				.collect(Collectors.toSet());
		return MergedAnnotations.of(annotations);
	}

	@SuppressWarnings(""unchecked"")
	private static <A extends java.lang.annotation.Annotation> @Nullable MergedAnnotation<A> createMergedAnnotation(String className, Annotation annotation, @Nullable ClassLoader classLoader) {
		String typeName = fromTypeDescriptor(annotation.className().stringValue());
		if (AnnotationFilter.PLAIN.matches(typeName)) {
			return null;
		}
		Map<String, Object> attributes = new LinkedHashMap<>(4);
		try {
			for (AnnotationElement element : annotation.elements()) {
				Object annotationValue = readAnnotationValue(className, element.value(), classLoader);
				if (annotationValue != null) {
					attributes.put(element.name().stringValue(), annotationValue);
				}
			}
			Map<String, Object> compactedAttributes = (attributes.isEmpty() ? Collections.emptyMap() : attributes);
			Class<A> annotationType = (Class<A>) ClassUtils.forName(typeName, classLoader);
			return MergedAnnotation.of(classLoader, new Source(annotation), annotationType, compactedAttributes);
		}
		catch (ClassNotFoundException | LinkageError ex) {
			return null;
		}
	}

	private static @Nullable Object readAnnotationValue(String className, AnnotationValue elementValue, @Nullable ClassLoader classLoader) {
		switch (elementValue) {
			case AnnotationValue.OfConstant constantValue -> {
				return constantValue.resolvedValue();
			}
			case AnnotationValue.OfAnnotation annotationValue -> {
				return createMergedAnnotation(className, annotationValue.annotation(), classLoader);
			}
			case AnnotationValue.OfClass classValue -> {
				return fromTypeDescriptor(classValue.className().stringValue());
			}
			case AnnotationValue.OfEnum enumValue -> {
				return parseEnum(enumValue, classLoader);
			}
			case AnnotationValue.OfArray arrayValue -> {
				return parseArrayValue(className, classLoader, arrayValue);
			}
		}
	}

	private static String fromTypeDescriptor(String descriptor) {
		ClassDesc classDesc = ClassDesc.ofDescriptor(descriptor);
		return classDesc.isPrimitive() ? classDesc.displayName() :
		classDesc.packageName() + ""."" + classDesc.displayName();
	}

	private static Class<?> loadClass(String className, @Nullable ClassLoader classLoader) {
		String name = fromTypeDescriptor(className);
		return ClassUtils.resolveClassName(name, classLoader);
	}

	private static Object parseArrayValue(String className, @Nullable ClassLoader classLoader, AnnotationValue.OfArray arrayValue) {
		if (arrayValue.values().isEmpty()) {
			return new Object[0];
		}
		Stream<AnnotationValue> stream = arrayValue.values().stream();
		switch (arrayValue.values().getFirst()) {
			case AnnotationValue.OfInt _ -> {
				return stream.map(AnnotationValue.OfInt.class::cast).mapToInt(AnnotationValue.OfInt::intValue).toArray();
			}
			case AnnotationValue.OfDouble _ -> {
				return stream.map(AnnotationValue.OfDouble.class::cast).mapToDouble(AnnotationValue.OfDouble::doubleValue).toArray();
			}
			case AnnotationValue.OfLong _ -> {
				return stream.map(AnnotationValue.OfLong.class::cast).mapToLong(AnnotationValue.OfLong::longValue).toArray();
			}
			default -> {
				Class<?> arrayElementType = resolveArrayElementType(arrayValue.values(), classLoader);
				return stream
						.map(rawValue -> readAnnotationValue(className, rawValue, classLoader))
						.toArray(s -> (Object[]) Array.newInstance(arrayElementType, s));
			}
		}
	}

	@SuppressWarnings(""unchecked"")
	private static @Nullable <E extends Enum<E>> Enum<E> parseEnum(AnnotationValue.OfEnum enumValue, @Nullable ClassLoader classLoader) {
		String enumClassName = fromTypeDescriptor(enumValue.className().stringValue());
		try {
			Class<E> enumClass = (Class<E>) ClassUtils.forName(enumClassName, classLoader);
			return Enum.valueOf(enumClass, enumValue.constantName().stringValue());
		}
		catch (ClassNotFoundException | LinkageError ex) {
			return null;
		}
	}

	private static Class<?> resolveArrayElementType(List<AnnotationValue> values, @Nullable ClassLoader classLoader) {
		AnnotationValue firstValue = values.getFirst();
		switch (firstValue) {
			case AnnotationValue.OfConstant constantValue -> {
				return constantValue.resolvedValue().getClass();
			}
			case AnnotationValue.OfAnnotation _ -> {
				return MergedAnnotation.class;
			}
			case AnnotationValue.OfClass _ -> {
				return String.class;
			}
			case AnnotationValue.OfEnum enumValue -> {
				return loadClass(enumValue.className().stringValue(), classLoader);
			}
			default -> {
				return Object.class;
			}
		}
	}


	record Source(Annotation entryName) {

	}

}
"
81b4020fc6392025e5e55b2d26b7cd5bac1ca7fe,"Do not load concrete types in annotation metadata

This change fixes a regression introduced in the previous commit.

Closes gh-35252",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type.classreading;

import org.springframework.core.type.AbstractAnnotationMetadataTests;
import org.springframework.core.type.AnnotationMetadata;

/**
 * Tests for {@link SimpleAnnotationMetadata} and
 * {@link SimpleAnnotationMetadataReadingVisitor} on Java < 24,
 * and for the ClassFile API variant on Java >= 24.
 *
 * @author Phillip Webb
 */
class DefaultAnnotationMetadataTests extends AbstractAnnotationMetadataTests {

	@Override
	protected AnnotationMetadata get(Class<?> source) {
		try {
			return MetadataReaderFactory.create(source.getClassLoader())
					.getMetadataReader(source.getName()).getAnnotationMetadata();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type.classreading;

import java.io.IOException;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.junit.jupiter.api.Test;

import org.springframework.core.type.AbstractAnnotationMetadataTests;
import org.springframework.core.type.AnnotationMetadata;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;

/**
 * Tests for {@link SimpleAnnotationMetadata} and
 * {@link SimpleAnnotationMetadataReadingVisitor} on Java < 24,
 * and for the ClassFile API variant on Java >= 24.
 *
 * @author Phillip Webb
 * @author Brian Clozel
 */
class DefaultAnnotationMetadataTests extends AbstractAnnotationMetadataTests {

	@Override
	protected AnnotationMetadata get(Class<?> source) {
		try {
			return MetadataReaderFactory.create(source.getClassLoader())
					.getMetadataReader(source.getName()).getAnnotationMetadata();
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}

	@Test
	void getClassAttributeWhenUnknownClass() {
		var annotation = get(WithClassMissingFromClasspath.class).getAnnotations().get(ClassAttributes.class);
		assertThat(annotation.getStringArray(""types"")).contains(""com.github.benmanes.caffeine.cache.Caffeine"");
		assertThatIllegalArgumentException().isThrownBy(() -> annotation.getClassArray(""types""));
	}

	@ClassAttributes(types = {Caffeine.class})
	public static class WithClassMissingFromClasspath {
	}

	@Retention(RetentionPolicy.RUNTIME)
	public @interface ClassAttributes {
		Class<?>[] types();
	}

}
"
81b4020fc6392025e5e55b2d26b7cd5bac1ca7fe,"Do not load concrete types in annotation metadata

This change fixes a regression introduced in the previous commit.

Closes gh-35252",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type.classreading;

import org.springframework.core.type.AbstractAnnotationMetadataTests;
import org.springframework.core.type.AnnotationMetadata;

/**
 * Tests for {@link SimpleAnnotationMetadata} and
 * {@link SimpleAnnotationMetadataReadingVisitor}.
 *
 * @author Phillip Webb
 */
class SimpleAnnotationMetadataTests extends AbstractAnnotationMetadataTests {

	@Override
	protected AnnotationMetadata get(Class<?> source) {
		try {
			return new SimpleMetadataReaderFactory(
					source.getClassLoader()).getMetadataReader(
							source.getName()).getAnnotationMetadata();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.type.classreading;

import java.io.IOException;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.junit.jupiter.api.Test;

import org.springframework.core.type.AbstractAnnotationMetadataTests;
import org.springframework.core.type.AnnotationMetadata;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;

/**
 * Tests for {@link SimpleAnnotationMetadata} and
 * {@link SimpleAnnotationMetadataReadingVisitor}.
 *
 * @author Phillip Webb
 * @author Brian Clozel
 */
class SimpleAnnotationMetadataTests extends AbstractAnnotationMetadataTests {

	@Override
	protected AnnotationMetadata get(Class<?> source) {
		try {
			return new SimpleMetadataReaderFactory(
					source.getClassLoader()).getMetadataReader(
							source.getName()).getAnnotationMetadata();
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}

	@Test
	void getClassAttributeWhenUnknownClass() {
		var annotation = get(WithClassMissingFromClasspath.class).getAnnotations().get(ClassAttributes.class);
		assertThat(annotation.getStringArray(""types"")).contains(""com.github.benmanes.caffeine.cache.Caffeine"");
		assertThatIllegalArgumentException().isThrownBy(() -> annotation.getClassArray(""types""));
	}

	@ClassAttributes(types = {Caffeine.class})
	public static class WithClassMissingFromClasspath {
	}


	@Retention(RetentionPolicy.RUNTIME)
	public @interface ClassAttributes {
		Class<?>[] types();
	}

}
"
764336f0f201c34ba0e636324e4b31da922c81c1,"Fix Jetty DataBufferFactory memory leak

Prior to this commit, gh-32097 added native support for Jetty for both
client and server integrations. The `JettyDataBufferFactory` was
promoted as a first class citizen, extracted from a private class in the
client support. To accomodate with server-side requirements, an extra
`buffer.retain()` call was performed.
While this is useful for server-side support, this introduced a bug in
the data buffer factory, as wrapping an existing chunk means that this
chunk is already retained.

This commit fixes the buffer factory implementation and moved existing
tests from mocks to actual pooled buffer implementations from Jetty.
The extra `buffer.retain()` is now done from the server support, right
before wrapping the buffer.

Fixes gh-35319",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.io.buffer;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.IntPredicate;

import org.eclipse.jetty.io.Content;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Implementation of the {@code DataBuffer} interface that can wrap a Jetty
 * {@link Content.Chunk}. Typically constructed with {@link JettyDataBufferFactory}.
 *
 * @author Greg Wilkins
 * @author Lachlan Roberts
 * @author Arjen Poutsma
 * @since 6.2
 */
public final class JettyDataBuffer implements PooledDataBuffer {

	private final DefaultDataBuffer delegate;

	@Nullable
	private final Content.Chunk chunk;

	private final JettyDataBufferFactory bufferFactory;

	private final AtomicInteger refCount = new AtomicInteger(1);


	JettyDataBuffer(JettyDataBufferFactory bufferFactory, DefaultDataBuffer delegate, Content.Chunk chunk) {
		Assert.notNull(bufferFactory, ""BufferFactory must not be null"");
		Assert.notNull(delegate, ""Delegate must not be null"");
		Assert.notNull(chunk, ""Chunk must not be null"");

		this.bufferFactory = bufferFactory;
		this.delegate = delegate;
		this.chunk = chunk;
		this.chunk.retain();
	}

	JettyDataBuffer(JettyDataBufferFactory bufferFactory, DefaultDataBuffer delegate) {
		Assert.notNull(bufferFactory, ""BufferFactory must not be null"");
		Assert.notNull(delegate, ""Delegate must not be null"");

		this.bufferFactory = bufferFactory;
		this.delegate = delegate;
		this.chunk = null;
	}


	@Override
	public boolean isAllocated() {
		return this.refCount.get() > 0;
	}

	@Override
	public PooledDataBuffer retain() {
		int result = this.refCount.updateAndGet(c -> (c != 0 ? c + 1 : 0));
		if (result != 0 && this.chunk != null) {
			this.chunk.retain();
		}
		return this;
	}

	@Override
	public PooledDataBuffer touch(Object hint) {
		return this;
	}

	@Override
	public boolean release() {
		int result = this.refCount.updateAndGet(c -> {
			if (c != 0) {
				return c - 1;
			}
			else {
				throw new IllegalStateException(""JettyDataBuffer already released: "" + this);
			}
		});
		if (this.chunk != null) {
			return this.chunk.release();
		}
		else {
			return (result == 0);
		}
	}

	@Override
	public DataBufferFactory factory() {
		return this.bufferFactory;
	}


	// delegation

	@Override
	public int indexOf(IntPredicate predicate, int fromIndex) {
		return this.delegate.indexOf(predicate, fromIndex);
	}

	@Override
	public int lastIndexOf(IntPredicate predicate, int fromIndex) {
		return this.delegate.lastIndexOf(predicate, fromIndex);
	}

	@Override
	public int readableByteCount() {
		return this.delegate.readableByteCount();
	}

	@Override
	public int writableByteCount() {
		return this.delegate.writableByteCount();
	}

	@Override
	public int capacity() {
		return this.delegate.capacity();
	}

	@Override
	@Deprecated
	public DataBuffer capacity(int capacity) {
		this.delegate.capacity(capacity);
		return this;
	}

	@Override
	public DataBuffer ensureWritable(int capacity) {
		this.delegate.ensureWritable(capacity);
		return this;
	}

	@Override
	public int readPosition() {
		return this.delegate.readPosition();
	}

	@Override
	public DataBuffer readPosition(int readPosition) {
		this.delegate.readPosition(readPosition);
		return this;
	}

	@Override
	public int writePosition() {
		return this.delegate.writePosition();
	}

	@Override
	public DataBuffer writePosition(int writePosition) {
		this.delegate.writePosition(writePosition);
		return this;
	}

	@Override
	public byte getByte(int index) {
		return this.delegate.getByte(index);
	}

	@Override
	public byte read() {
		return this.delegate.read();
	}

	@Override
	public DataBuffer read(byte[] destination) {
		this.delegate.read(destination);
		return this;
	}

	@Override
	public DataBuffer read(byte[] destination, int offset, int length) {
		this.delegate.read(destination, offset, length);
		return this;
	}

	@Override
	public DataBuffer write(byte b) {
		this.delegate.write(b);
		return this;
	}

	@Override
	public DataBuffer write(byte[] source) {
		this.delegate.write(source);
		return this;
	}

	@Override
	public DataBuffer write(byte[] source, int offset, int length) {
		this.delegate.write(source, offset, length);
		return this;
	}

	@Override
	public DataBuffer write(DataBuffer... buffers) {
		this.delegate.write(buffers);
		return this;
	}

	@Override
	public DataBuffer write(ByteBuffer... buffers) {
		this.delegate.write(buffers);
		return this;
	}

	@Override
	@Deprecated
	public DataBuffer slice(int index, int length) {
		DefaultDataBuffer delegateSlice = this.delegate.slice(index, length);
		if (this.chunk != null) {
			this.chunk.retain();
			return new JettyDataBuffer(this.bufferFactory, delegateSlice, this.chunk);
		}
		else {
			return new JettyDataBuffer(this.bufferFactory, delegateSlice);
		}
	}

	@Override
	public DataBuffer split(int index) {
		DefaultDataBuffer delegateSplit = this.delegate.split(index);
		if (this.chunk != null) {
			this.chunk.retain();
			return new JettyDataBuffer(this.bufferFactory, delegateSplit, this.chunk);
		}
		else {
			return new JettyDataBuffer(this.bufferFactory, delegateSplit);
		}
	}

	@Override
	@Deprecated
	public ByteBuffer asByteBuffer() {
		return this.delegate.asByteBuffer();
	}

	@Override
	@Deprecated
	public ByteBuffer asByteBuffer(int index, int length) {
		return this.delegate.asByteBuffer(index, length);
	}

	@Override
	@Deprecated
	public ByteBuffer toByteBuffer(int index, int length) {
		return this.delegate.toByteBuffer(index, length);
	}

	@Override
	public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {
		this.delegate.toByteBuffer(srcPos, dest, destPos, length);
	}

	@Override
	public ByteBufferIterator readableByteBuffers() {
		ByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();
		if (this.chunk != null) {
			return new JettyByteBufferIterator(delegateIterator, this.chunk);
		}
		else {
			return delegateIterator;
		}
	}

	@Override
	public ByteBufferIterator writableByteBuffers() {
		ByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();
		if (this.chunk != null) {
			return new JettyByteBufferIterator(delegateIterator, this.chunk);
		}
		else {
			return delegateIterator;
		}
	}

	@Override
	public String toString(int index, int length, Charset charset) {
		return this.delegate.toString(index, length, charset);
	}


	@Override
	public boolean equals(Object other) {
		return (this == other || (other instanceof JettyDataBuffer otherBuffer &&
				this.delegate.equals(otherBuffer.delegate)));
	}

	@Override
	public int hashCode() {
		return this.delegate.hashCode();
	}

	@Override
	public String toString() {
		return String.format(""JettyDataBuffer (r: %d, w: %d, c: %d)"",
				readPosition(), writePosition(), capacity());
	}


	private static final class JettyByteBufferIterator implements ByteBufferIterator {

		private final ByteBufferIterator delegate;

		private final Content.Chunk chunk;

		public JettyByteBufferIterator(ByteBufferIterator delegate, Content.Chunk chunk) {
			Assert.notNull(delegate, ""Delegate must not be null"");
			Assert.notNull(chunk, ""Chunk must not be null"");

			this.delegate = delegate;
			this.chunk = chunk;
			this.chunk.retain();
		}

		@Override
		public void close() {
			this.delegate.close();
			this.chunk.release();
		}

		@Override
		public boolean hasNext() {
			return this.delegate.hasNext();
		}

		@Override
		public ByteBuffer next() {
			return this.delegate.next();
		}
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.io.buffer;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.IntPredicate;

import org.eclipse.jetty.io.Content;

import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * Implementation of the {@code DataBuffer} interface that can wrap a Jetty
 * {@link Content.Chunk}. Typically constructed with {@link JettyDataBufferFactory}.
 *
 * @author Greg Wilkins
 * @author Lachlan Roberts
 * @author Arjen Poutsma
 * @since 6.2
 */
public final class JettyDataBuffer implements PooledDataBuffer {

	private final DefaultDataBuffer delegate;

	@Nullable
	private final Content.Chunk chunk;

	private final JettyDataBufferFactory bufferFactory;

	private final AtomicInteger refCount = new AtomicInteger(1);


	JettyDataBuffer(JettyDataBufferFactory bufferFactory, DefaultDataBuffer delegate, Content.Chunk chunk) {
		Assert.notNull(bufferFactory, ""BufferFactory must not be null"");
		Assert.notNull(delegate, ""Delegate must not be null"");
		Assert.notNull(chunk, ""Chunk must not be null"");

		this.bufferFactory = bufferFactory;
		this.delegate = delegate;
		this.chunk = chunk;
	}

	JettyDataBuffer(JettyDataBufferFactory bufferFactory, DefaultDataBuffer delegate) {
		Assert.notNull(bufferFactory, ""BufferFactory must not be null"");
		Assert.notNull(delegate, ""Delegate must not be null"");

		this.bufferFactory = bufferFactory;
		this.delegate = delegate;
		this.chunk = null;
	}


	@Override
	public boolean isAllocated() {
		return this.refCount.get() > 0;
	}

	@Override
	public PooledDataBuffer retain() {
		int result = this.refCount.updateAndGet(c -> (c != 0 ? c + 1 : 0));
		if (result != 0 && this.chunk != null) {
			this.chunk.retain();
		}
		return this;
	}

	@Override
	public PooledDataBuffer touch(Object hint) {
		return this;
	}

	@Override
	public boolean release() {
		int result = this.refCount.updateAndGet(c -> {
			if (c != 0) {
				return c - 1;
			}
			else {
				throw new IllegalStateException(""JettyDataBuffer already released: "" + this);
			}
		});
		if (this.chunk != null) {
			return this.chunk.release();
		}
		else {
			return (result == 0);
		}
	}

	@Override
	public DataBufferFactory factory() {
		return this.bufferFactory;
	}


	// delegation

	@Override
	public int indexOf(IntPredicate predicate, int fromIndex) {
		return this.delegate.indexOf(predicate, fromIndex);
	}

	@Override
	public int lastIndexOf(IntPredicate predicate, int fromIndex) {
		return this.delegate.lastIndexOf(predicate, fromIndex);
	}

	@Override
	public int readableByteCount() {
		return this.delegate.readableByteCount();
	}

	@Override
	public int writableByteCount() {
		return this.delegate.writableByteCount();
	}

	@Override
	public int capacity() {
		return this.delegate.capacity();
	}

	@Override
	@Deprecated
	public DataBuffer capacity(int capacity) {
		this.delegate.capacity(capacity);
		return this;
	}

	@Override
	public DataBuffer ensureWritable(int capacity) {
		this.delegate.ensureWritable(capacity);
		return this;
	}

	@Override
	public int readPosition() {
		return this.delegate.readPosition();
	}

	@Override
	public DataBuffer readPosition(int readPosition) {
		this.delegate.readPosition(readPosition);
		return this;
	}

	@Override
	public int writePosition() {
		return this.delegate.writePosition();
	}

	@Override
	public DataBuffer writePosition(int writePosition) {
		this.delegate.writePosition(writePosition);
		return this;
	}

	@Override
	public byte getByte(int index) {
		return this.delegate.getByte(index);
	}

	@Override
	public byte read() {
		return this.delegate.read();
	}

	@Override
	public DataBuffer read(byte[] destination) {
		this.delegate.read(destination);
		return this;
	}

	@Override
	public DataBuffer read(byte[] destination, int offset, int length) {
		this.delegate.read(destination, offset, length);
		return this;
	}

	@Override
	public DataBuffer write(byte b) {
		this.delegate.write(b);
		return this;
	}

	@Override
	public DataBuffer write(byte[] source) {
		this.delegate.write(source);
		return this;
	}

	@Override
	public DataBuffer write(byte[] source, int offset, int length) {
		this.delegate.write(source, offset, length);
		return this;
	}

	@Override
	public DataBuffer write(DataBuffer... buffers) {
		this.delegate.write(buffers);
		return this;
	}

	@Override
	public DataBuffer write(ByteBuffer... buffers) {
		this.delegate.write(buffers);
		return this;
	}

	@Override
	@Deprecated
	public DataBuffer slice(int index, int length) {
		DefaultDataBuffer delegateSlice = this.delegate.slice(index, length);
		if (this.chunk != null) {
			this.chunk.retain();
			return new JettyDataBuffer(this.bufferFactory, delegateSlice, this.chunk);
		}
		else {
			return new JettyDataBuffer(this.bufferFactory, delegateSlice);
		}
	}

	@Override
	public DataBuffer split(int index) {
		DefaultDataBuffer delegateSplit = this.delegate.split(index);
		if (this.chunk != null) {
			this.chunk.retain();
			return new JettyDataBuffer(this.bufferFactory, delegateSplit, this.chunk);
		}
		else {
			return new JettyDataBuffer(this.bufferFactory, delegateSplit);
		}
	}

	@Override
	@Deprecated
	public ByteBuffer asByteBuffer() {
		return this.delegate.asByteBuffer();
	}

	@Override
	@Deprecated
	public ByteBuffer asByteBuffer(int index, int length) {
		return this.delegate.asByteBuffer(index, length);
	}

	@Override
	@Deprecated
	public ByteBuffer toByteBuffer(int index, int length) {
		return this.delegate.toByteBuffer(index, length);
	}

	@Override
	public void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {
		this.delegate.toByteBuffer(srcPos, dest, destPos, length);
	}

	@Override
	public ByteBufferIterator readableByteBuffers() {
		ByteBufferIterator delegateIterator = this.delegate.readableByteBuffers();
		if (this.chunk != null) {
			return new JettyByteBufferIterator(delegateIterator, this.chunk);
		}
		else {
			return delegateIterator;
		}
	}

	@Override
	public ByteBufferIterator writableByteBuffers() {
		ByteBufferIterator delegateIterator = this.delegate.writableByteBuffers();
		if (this.chunk != null) {
			return new JettyByteBufferIterator(delegateIterator, this.chunk);
		}
		else {
			return delegateIterator;
		}
	}

	@Override
	public String toString(int index, int length, Charset charset) {
		return this.delegate.toString(index, length, charset);
	}


	@Override
	public boolean equals(Object other) {
		return (this == other || (other instanceof JettyDataBuffer otherBuffer &&
				this.delegate.equals(otherBuffer.delegate)));
	}

	@Override
	public int hashCode() {
		return this.delegate.hashCode();
	}

	@Override
	public String toString() {
		return String.format(""JettyDataBuffer (r: %d, w: %d, c: %d)"",
				readPosition(), writePosition(), capacity());
	}


	private static final class JettyByteBufferIterator implements ByteBufferIterator {

		private final ByteBufferIterator delegate;

		private final Content.Chunk chunk;

		public JettyByteBufferIterator(ByteBufferIterator delegate, Content.Chunk chunk) {
			Assert.notNull(delegate, ""Delegate must not be null"");
			Assert.notNull(chunk, ""Chunk must not be null"");

			this.delegate = delegate;
			this.chunk = chunk;
			this.chunk.retain();
		}

		@Override
		public void close() {
			this.delegate.close();
			this.chunk.release();
		}

		@Override
		public boolean hasNext() {
			return this.delegate.hasNext();
		}

		@Override
		public ByteBuffer next() {
			return this.delegate.next();
		}
	}

}
"
764336f0f201c34ba0e636324e4b31da922c81c1,"Fix Jetty DataBufferFactory memory leak

Prior to this commit, gh-32097 added native support for Jetty for both
client and server integrations. The `JettyDataBufferFactory` was
promoted as a first class citizen, extracted from a private class in the
client support. To accomodate with server-side requirements, an extra
`buffer.retain()` call was performed.
While this is useful for server-side support, this introduced a bug in
the data buffer factory, as wrapping an existing chunk means that this
chunk is already retained.

This commit fixes the buffer factory implementation and moved existing
tests from mocks to actual pooled buffer implementations from Jetty.
The extra `buffer.retain()` is now done from the server support, right
before wrapping the buffer.

Fixes gh-35319",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.io.buffer;

import java.nio.ByteBuffer;

import org.eclipse.jetty.io.Content;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatIllegalStateException;
import static org.mockito.BDDMockito.given;
import static org.mockito.BDDMockito.then;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;

/**
 * @author Arjen Poutsma
 */
public class JettyDataBufferTests {

	private final JettyDataBufferFactory dataBufferFactory = new JettyDataBufferFactory();

	@Test
	void releaseRetainChunk() {
		ByteBuffer buffer = ByteBuffer.allocate(3);
		Content.Chunk mockChunk = mock();
		given(mockChunk.getByteBuffer()).willReturn(buffer);
		given(mockChunk.release()).willReturn(false, false, true);



		JettyDataBuffer dataBuffer = this.dataBufferFactory.wrap(mockChunk);
		dataBuffer.retain();
		dataBuffer.retain();
		assertThat(dataBuffer.release()).isFalse();
		assertThat(dataBuffer.release()).isFalse();
		assertThat(dataBuffer.release()).isTrue();

		assertThatIllegalStateException().isThrownBy(dataBuffer::release);

		then(mockChunk).should(times(3)).retain();
		then(mockChunk).should(times(3)).release();
	}
}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core.io.buffer;

import java.nio.ByteBuffer;

import org.eclipse.jetty.io.ArrayByteBufferPool;
import org.eclipse.jetty.io.Content;
import org.eclipse.jetty.io.RetainableByteBuffer;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatIllegalStateException;

/**
 * Tests for {@link JettyDataBuffer}
 * @author Arjen Poutsma
 * @author Brian Clozel
 */
public class JettyDataBufferTests {

	private final JettyDataBufferFactory dataBufferFactory = new JettyDataBufferFactory();

	private ArrayByteBufferPool.Tracking byteBufferPool = new ArrayByteBufferPool.Tracking();

	@Test
	void releaseRetainChunk() {
		RetainableByteBuffer retainableBuffer = byteBufferPool.acquire(3, false);
		ByteBuffer buffer = retainableBuffer.getByteBuffer();
		buffer.position(0).limit(1);
		Content.Chunk chunk = Content.Chunk.asChunk(buffer, false, retainableBuffer);

		JettyDataBuffer dataBuffer = this.dataBufferFactory.wrap(chunk);
		dataBuffer.retain();
		dataBuffer.retain();
		assertThat(dataBuffer.release()).isFalse();
		assertThat(dataBuffer.release()).isFalse();
		assertThat(dataBuffer.release()).isTrue();

		assertThatIllegalStateException().isThrownBy(dataBuffer::release);
		assertThat(retainableBuffer.isRetained()).isFalse();
		assertThat(byteBufferPool.getLeaks()).isEmpty();
	}

	@AfterEach
	public void tearDown() throws Exception {
		this.byteBufferPool.clear();
	}
}
"
764336f0f201c34ba0e636324e4b31da922c81c1,"Fix Jetty DataBufferFactory memory leak

Prior to this commit, gh-32097 added native support for Jetty for both
client and server integrations. The `JettyDataBufferFactory` was
promoted as a first class citizen, extracted from a private class in the
client support. To accomodate with server-side requirements, an extra
`buffer.retain()` call was performed.
While this is useful for server-side support, this introduced a bug in
the data buffer factory, as wrapping an existing chunk means that this
chunk is already retained.

This commit fixes the buffer factory implementation and moved existing
tests from mocks to actual pooled buffer implementations from Jetty.
The extra `buffer.retain()` is now done from the server support, right
before wrapping the buffer.

Fixes gh-35319",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.http.server.reactive;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Collections;
import java.util.List;

import org.eclipse.jetty.io.Content;
import org.eclipse.jetty.io.EndPoint;
import org.eclipse.jetty.server.Request;
import org.reactivestreams.FlowAdapters;
import reactor.core.publisher.Flux;

import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.JettyDataBufferFactory;
import org.springframework.http.HttpCookie;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.support.JettyHeadersAdapter;
import org.springframework.lang.Nullable;
import org.springframework.util.CollectionUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

/**
 * Adapt an Eclipse Jetty {@link Request} to a {@link org.springframework.http.server.ServerHttpRequest}.
 *
 * @author Greg Wilkins
 * @author Arjen Poutsma
 * @since 6.2
 */
class JettyCoreServerHttpRequest extends AbstractServerHttpRequest {

	private final JettyDataBufferFactory dataBufferFactory;

	private final Request request;


	public JettyCoreServerHttpRequest(Request request, JettyDataBufferFactory dataBufferFactory) {
		super(HttpMethod.valueOf(request.getMethod()),
				request.getHttpURI().toURI(),
				request.getContext().getContextPath(),
				new HttpHeaders(new JettyHeadersAdapter(request.getHeaders())));
		this.dataBufferFactory = dataBufferFactory;
		this.request = request;
	}


	@Override
	protected MultiValueMap<String, HttpCookie> initCookies() {
		List<org.eclipse.jetty.http.HttpCookie> httpCookies = Request.getCookies(this.request);
		if (httpCookies.isEmpty()) {
			return CollectionUtils.toMultiValueMap(Collections.emptyMap());
		}
		MultiValueMap<String, HttpCookie> cookies =new LinkedMultiValueMap<>();
		for (org.eclipse.jetty.http.HttpCookie c : httpCookies) {
			cookies.add(c.getName(), new HttpCookie(c.getName(), c.getValue()));
		}
		return cookies;
	}

	@Override
	@Nullable
	public SslInfo initSslInfo() {
		if (this.request.getConnectionMetaData().isSecure() &&
				this.request.getAttribute(EndPoint.SslSessionData.ATTRIBUTE) instanceof EndPoint.SslSessionData sessionData) {
			return new DefaultSslInfo(sessionData.sslSessionId(), sessionData.peerCertificates());
		}
		return null;
	}

	@SuppressWarnings(""unchecked"")
	@Override
	public <T> T getNativeRequest() {
		return (T) this.request;
	}

	@Override
	protected String initId() {
		return this.request.getId();
	}

	@Override
	@Nullable
	public InetSocketAddress getLocalAddress() {
		SocketAddress localAddress = this.request.getConnectionMetaData().getLocalSocketAddress();
		return localAddress instanceof InetSocketAddress inet ? inet : null;
	}

	@Override
	@Nullable
	public InetSocketAddress getRemoteAddress() {
		SocketAddress remoteAddress = this.request.getConnectionMetaData().getRemoteSocketAddress();
		return remoteAddress instanceof InetSocketAddress inet ? inet : null;
	}

	@Override
	public Flux<DataBuffer> getBody() {
		// We access the request body as a Flow.Publisher, which is wrapped as an org.reactivestreams.Publisher and
		// then wrapped as a Flux.
		return Flux.from(FlowAdapters.toPublisher(Content.Source.asPublisher(this.request)))
				.map(this.dataBufferFactory::wrap);
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.http.server.reactive;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Collections;
import java.util.List;

import org.eclipse.jetty.io.Content;
import org.eclipse.jetty.io.EndPoint;
import org.eclipse.jetty.server.Request;
import org.reactivestreams.FlowAdapters;
import reactor.core.publisher.Flux;

import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.JettyDataBufferFactory;
import org.springframework.http.HttpCookie;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.support.JettyHeadersAdapter;
import org.springframework.lang.Nullable;
import org.springframework.util.CollectionUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

/**
 * Adapt an Eclipse Jetty {@link Request} to a {@link org.springframework.http.server.ServerHttpRequest}.
 *
 * @author Greg Wilkins
 * @author Arjen Poutsma
 * @since 6.2
 */
class JettyCoreServerHttpRequest extends AbstractServerHttpRequest {

	private final JettyDataBufferFactory dataBufferFactory;

	private final Request request;


	public JettyCoreServerHttpRequest(Request request, JettyDataBufferFactory dataBufferFactory) {
		super(HttpMethod.valueOf(request.getMethod()),
				request.getHttpURI().toURI(),
				request.getContext().getContextPath(),
				new HttpHeaders(new JettyHeadersAdapter(request.getHeaders())));
		this.dataBufferFactory = dataBufferFactory;
		this.request = request;
	}


	@Override
	protected MultiValueMap<String, HttpCookie> initCookies() {
		List<org.eclipse.jetty.http.HttpCookie> httpCookies = Request.getCookies(this.request);
		if (httpCookies.isEmpty()) {
			return CollectionUtils.toMultiValueMap(Collections.emptyMap());
		}
		MultiValueMap<String, HttpCookie> cookies =new LinkedMultiValueMap<>();
		for (org.eclipse.jetty.http.HttpCookie c : httpCookies) {
			cookies.add(c.getName(), new HttpCookie(c.getName(), c.getValue()));
		}
		return cookies;
	}

	@Override
	@Nullable
	public SslInfo initSslInfo() {
		if (this.request.getConnectionMetaData().isSecure() &&
				this.request.getAttribute(EndPoint.SslSessionData.ATTRIBUTE) instanceof EndPoint.SslSessionData sessionData) {
			return new DefaultSslInfo(sessionData.sslSessionId(), sessionData.peerCertificates());
		}
		return null;
	}

	@SuppressWarnings(""unchecked"")
	@Override
	public <T> T getNativeRequest() {
		return (T) this.request;
	}

	@Override
	protected String initId() {
		return this.request.getId();
	}

	@Override
	@Nullable
	public InetSocketAddress getLocalAddress() {
		SocketAddress localAddress = this.request.getConnectionMetaData().getLocalSocketAddress();
		return localAddress instanceof InetSocketAddress inet ? inet : null;
	}

	@Override
	@Nullable
	public InetSocketAddress getRemoteAddress() {
		SocketAddress remoteAddress = this.request.getConnectionMetaData().getRemoteSocketAddress();
		return remoteAddress instanceof InetSocketAddress inet ? inet : null;
	}

	@Override
	public Flux<DataBuffer> getBody() {
		// We access the request body as a Flow.Publisher, which is wrapped as an org.reactivestreams.Publisher and
		// then wrapped as a Flux.
		return Flux.from(FlowAdapters.toPublisher(Content.Source.asPublisher(this.request)))
				.map(chunk -> {
					chunk.retain();
					return this.dataBufferFactory.wrap(chunk);
				});
	}

}
"
521764e68b7ab425ff7964e0b3d9d303c80adf7b,"Fix links, @since tags, formatting, etc. in RestTestClient",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.test.web.reactive.server;

import java.net.URI;
import java.nio.charset.Charset;
import java.time.Duration;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;

import org.hamcrest.Matcher;
import org.jspecify.annotations.Nullable;
import org.reactivestreams.Publisher;

import org.springframework.context.ApplicationContext;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.core.ReactiveAdapterRegistry;
import org.springframework.format.FormatterRegistry;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.client.reactive.ClientHttpConnector;
import org.springframework.http.client.reactive.ClientHttpRequest;
import org.springframework.http.codec.ClientCodecConfigurer;
import org.springframework.http.codec.ServerCodecConfigurer;
import org.springframework.http.server.reactive.SslInfo;
import org.springframework.test.json.JsonComparator;
import org.springframework.test.json.JsonCompareMode;
import org.springframework.test.json.JsonComparison;
import org.springframework.util.MultiValueMap;
import org.springframework.validation.Validator;
import org.springframework.web.client.ApiVersionFormatter;
import org.springframework.web.client.ApiVersionInserter;
import org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilder;
import org.springframework.web.reactive.config.ApiVersionConfigurer;
import org.springframework.web.reactive.config.BlockingExecutionConfigurer;
import org.springframework.web.reactive.config.CorsRegistry;
import org.springframework.web.reactive.config.PathMatchConfigurer;
import org.springframework.web.reactive.config.ViewResolverRegistry;
import org.springframework.web.reactive.config.WebFluxConfigurer;
import org.springframework.web.reactive.function.BodyInserter;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.ExchangeFilterFunction;
import org.springframework.web.reactive.function.client.ExchangeStrategies;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.server.HandlerStrategies;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.result.method.annotation.ArgumentResolverConfigurer;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebHandler;
import org.springframework.web.server.session.WebSessionManager;
import org.springframework.web.util.UriBuilder;
import org.springframework.web.util.UriBuilderFactory;

/**
 * Client for testing web servers that uses {@link WebClient} internally to
 * perform requests while also providing a fluent API to verify responses.
 * This client can connect to any server over HTTP, or to a WebFlux application
 * with a mock request and response.
 *
 * <p>Use one of the bindToXxx methods to create an instance. For example:
 * <ul>
 * <li>{@link #bindToController(Object...)}
 * <li>{@link #bindToRouterFunction(RouterFunction)}
 * <li>{@link #bindToApplicationContext(ApplicationContext)}
 * <li>{@link #bindToServer()}
 * <li>...
 * </ul>
 *
 * @author Rossen Stoyanchev
 * @author Brian Clozel
 * @author Sam Brannen
 * @author Micha Rowicki
 * @since 5.0
 */
public interface WebTestClient {

	/**
	 * The name of a request header used to assign a unique id to every request
	 * performed through the {@code WebTestClient}. This can be useful for
	 * storing contextual information at all phases of request processing (for example,
	 * from a server-side component) under that id and later to look up
	 * that information once an {@link ExchangeResult} is available.
	 */
	String WEBTESTCLIENT_REQUEST_ID = ""WebTestClient-Request-Id"";


	/**
	 * Prepare an HTTP GET request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> get();

	/**
	 * Prepare an HTTP HEAD request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> head();

	/**
	 * Prepare an HTTP POST request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec post();

	/**
	 * Prepare an HTTP PUT request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec put();

	/**
	 * Prepare an HTTP PATCH request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec patch();

	/**
	 * Prepare an HTTP DELETE request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> delete();

	/**
	 * Prepare an HTTP OPTIONS request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> options();

	/**
	 * Prepare a request for the specified {@code HttpMethod}.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec method(HttpMethod method);


	/**
	 * Return a builder to mutate properties of this test client.
	 */
	Builder mutate();

	/**
	 * Mutate the {@link WebTestClient}, apply the given configurer, and build
	 * a new instance. Essentially a shortcut for:
	 * <pre>
	 * mutate().apply(configurer).build();
	 * </pre>
	 * @param configurer the configurer to apply
	 * @return the mutated test client
	 */
	WebTestClient mutateWith(WebTestClientConfigurer configurer);


	/**
	 * Begin creating a {@link WebTestClient} with a mock server setup that
	 * tests one {@code @Controller} at a time with
	 * {@link org.springframework.web.reactive.config.EnableWebFlux @EnableWebFlux}
	 * equivalent configuration.
	 * @param controllers one or more controller instances to test
	 * (specified {@code Class} will be turned into instance)
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	static ControllerSpec bindToController(Object... controllers) {
		return new DefaultControllerSpec(controllers);
	}

	/**
	 * Begin creating a {@link WebTestClient} with a mock server setup that
	 * tests one {@code RouterFunction} at a time with
	 * {@link org.springframework.web.reactive.config.EnableWebFlux @EnableWebFlux}
	 * equivalent configuration.
	 * @param routerFunction the RouterFunction to test
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	static RouterFunctionSpec bindToRouterFunction(RouterFunction<?> routerFunction) {
		return new DefaultRouterFunctionSpec(routerFunction);
	}

	/**
	 * Use this option to set up a server from the Spring configuration of your
	 * application, or some subset of it. Internally the provided configuration
	 * is passed to {@code WebHttpHandlerBuilder} to set up the request
	 * processing chain. The resulting WebFlux application will be tested
	 * without an HTTP server using a mock request and response.
	 * <p>Consider using the TestContext framework and
	 * {@link org.springframework.test.context.ContextConfiguration @ContextConfiguration}
	 * in order to efficiently load and inject the Spring configuration into the
	 * test class.
	 * @param applicationContext the Spring context
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	static MockServerSpec<?> bindToApplicationContext(ApplicationContext applicationContext) {
		return new ApplicationContextSpec(applicationContext);
	}

	/**
	 * Integration testing with a ""mock"" server targeting the given WebHandler.
	 * @param webHandler the handler to test
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	static MockServerSpec<?> bindToWebHandler(WebHandler webHandler) {
		return new DefaultMockServerSpec(webHandler);
	}

	/**
	 * This server setup option allows you to connect to a live server.
	 * <p><pre class=""code"">
	 * WebTestClient client = WebTestClient.bindToServer()
	 *         .baseUrl(""http://localhost:8080"")
	 *         .build();
	 * </pre>
	 * @return chained API to customize client config
	 */
	static Builder bindToServer() {
		return new DefaultWebTestClientBuilder();
	}

	/**
	 * A variant of {@link #bindToServer()} with a pre-configured connector.
	 * @return chained API to customize client config
	 * @since 5.0.2
	 */
	static Builder bindToServer(ClientHttpConnector connector) {
		return new DefaultWebTestClientBuilder().clientConnector(connector);
	}


	/**
	 * Base specification for setting up tests without a server.
	 *
	 * @param <B> a self reference to the builder type
	 */
	interface MockServerSpec<B extends MockServerSpec<B>> {

		/**
		 * Register {@link WebFilter} instances to add to the mock server.
		 * @param filter one or more filters
		 */
		<T extends B> T webFilter(WebFilter... filter);

		/**
		 * Provide a session manager instance for the mock server.
		 * <p>By default an instance of
		 * {@link org.springframework.web.server.session.DefaultWebSessionManager
		 * DefaultWebSessionManager} is used.
		 * @param sessionManager the session manager to use
		 */
		<T extends B> T webSessionManager(WebSessionManager sessionManager);

		/**
		 * Set or reset SSL session information to assign to mock server requests.
		 * @param info the {@link SslInfo} to use
		 * @since 7.0
		 * @see SslInfo#from(String)
		 * @see SslInfo#from(String, java.security.cert.X509Certificate...)
		 */
		<T extends B> T sslInfo(@Nullable SslInfo info);

		/**
		 * Shortcut for pre-packaged customizations to the mock server setup.
		 * @param configurer the configurer to apply
		 */
		<T extends B> T apply(MockServerConfigurer configurer);

		/**
		 * Proceed to configure and build the test client.
		 */
		Builder configureClient();

		/**
		 * Shortcut to build the test client.
		 */
		WebTestClient build();
	}


	/**
	 * Specification for customizing controller configuration equivalent to, and
	 * internally delegating to, a {@link WebFluxConfigurer}.
	 */
	interface ControllerSpec extends MockServerSpec<ControllerSpec> {

		/**
		 * Register one or more {@link org.springframework.web.bind.annotation.ControllerAdvice}
		 * instances to be used in tests (specified {@code Class} will be turned into instance).
		 */
		ControllerSpec controllerAdvice(Object... controllerAdvice);

		/**
		 * Customize content type resolution.
		 * @see WebFluxConfigurer#configureContentTypeResolver
		 */
		ControllerSpec contentTypeResolver(Consumer<RequestedContentTypeResolverBuilder> consumer);

		/**
		 * Configure CORS support.
		 * @see WebFluxConfigurer#addCorsMappings
		 */
		ControllerSpec corsMappings(Consumer<CorsRegistry> consumer);

		/**
		 * Configure path matching options.
		 * @see WebFluxConfigurer#configurePathMatching
		 */
		ControllerSpec pathMatching(Consumer<PathMatchConfigurer> consumer);

		/**
		 * Configure resolvers for custom controller method arguments.
		 * @see WebFluxConfigurer#configureHttpMessageCodecs
		 */
		ControllerSpec argumentResolvers(Consumer<ArgumentResolverConfigurer> configurer);

		/**
		 * Configure custom HTTP message readers and writers or override built-in ones.
		 * @see WebFluxConfigurer#configureHttpMessageCodecs
		 */
		ControllerSpec httpMessageCodecs(Consumer<ServerCodecConfigurer> configurer);

		/**
		 * Register formatters and converters to use for type conversion.
		 * @see WebFluxConfigurer#addFormatters
		 */
		ControllerSpec formatters(Consumer<FormatterRegistry> consumer);

		/**
		 * Configure a global Validator.
		 * @see WebFluxConfigurer#getValidator()
		 */
		ControllerSpec validator(Validator validator);

		/**
		 * Configure API versioning for mapping requests to controller methods.
		 * @since 7.0
		 */
		ControllerSpec apiVersioning(Consumer<ApiVersionConfigurer> configurer);

		/**
		 * Configure view resolution.
		 * @see WebFluxConfigurer#configureViewResolvers
		 */
		ControllerSpec viewResolvers(Consumer<ViewResolverRegistry> consumer);

		/**
		 * Configure blocking execution options.
		 * @since 6.1
		 * @see WebFluxConfigurer#configureBlockingExecution
		 */
		ControllerSpec blockingExecution(Consumer<BlockingExecutionConfigurer> consumer);
	}


	/**
	 * Specification for customizing router function configuration.
	 */
	interface RouterFunctionSpec extends MockServerSpec<RouterFunctionSpec> {

		/**
		 * Configure handler strategies.
		 */
		RouterFunctionSpec handlerStrategies(HandlerStrategies handlerStrategies);
	}


	/**
	 * Steps to customize the underlying {@link WebClient} via {@link WebClient.Builder}.
	 */
	interface Builder {

		/**
		 * Configure a base URI as described in {@link WebClient#create(String)}.
		 */
		Builder baseUrl(String baseUrl);

		/**
		 * Provide a pre-configured {@link UriBuilderFactory} instance as an
		 * alternative to and effectively overriding {@link #baseUrl(String)}.
		 */
		Builder uriBuilderFactory(UriBuilderFactory uriBuilderFactory);

		/**
		 * Add the given header to all requests that haven't added it.
		 * @param headerName the header name
		 * @param headerValues the header values
		 */
		Builder defaultHeader(String headerName, String... headerValues);

		/**
		 * Manipulate the default headers with the given consumer. The
		 * headers provided to the consumer are ""live"", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this builder
		 */
		Builder defaultHeaders(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Add the given cookie to all requests that haven't already added it.
		 * @param cookieName the cookie name
		 * @param cookieValues the cookie values
		 */
		Builder defaultCookie(String cookieName, String... cookieValues);

		/**
		 * Manipulate the default cookies with the given consumer. The
		 * map provided to the consumer is ""live"", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this builder
		 */
		Builder defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Global option to specify an API version to add to every request,
		 * if not already set.
		 * @param version the version to use
		 * @return this builder
		 * @since 7.0
		 */
		Builder defaultApiVersion(Object version);

		/**
		 * Configure an {@link ApiVersionInserter} to abstract how an API version
		 * specified via {@link RequestHeadersSpec#apiVersion(Object)}
		 * is inserted into the request.
		 * @param apiVersionInserter the inserter to use
		 * @since 7.0
		 */
		Builder apiVersionInserter(ApiVersionInserter apiVersionInserter);

		/**
		 * Add the given filter to the filter chain.
		 * @param filter the filter to be added to the chain
		 */
		Builder filter(ExchangeFilterFunction filter);

		/**
		 * Manipulate the filters with the given consumer. The
		 * list provided to the consumer is ""live"", so that the consumer can be used to remove
		 * filters, change ordering, etc.
		 * @param filtersConsumer a function that consumes the filter list
		 * @return this builder
		 */
		Builder filters(Consumer<List<ExchangeFilterFunction>> filtersConsumer);

		/**
		 * Configure the codecs for the {@code WebClient} in the
		 * {@link #exchangeStrategies(ExchangeStrategies) underlying}
		 * {@code ExchangeStrategies}.
		 * @param configurer the configurer to apply
		 * @since 5.1.13
		 */
		Builder codecs(Consumer<ClientCodecConfigurer> configurer);

		/**
		 * Configure the {@link ExchangeStrategies} to use.
		 * <p>For most cases, prefer using {@link #codecs(Consumer)} which allows
		 * customizing the codecs in the {@code ExchangeStrategies} rather than
		 * replace them. That ensures multiple parties can contribute to codecs
		 * configuration.
		 * <p>By default this is set to {@link ExchangeStrategies#withDefaults()}.
		 * @param strategies the strategies to use
		 */
		Builder exchangeStrategies(ExchangeStrategies strategies);

		/**
		 * Max amount of time to wait for responses.
		 * <p>By default 5 seconds.
		 * @param timeout the response timeout value
		 */
		Builder responseTimeout(Duration timeout);

		/**
		 * Set the {@link ClientHttpConnector} to use.
		 * <p>By default, this is initialized and set internally. However, the
		 * connector may also be prepared externally and passed via
		 * {@link WebTestClient#bindToServer(ClientHttpConnector)} such as for
		 * {@code MockMvcWebTestClient} tests, and in that case you can use this
		 * from {@link #mutateWith(WebTestClientConfigurer)} to replace it.
		 * @param connector the connector to use
		 * @since 6.1
		 */
		Builder clientConnector(ClientHttpConnector connector);

		/**
		 * Configure an {@code EntityExchangeResult} callback that is invoked
		 * every time after a response is fully decoded to a single entity, to a
		 * List of entities, or to a byte[]. In effect, equivalent to each and
		 * all of the below but registered once, globally:
		 * <pre>
		 * client.get().uri(""/accounts/1"")
		 *         .exchange()
		 *         .expectBody(Person.class).consumeWith(exchangeResult -&gt; ... ));
		 *
		 * client.get().uri(""/accounts"")
		 *         .exchange()
		 *         .expectBodyList(Person.class).consumeWith(exchangeResult -&gt; ... ));
		 *
		 * client.get().uri(""/accounts/1"")
		 *         .exchange()
		 *         .expectBody().consumeWith(exchangeResult -&gt; ... ));
		 * </pre>
		 * <p>Note that the configured consumer does not apply to responses
		 * decoded to {@code Flux<T>} which can be consumed outside the workflow
		 * of the test client, for example via {@code reactor.test.StepVerifier}.
		 * @param consumer the consumer to apply to entity responses
		 * @return the builder
		 * @since 5.3.5
		 */
		Builder entityExchangeResultConsumer(Consumer<EntityExchangeResult<?>> consumer);

		/**
		 * Apply the given configurer to this builder instance.
		 * <p>This can be useful for applying pre-packaged customizations.
		 * @param configurer the configurer to apply
		 */
		Builder apply(WebTestClientConfigurer configurer);

		/**
		 * Build the {@link WebTestClient} instance.
		 */
		WebTestClient build();
	}


	/**
	 * Specification for providing the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface UriSpec<S extends RequestHeadersSpec<?>> {

		/**
		 * Specify the URI using an absolute, fully constructed {@link java.net.URI}.
		 * <p>If a {@link UriBuilderFactory} was configured for the client with
		 * a base URI, that base URI will <strong>not</strong> be applied to the
		 * supplied {@code java.net.URI}. If you wish to have a base URI applied to a
		 * {@code java.net.URI} you must invoke either {@link #uri(String, Object...)}
		 * or {@link #uri(String, Map)} &mdash; for example, {@code uri(myUri.toString())}.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(URI uri);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * <p>If a {@link UriBuilderFactory} was configured for the client (for example,
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(String uri, @Nullable Object... uriVariables);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * <p>If a {@link UriBuilderFactory} was configured for the client (for example,
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(String uri, Map<String, ? extends @Nullable Object> uriVariables);

		/**
		 * Build the URI for the request with a {@link UriBuilder} obtained
		 * through the {@link UriBuilderFactory} configured for this client.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(Function<UriBuilder, URI> uriFunction);
	}


	/**
	 * Specification for adding request headers and performing an exchange.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface RequestHeadersSpec<S extends RequestHeadersSpec<S>> {

		/**
		 * Set the list of acceptable {@linkplain MediaType media types}, as
		 * specified by the {@code Accept} header.
		 * @param acceptableMediaTypes the acceptable media types
		 * @return the same instance
		 */
		S accept(MediaType... acceptableMediaTypes);

		/**
		 * Set the list of acceptable {@linkplain Charset charsets}, as specified
		 * by the {@code Accept-Charset} header.
		 * @param acceptableCharsets the acceptable charsets
		 * @return the same instance
		 */
		S acceptCharset(Charset... acceptableCharsets);

		/**
		 * Add a cookie with the given name and value.
		 * @param name the cookie name
		 * @param value the cookie value
		 * @return the same instance
		 */
		S cookie(String name, String value);

		/**
		 * Manipulate this request's cookies with the given consumer. The
		 * map provided to the consumer is ""live"", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this builder
		 */
		S cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Set the value of the {@code If-Modified-Since} header.
		 * <p>The date should be specified as the number of milliseconds since
		 * January 1, 1970 GMT.
		 * @param ifModifiedSince the new value of the header
		 * @return the same instance
		 */
		S ifModifiedSince(ZonedDateTime ifModifiedSince);

		/**
		 * Set the values of the {@code If-None-Match} header.
		 * @param ifNoneMatches the new value of the header
		 * @return the same instance
		 */
		S ifNoneMatch(String... ifNoneMatches);

		/**
		 * Add the given, single header value under the given name.
		 * @param headerName  the header name
		 * @param headerValues the header value(s)
		 * @return the same instance
		 */
		S header(String headerName, String... headerValues);

		/**
		 * Manipulate the request's headers with the given consumer. The
		 * headers provided to the consumer are ""live"", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this builder
		 */
		S headers(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Set an API version for the request. The version is inserted into the
		 * request by the {@linkplain Builder#apiVersionInserter(ApiVersionInserter)
		 * configured} {@code ApiVersionInserter}.
		 * @param version the API version of the request; this can be a String or
		 * some Object that can be formatted by the inserter &mdash; for example,
		 * through an {@link ApiVersionFormatter}
		 * @since 7.0
		 */
		S apiVersion(Object version);

		/**
		 * Set the attribute with the given name to the given value.
		 * @param name the name of the attribute to add
		 * @param value the value of the attribute to add
		 * @return this builder
		 */
		S attribute(String name, Object value);

		/**
		 * Manipulate the request attributes with the given consumer. The attributes provided to
		 * the consumer are ""live"", so that the consumer can be used to inspect attributes,
		 * remove attributes, or use any of the other map-provided methods.
		 * @param attributesConsumer a function that consumes the attributes
		 * @return this builder
		 */
		S attributes(Consumer<Map<String, Object>> attributesConsumer);

		/**
		 * Perform the exchange without a request body.
		 * @return spec for decoding the response
		 */
		ResponseSpec exchange();
	}


	/**
	 * Specification for providing body of a request.
	 */
	interface RequestBodySpec extends RequestHeadersSpec<RequestBodySpec> {

		/**
		 * Set the length of the body in bytes, as specified by the
		 * {@code Content-Length} header.
		 * @param contentLength the content length
		 * @return the same instance
		 * @see HttpHeaders#setContentLength(long)
		 */
		RequestBodySpec contentLength(long contentLength);

		/**
		 * Set the {@linkplain MediaType media type} of the body, as specified
		 * by the {@code Content-Type} header.
		 * @param contentType the content type
		 * @return the same instance
		 * @see HttpHeaders#setContentType(MediaType)
		 */
		RequestBodySpec contentType(MediaType contentType);

		/**
		 * Set the body to the given {@code Object} value. This method invokes the
		 * {@link WebClient.RequestBodySpec#bodyValue(Object)
		 * bodyValue} method on the underlying {@code WebClient}.
		 * @param body the value to write to the request body
		 * @return spec for further declaration of the request
		 * @since 5.2
		 */
		RequestHeadersSpec<?> bodyValue(Object body);

		/**
		 * Set the body from the given {@code Publisher}. Shortcut for
		 * {@link #body(BodyInserter)} with a
		 * {@linkplain BodyInserters#fromPublisher Publisher inserter}.
		 * @param publisher the request body data
		 * @param elementClass the class of elements contained in the publisher
		 * @param <T> the type of the elements contained in the publisher
		 * @param <S> the type of the {@code Publisher}
		 * @return spec for further declaration of the request
		 */
		<T, S extends Publisher<T>> RequestHeadersSpec<?> body(S publisher, Class<T> elementClass);

		/**
		 * Variant of {@link #body(Publisher, Class)} that allows providing
		 * element type information with generics.
		 * @param publisher the request body data
		 * @param elementTypeRef the type reference of elements contained in the publisher
		 * @param <T> the type of the elements contained in the publisher
		 * @param <S> the type of the {@code Publisher}
		 * @return spec for further declaration of the request
		 * @since 5.2
		 */
		<T, S extends Publisher<T>> RequestHeadersSpec<?> body(
				S publisher, ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * Set the body from the given producer. This method invokes the
		 * {@link WebClient.RequestBodySpec#body(Object, Class)
		 * body(Object, Class)} method on the underlying {@code WebClient}.
		 * @param producer the producer to write to the request. This must be a
		 * {@link Publisher} or another producer adaptable to a
		 * {@code Publisher} via {@link ReactiveAdapterRegistry}
		 * @param elementClass the class of elements contained in the producer
		 * @return spec for further declaration of the request
		 * @since 5.2
		 */
		RequestHeadersSpec<?> body(Object producer, Class<?> elementClass);

		/**
		 * Set the body from the given producer. This method invokes the
		 * {@link WebClient.RequestBodySpec#body(Object, ParameterizedTypeReference)
		 * body(Object, ParameterizedTypeReference)} method on the underlying {@code WebClient}.
		 * @param producer the producer to write to the request. This must be a
		 * {@link Publisher} or another producer adaptable to a
		 * {@code Publisher} via {@link ReactiveAdapterRegistry}
		 * @param elementTypeRef the type reference of elements contained in the producer
		 * @return spec for further declaration of the request
		 * @since 5.2
		 */
		RequestHeadersSpec<?> body(Object producer, ParameterizedTypeReference<?> elementTypeRef);

		/**
		 * Set the body of the request to the given {@code BodyInserter}.
		 * This method invokes the
		 * {@link WebClient.RequestBodySpec#body(BodyInserter)
		 * body(BodyInserter)} method on the underlying {@code WebClient}.
		 * @param inserter the body inserter to use
		 * @return spec for further declaration of the request
		 * @see org.springframework.web.reactive.function.BodyInserters
		 */
		RequestHeadersSpec<?> body(BodyInserter<?, ? super ClientHttpRequest> inserter);
	}


	/**
	 * Specification for providing request headers and the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface RequestHeadersUriSpec<S extends RequestHeadersSpec<S>> extends UriSpec<S>, RequestHeadersSpec<S> {
	}


	/**
	 * Specification for providing the body and the URI of a request.
	 */
	interface RequestBodyUriSpec extends RequestBodySpec, RequestHeadersUriSpec<RequestBodySpec> {
	}


	/**
	 * Chained API for applying assertions to a response.
	 */
	interface ResponseSpec {

		/**
		 * Apply multiple assertions to a response with the given
		 * {@linkplain ResponseSpecConsumer consumers}, with the guarantee that
		 * all assertions will be applied even if one or more assertions fails
		 * with an exception.
		 * <p>If a single {@link Error} or {@link RuntimeException} is thrown,
		 * it will be rethrown.
		 * <p>If multiple exceptions are thrown, this method will throw an
		 * {@link AssertionError} whose error message is a summary of all the
		 * exceptions. In addition, each exception will be added as a
		 * {@linkplain Throwable#addSuppressed(Throwable) suppressed exception} to
		 * the {@code AssertionError}.
		 * <p>This feature is similar to the {@code SoftAssertions} support in
		 * AssertJ and the {@code assertAll()} support in JUnit Jupiter.
		 *
		 * <h4>Example</h4>
		 * <pre class=""code"">
		 * webTestClient.get().uri(""/hello"").exchange()
		 *     .expectAll(
		 *         responseSpec -&gt; responseSpec.expectStatus().isOk(),
		 *         responseSpec -&gt; responseSpec.expectBody(String.class).isEqualTo(""Hello, World!"")
		 *     );
		 * </pre>
		 * @param consumers the list of {@code ResponseSpec} consumers
		 * @since 5.3.10
		 */
		ResponseSpec expectAll(ResponseSpecConsumer... consumers);

		/**
		 * Assertions on the response status.
		 */
		StatusAssertions expectStatus();

		/**
		 * Assertions on the headers of the response.
		 */
		HeaderAssertions expectHeader();

		/**
		 * Assertions on the cookies of the response.
		 * @since 5.3
		 */
		CookieAssertions expectCookie();

		/**
		 * Consume and decode the response body to a single object of type
		 * {@code <B>} and then apply assertions.
		 * @param bodyType the expected body type
		 */
		<B> BodySpec<B, ?> expectBody(Class<B> bodyType);

		/**
		 * Alternative to {@link #expectBody(Class)} that accepts information
		 * about a target type with generics.
		 */
		<B> BodySpec<B, ?> expectBody(ParameterizedTypeReference<B> bodyType);

		/**
		 * Consume and decode the response body to {@code List<E>} and then apply
		 * List-specific assertions.
		 * @param elementType the expected List element type
		 */
		<E> ListBodySpec<E> expectBodyList(Class<E> elementType);

		/**
		 * Alternative to {@link #expectBodyList(Class)} that accepts information
		 * about a target type with generics.
		 */
		<E> ListBodySpec<E> expectBodyList(ParameterizedTypeReference<E> elementType);

		/**
		 * Consume and decode the response body to {@code byte[]} and then apply
		 * assertions on the raw content (for example, isEmpty, JSONPath, etc.).
		 */
		BodyContentSpec expectBody();

		/**
		 * Exit the chained flow in order to consume the response body externally,
		 * for example, via {@link reactor.test.StepVerifier}.
		 * <p>Note that when {@code Void.class} is passed in, the response body
		 * is consumed and released. If no content is expected, then consider
		 * using {@code .expectBody().isEmpty()} instead which asserts that
		 * there is no content.
		 */
		<T> FluxExchangeResult<T> returnResult(Class<T> elementClass);

		/**
		 * Alternative to {@link #returnResult(Class)} that accepts information
		 * about a target type with generics.
		 */
		<T> FluxExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * {@link Consumer} of a {@link ResponseSpec}.
		 * @since 5.3.10
		 * @see ResponseSpec#expectAll(ResponseSpecConsumer...)
		 */
		@FunctionalInterface
		interface ResponseSpecConsumer extends Consumer<ResponseSpec> {
		}
	}


	/**
	 * Spec for expectations on the response body decoded to a single Object.
	 *
	 * @param <S> a self reference to the spec type
	 * @param <B> the body type
	 */
	interface BodySpec<B, S extends BodySpec<B, S>> {

		/**
		 * Assert the extracted body is equal to the given value.
		 */
		<T extends S> T isEqualTo(@Nullable B expected);

		/**
		 * Assert the extracted body with a {@link Matcher}.
		 * @since 5.1
		 */
		<T extends S> T value(Matcher<? super @Nullable B> matcher);

		/**
		 * Transform the extracted the body with a function, for example, extracting a
		 * property, and assert the mapped value with a {@link Matcher}.
		 * @since 5.1
		 */
		<T extends S, R> T value(Function<@Nullable B, @Nullable R> bodyMapper, Matcher<? super @Nullable R> matcher);

		/**
		 * Assert the extracted body with a {@link Consumer}.
		 * @since 5.1
		 */
		<T extends S> T value(Consumer<@Nullable B> consumer);

		/**
		 * Assert the exchange result with the given {@link Consumer}.
		 */
		<T extends S> T consumeWith(Consumer<EntityExchangeResult<B>> consumer);

		/**
		 * Exit the chained API and return an {@code ExchangeResult} with the
		 * decoded response content.
		 */
		EntityExchangeResult<B> returnResult();
	}


	/**
	 * Spec for expectations on the response body decoded to a List.
	 *
	 * @param <E> the body list element type
	 */
	interface ListBodySpec<E> extends BodySpec<List<@Nullable E>, ListBodySpec<E>> {

		/**
		 * Assert the extracted list of values is of the given size.
		 * @param size the expected size
		 */
		ListBodySpec<E> hasSize(int size);

		/**
		 * Assert the extracted list of values contains the given elements.
		 * @param elements the elements to check
		 */
		@SuppressWarnings(""unchecked"")
		ListBodySpec<E> contains(@Nullable E... elements);

		/**
		 * Assert the extracted list of values doesn't contain the given elements.
		 * @param elements the elements to check
		 */
		@SuppressWarnings(""unchecked"")
		ListBodySpec<E> doesNotContain(@Nullable E... elements);
	}


	/**
	 * Spec for expectations on the response body content.
	 */
	interface BodyContentSpec {
		/**
		 * Assert the response body is empty and return the exchange result.
		 */
		EntityExchangeResult<Void> isEmpty();

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison verifying that they contain the same attribute-value pairs
		 * regardless of formatting with <em>lenient</em> checking (extensible
		 * and non-strict array ordering).
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @see #json(String, JsonCompareMode)
		 */
		default BodyContentSpec json(String expectedJson) {
			return json(expectedJson, JsonCompareMode.LENIENT);
		}

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison verifying that they contain the same attribute-value pairs
		 * regardless of formatting.
		 * <p>Can compare in two modes, depending on the {@code strict} parameter value:
		 * <ul>
		 * <li>{@code true}: strict checking. Not extensible and strict array ordering.</li>
		 * <li>{@code false}: lenient checking. Extensible and non-strict array ordering.</li>
		 * </ul>
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @param strict enables strict checking if {@code true}
		 * @since 5.3.16
		 * @see #json(String)
		 * @deprecated in favor of {@link #json(String, JsonCompareMode)}
		 */
		@Deprecated(since = ""6.2"")
		BodyContentSpec json(String expectedJson, boolean strict);

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison using the given {@linkplain JsonCompareMode mode}. If the
		 * comparison failed, throws an {@link AssertionError} with the message
		 * of the {@link JsonComparison}.
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @param compareMode the compare mode
		 * @since 6.2
		 * @see #json(String)
		 */
		BodyContentSpec json(String expectedJson, JsonCompareMode compareMode);

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison using the given {@link JsonComparator}. If the comparison
		 * failed, throws an {@link AssertionError} with the message  of the
		 * {@link JsonComparison}.
		 * @param expectedJson the expected JSON content
		 * @param comparator the comparator to use
		 * @since 6.2
		 */
		BodyContentSpec json(String expectedJson, JsonComparator comparator);

		/**
		 * Parse expected and actual response content as XML and assert that
		 * the two are ""similar"", i.e. they contain the same elements and
		 * attributes regardless of order.
		 * <p>Use of this method requires the
		 * <a href=""https://github.com/xmlunit/xmlunit"">XMLUnit</a> library on
		 * the classpath.
		 * @param expectedXml the expected XML content.
		 * @since 5.1
		 * @see org.springframework.test.util.XmlExpectationsHelper#assertXmlEqual(String, String)
		 */
		BodyContentSpec xml(String expectedXml);

		/**
		 * Access to response body assertions using a
		 * <a href=""https://github.com/jayway/JsonPath"">JsonPath</a> expression
		 * to inspect a specific subset of the body.
		 * @param expression the JsonPath expression
		 * @since 6.2
		 */
		JsonPathAssertions jsonPath(String expression);

		/**
		 * Access to response body assertions using an XPath expression to
		 * inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param args arguments to parameterize the expression
		 * @since 5.1
		 * @see #xpath(String, Map, Object...)
		 */
		default XpathAssertions xpath(String expression, Object... args) {
			return xpath(expression, null, args);
		}

		/**
		 * Access to response body assertions with specific namespaces using an
		 * XPath expression to inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param namespaces the namespaces to use
		 * @param args arguments to parameterize the expression
		 * @since 5.1
		 */
		XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args);

		/**
		 * Assert the response body content with the given {@link Consumer}.
		 * @param consumer the consumer for the response body; the input
		 * {@code byte[]} may be {@code null} if there was no response body.
		 */
		BodyContentSpec consumeWith(Consumer<EntityExchangeResult<byte[]>> consumer);

		/**
		 * Exit the chained API and return an {@code ExchangeResult} with the
		 * raw response content.
		 */
		EntityExchangeResult<byte[]> returnResult();
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.test.web.reactive.server;

import java.net.URI;
import java.nio.charset.Charset;
import java.time.Duration;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;

import org.hamcrest.Matcher;
import org.jspecify.annotations.Nullable;
import org.reactivestreams.Publisher;

import org.springframework.context.ApplicationContext;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.core.ReactiveAdapterRegistry;
import org.springframework.format.FormatterRegistry;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.client.reactive.ClientHttpConnector;
import org.springframework.http.client.reactive.ClientHttpRequest;
import org.springframework.http.codec.ClientCodecConfigurer;
import org.springframework.http.codec.ServerCodecConfigurer;
import org.springframework.http.server.reactive.SslInfo;
import org.springframework.test.json.JsonComparator;
import org.springframework.test.json.JsonCompareMode;
import org.springframework.test.json.JsonComparison;
import org.springframework.util.MultiValueMap;
import org.springframework.validation.Validator;
import org.springframework.web.client.ApiVersionFormatter;
import org.springframework.web.client.ApiVersionInserter;
import org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilder;
import org.springframework.web.reactive.config.ApiVersionConfigurer;
import org.springframework.web.reactive.config.BlockingExecutionConfigurer;
import org.springframework.web.reactive.config.CorsRegistry;
import org.springframework.web.reactive.config.PathMatchConfigurer;
import org.springframework.web.reactive.config.ViewResolverRegistry;
import org.springframework.web.reactive.config.WebFluxConfigurer;
import org.springframework.web.reactive.function.BodyInserter;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.ExchangeFilterFunction;
import org.springframework.web.reactive.function.client.ExchangeStrategies;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.server.HandlerStrategies;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.result.method.annotation.ArgumentResolverConfigurer;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebHandler;
import org.springframework.web.server.session.WebSessionManager;
import org.springframework.web.util.UriBuilder;
import org.springframework.web.util.UriBuilderFactory;

/**
 * Client for testing web servers that uses {@link WebClient} internally to
 * perform requests while also providing a fluent API to verify responses.
 * This client can connect to any server over HTTP, or to a WebFlux application
 * with a mock request and response.
 *
 * <p>Use one of the bindToXxx methods to create an instance. For example:
 * <ul>
 * <li>{@link #bindToController(Object...)}
 * <li>{@link #bindToRouterFunction(RouterFunction)}
 * <li>{@link #bindToApplicationContext(ApplicationContext)}
 * <li>{@link #bindToServer()}
 * <li>...
 * </ul>
 *
 * @author Rossen Stoyanchev
 * @author Brian Clozel
 * @author Sam Brannen
 * @author Micha Rowicki
 * @since 5.0
 */
public interface WebTestClient {

	/**
	 * The name of a request header used to assign a unique id to every request
	 * performed through the {@code WebTestClient}. This can be useful for
	 * storing contextual information at all phases of request processing (for example,
	 * from a server-side component) under that id and later to look up
	 * that information once an {@link ExchangeResult} is available.
	 */
	String WEBTESTCLIENT_REQUEST_ID = ""WebTestClient-Request-Id"";


	/**
	 * Prepare an HTTP GET request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> get();

	/**
	 * Prepare an HTTP HEAD request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> head();

	/**
	 * Prepare an HTTP POST request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec post();

	/**
	 * Prepare an HTTP PUT request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec put();

	/**
	 * Prepare an HTTP PATCH request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec patch();

	/**
	 * Prepare an HTTP DELETE request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> delete();

	/**
	 * Prepare an HTTP OPTIONS request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> options();

	/**
	 * Prepare a request for the specified {@code HttpMethod}.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec method(HttpMethod method);


	/**
	 * Return a builder to mutate properties of this test client.
	 */
	Builder mutate();

	/**
	 * Mutate the {@link WebTestClient}, apply the given configurer, and build
	 * a new instance. Essentially a shortcut for:
	 * <pre>
	 * mutate().apply(configurer).build();
	 * </pre>
	 * @param configurer the configurer to apply
	 * @return the mutated test client
	 */
	WebTestClient mutateWith(WebTestClientConfigurer configurer);


	/**
	 * Begin creating a {@link WebTestClient} with a mock server setup that
	 * tests one {@code @Controller} at a time with
	 * {@link org.springframework.web.reactive.config.EnableWebFlux @EnableWebFlux}
	 * equivalent configuration.
	 * @param controllers one or more controller instances to test
	 * (specified {@code Class} will be turned into instance)
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	static ControllerSpec bindToController(Object... controllers) {
		return new DefaultControllerSpec(controllers);
	}

	/**
	 * Begin creating a {@link WebTestClient} with a mock server setup that
	 * tests one {@code RouterFunction} at a time with
	 * {@link org.springframework.web.reactive.config.EnableWebFlux @EnableWebFlux}
	 * equivalent configuration.
	 * @param routerFunction the RouterFunction to test
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	static RouterFunctionSpec bindToRouterFunction(RouterFunction<?> routerFunction) {
		return new DefaultRouterFunctionSpec(routerFunction);
	}

	/**
	 * Use this option to set up a server from the Spring configuration of your
	 * application, or some subset of it. Internally the provided configuration
	 * is passed to {@code WebHttpHandlerBuilder} to set up the request
	 * processing chain. The resulting WebFlux application will be tested
	 * without an HTTP server using a mock request and response.
	 * <p>Consider using the TestContext framework and
	 * {@link org.springframework.test.context.ContextConfiguration @ContextConfiguration}
	 * in order to efficiently load and inject the Spring configuration into the
	 * test class.
	 * @param applicationContext the Spring context
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	static MockServerSpec<?> bindToApplicationContext(ApplicationContext applicationContext) {
		return new ApplicationContextSpec(applicationContext);
	}

	/**
	 * Integration testing with a ""mock"" server targeting the given WebHandler.
	 * @param webHandler the handler to test
	 * @return chained API to customize server and client config; use
	 * {@link MockServerSpec#configureClient()} to transition to client config
	 */
	static MockServerSpec<?> bindToWebHandler(WebHandler webHandler) {
		return new DefaultMockServerSpec(webHandler);
	}

	/**
	 * This server setup option allows you to connect to a live server.
	 * <p><pre class=""code"">
	 * WebTestClient client = WebTestClient.bindToServer()
	 *         .baseUrl(""http://localhost:8080"")
	 *         .build();
	 * </pre>
	 * @return chained API to customize client config
	 */
	static Builder bindToServer() {
		return new DefaultWebTestClientBuilder();
	}

	/**
	 * A variant of {@link #bindToServer()} with a pre-configured connector.
	 * @return chained API to customize client config
	 * @since 5.0.2
	 */
	static Builder bindToServer(ClientHttpConnector connector) {
		return new DefaultWebTestClientBuilder().clientConnector(connector);
	}


	/**
	 * Base specification for setting up tests without a server.
	 *
	 * @param <B> a self reference to the builder type
	 */
	interface MockServerSpec<B extends MockServerSpec<B>> {

		/**
		 * Register {@link WebFilter} instances to add to the mock server.
		 * @param filter one or more filters
		 */
		<T extends B> T webFilter(WebFilter... filter);

		/**
		 * Provide a session manager instance for the mock server.
		 * <p>By default an instance of
		 * {@link org.springframework.web.server.session.DefaultWebSessionManager
		 * DefaultWebSessionManager} is used.
		 * @param sessionManager the session manager to use
		 */
		<T extends B> T webSessionManager(WebSessionManager sessionManager);

		/**
		 * Set or reset SSL session information to assign to mock server requests.
		 * @param info the {@link SslInfo} to use
		 * @since 7.0
		 * @see SslInfo#from(String)
		 * @see SslInfo#from(String, java.security.cert.X509Certificate...)
		 */
		<T extends B> T sslInfo(@Nullable SslInfo info);

		/**
		 * Shortcut for pre-packaged customizations to the mock server setup.
		 * @param configurer the configurer to apply
		 */
		<T extends B> T apply(MockServerConfigurer configurer);

		/**
		 * Proceed to configure and build the test client.
		 */
		Builder configureClient();

		/**
		 * Shortcut to build the test client.
		 */
		WebTestClient build();
	}


	/**
	 * Specification for customizing controller configuration equivalent to, and
	 * internally delegating to, a {@link WebFluxConfigurer}.
	 */
	interface ControllerSpec extends MockServerSpec<ControllerSpec> {

		/**
		 * Register one or more {@link org.springframework.web.bind.annotation.ControllerAdvice}
		 * instances to be used in tests (specified {@code Class} will be turned into instance).
		 */
		ControllerSpec controllerAdvice(Object... controllerAdvice);

		/**
		 * Customize content type resolution.
		 * @see WebFluxConfigurer#configureContentTypeResolver
		 */
		ControllerSpec contentTypeResolver(Consumer<RequestedContentTypeResolverBuilder> consumer);

		/**
		 * Configure CORS support.
		 * @see WebFluxConfigurer#addCorsMappings
		 */
		ControllerSpec corsMappings(Consumer<CorsRegistry> consumer);

		/**
		 * Configure path matching options.
		 * @see WebFluxConfigurer#configurePathMatching
		 */
		ControllerSpec pathMatching(Consumer<PathMatchConfigurer> consumer);

		/**
		 * Configure resolvers for custom controller method arguments.
		 * @see WebFluxConfigurer#configureHttpMessageCodecs
		 */
		ControllerSpec argumentResolvers(Consumer<ArgumentResolverConfigurer> configurer);

		/**
		 * Configure custom HTTP message readers and writers or override built-in ones.
		 * @see WebFluxConfigurer#configureHttpMessageCodecs
		 */
		ControllerSpec httpMessageCodecs(Consumer<ServerCodecConfigurer> configurer);

		/**
		 * Register formatters and converters to use for type conversion.
		 * @see WebFluxConfigurer#addFormatters
		 */
		ControllerSpec formatters(Consumer<FormatterRegistry> consumer);

		/**
		 * Configure a global Validator.
		 * @see WebFluxConfigurer#getValidator()
		 */
		ControllerSpec validator(Validator validator);

		/**
		 * Configure API versioning for mapping requests to controller methods.
		 * @since 7.0
		 */
		ControllerSpec apiVersioning(Consumer<ApiVersionConfigurer> configurer);

		/**
		 * Configure view resolution.
		 * @see WebFluxConfigurer#configureViewResolvers
		 */
		ControllerSpec viewResolvers(Consumer<ViewResolverRegistry> consumer);

		/**
		 * Configure blocking execution options.
		 * @since 6.1
		 * @see WebFluxConfigurer#configureBlockingExecution
		 */
		ControllerSpec blockingExecution(Consumer<BlockingExecutionConfigurer> consumer);
	}


	/**
	 * Specification for customizing router function configuration.
	 */
	interface RouterFunctionSpec extends MockServerSpec<RouterFunctionSpec> {

		/**
		 * Configure handler strategies.
		 */
		RouterFunctionSpec handlerStrategies(HandlerStrategies handlerStrategies);
	}


	/**
	 * Steps to customize the underlying {@link WebClient} via {@link WebClient.Builder}.
	 */
	interface Builder {

		/**
		 * Configure a base URI as described in {@link WebClient#create(String)}.
		 */
		Builder baseUrl(String baseUrl);

		/**
		 * Provide a pre-configured {@link UriBuilderFactory} instance as an
		 * alternative to and effectively overriding {@link #baseUrl(String)}.
		 */
		Builder uriBuilderFactory(UriBuilderFactory uriBuilderFactory);

		/**
		 * Add the given header to all requests that haven't added it.
		 * @param headerName the header name
		 * @param headerValues the header values
		 */
		Builder defaultHeader(String headerName, String... headerValues);

		/**
		 * Manipulate the default headers with the given consumer. The
		 * headers provided to the consumer are ""live"", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this builder
		 */
		Builder defaultHeaders(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Add the given cookie to all requests that haven't already added it.
		 * @param cookieName the cookie name
		 * @param cookieValues the cookie values
		 */
		Builder defaultCookie(String cookieName, String... cookieValues);

		/**
		 * Manipulate the default cookies with the given consumer. The
		 * map provided to the consumer is ""live"", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this builder
		 */
		Builder defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Global option to specify an API version to add to every request,
		 * if not already set.
		 * @param version the version to use
		 * @return this builder
		 * @since 7.0
		 */
		Builder defaultApiVersion(Object version);

		/**
		 * Configure an {@link ApiVersionInserter} to abstract how an API version
		 * specified via {@link RequestHeadersSpec#apiVersion(Object)}
		 * is inserted into the request.
		 * @param apiVersionInserter the inserter to use
		 * @since 7.0
		 */
		Builder apiVersionInserter(ApiVersionInserter apiVersionInserter);

		/**
		 * Add the given filter to the filter chain.
		 * @param filter the filter to be added to the chain
		 */
		Builder filter(ExchangeFilterFunction filter);

		/**
		 * Manipulate the filters with the given consumer. The
		 * list provided to the consumer is ""live"", so that the consumer can be used to remove
		 * filters, change ordering, etc.
		 * @param filtersConsumer a function that consumes the filter list
		 * @return this builder
		 */
		Builder filters(Consumer<List<ExchangeFilterFunction>> filtersConsumer);

		/**
		 * Configure the codecs for the {@code WebClient} in the
		 * {@link #exchangeStrategies(ExchangeStrategies) underlying}
		 * {@code ExchangeStrategies}.
		 * @param configurer the configurer to apply
		 * @since 5.1.13
		 */
		Builder codecs(Consumer<ClientCodecConfigurer> configurer);

		/**
		 * Configure the {@link ExchangeStrategies} to use.
		 * <p>For most cases, prefer using {@link #codecs(Consumer)} which allows
		 * customizing the codecs in the {@code ExchangeStrategies} rather than
		 * replace them. That ensures multiple parties can contribute to codecs
		 * configuration.
		 * <p>By default this is set to {@link ExchangeStrategies#withDefaults()}.
		 * @param strategies the strategies to use
		 */
		Builder exchangeStrategies(ExchangeStrategies strategies);

		/**
		 * Max amount of time to wait for responses.
		 * <p>By default 5 seconds.
		 * @param timeout the response timeout value
		 */
		Builder responseTimeout(Duration timeout);

		/**
		 * Set the {@link ClientHttpConnector} to use.
		 * <p>By default, this is initialized and set internally. However, the
		 * connector may also be prepared externally and passed via
		 * {@link WebTestClient#bindToServer(ClientHttpConnector)} such as for
		 * {@code MockMvcWebTestClient} tests, and in that case you can use this
		 * from {@link #mutateWith(WebTestClientConfigurer)} to replace it.
		 * @param connector the connector to use
		 * @since 6.1
		 */
		Builder clientConnector(ClientHttpConnector connector);

		/**
		 * Configure an {@code EntityExchangeResult} callback that is invoked
		 * every time after a response is fully decoded to a single entity, to a
		 * List of entities, or to a byte[]. In effect, equivalent to each and
		 * all of the below but registered once, globally:
		 * <pre>
		 * client.get().uri(""/accounts/1"")
		 *         .exchange()
		 *         .expectBody(Person.class).consumeWith(exchangeResult -&gt; ... ));
		 *
		 * client.get().uri(""/accounts"")
		 *         .exchange()
		 *         .expectBodyList(Person.class).consumeWith(exchangeResult -&gt; ... ));
		 *
		 * client.get().uri(""/accounts/1"")
		 *         .exchange()
		 *         .expectBody().consumeWith(exchangeResult -&gt; ... ));
		 * </pre>
		 * <p>Note that the configured consumer does not apply to responses
		 * decoded to {@code Flux<T>} which can be consumed outside the workflow
		 * of the test client, for example via {@code reactor.test.StepVerifier}.
		 * @param consumer the consumer to apply to entity responses
		 * @return the builder
		 * @since 5.3.5
		 */
		Builder entityExchangeResultConsumer(Consumer<EntityExchangeResult<?>> consumer);

		/**
		 * Apply the given configurer to this builder instance.
		 * <p>This can be useful for applying pre-packaged customizations.
		 * @param configurer the configurer to apply
		 */
		Builder apply(WebTestClientConfigurer configurer);

		/**
		 * Build the {@link WebTestClient} instance.
		 */
		WebTestClient build();
	}


	/**
	 * Specification for providing the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface UriSpec<S extends RequestHeadersSpec<?>> {

		/**
		 * Specify the URI using an absolute, fully constructed {@link java.net.URI}.
		 * <p>If a {@link UriBuilderFactory} was configured for the client with
		 * a base URI, that base URI will <strong>not</strong> be applied to the
		 * supplied {@code java.net.URI}. If you wish to have a base URI applied to a
		 * {@code java.net.URI} you must invoke either {@link #uri(String, Object...)}
		 * or {@link #uri(String, Map)} &mdash; for example, {@code uri(myUri.toString())}.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(URI uri);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * <p>If a {@link UriBuilderFactory} was configured for the client (for example,
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(String uri, @Nullable Object... uriVariables);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * <p>If a {@link UriBuilderFactory} was configured for the client (for example,
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(String uri, Map<String, ? extends @Nullable Object> uriVariables);

		/**
		 * Build the URI for the request with a {@link UriBuilder} obtained
		 * through the {@link UriBuilderFactory} configured for this client.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(Function<UriBuilder, URI> uriFunction);
	}


	/**
	 * Specification for adding request headers and performing an exchange.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface RequestHeadersSpec<S extends RequestHeadersSpec<S>> {

		/**
		 * Set the list of acceptable {@linkplain MediaType media types}, as
		 * specified by the {@code Accept} header.
		 * @param acceptableMediaTypes the acceptable media types
		 * @return this spec for further declaration of the request
		 */
		S accept(MediaType... acceptableMediaTypes);

		/**
		 * Set the list of acceptable {@linkplain Charset charsets}, as specified
		 * by the {@code Accept-Charset} header.
		 * @param acceptableCharsets the acceptable charsets
		 * @return this spec for further declaration of the request
		 */
		S acceptCharset(Charset... acceptableCharsets);

		/**
		 * Add a cookie with the given name and value.
		 * @param name the cookie name
		 * @param value the cookie value
		 * @return this spec for further declaration of the request
		 */
		S cookie(String name, String value);

		/**
		 * Manipulate this request's cookies with the given consumer. The
		 * map provided to the consumer is ""live"", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this spec for further declaration of the request
		 */
		S cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Set the value of the {@code If-Modified-Since} header.
		 * <p>The date should be specified as the number of milliseconds since
		 * January 1, 1970 GMT.
		 * @param ifModifiedSince the new value of the header
		 * @return this spec for further declaration of the request
		 */
		S ifModifiedSince(ZonedDateTime ifModifiedSince);

		/**
		 * Set the values of the {@code If-None-Match} header.
		 * @param ifNoneMatches the new value of the header
		 * @return this spec for further declaration of the request
		 */
		S ifNoneMatch(String... ifNoneMatches);

		/**
		 * Add the given, single header value under the given name.
		 * @param headerName  the header name
		 * @param headerValues the header value(s)
		 * @return this spec for further declaration of the request
		 */
		S header(String headerName, String... headerValues);

		/**
		 * Manipulate the request's headers with the given consumer. The
		 * headers provided to the consumer are ""live"", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this spec for further declaration of the request
		 */
		S headers(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Set an API version for the request. The version is inserted into the
		 * request by the {@linkplain Builder#apiVersionInserter(ApiVersionInserter)
		 * configured} {@code ApiVersionInserter}.
		 * @param version the API version of the request; this can be a String or
		 * some Object that can be formatted by the inserter &mdash; for example,
		 * through an {@link ApiVersionFormatter}
		 * @return this spec for further declaration of the request
		 * @since 7.0
		 */
		S apiVersion(Object version);

		/**
		 * Set the attribute with the given name to the given value.
		 * @param name the name of the attribute to add
		 * @param value the value of the attribute to add
		 * @return this spec for further declaration of the request
		 */
		S attribute(String name, Object value);

		/**
		 * Manipulate the request attributes with the given consumer. The attributes provided to
		 * the consumer are ""live"", so that the consumer can be used to inspect attributes,
		 * remove attributes, or use any of the other map-provided methods.
		 * @param attributesConsumer a function that consumes the attributes
		 * @return this spec for further declaration of the request
		 */
		S attributes(Consumer<Map<String, Object>> attributesConsumer);

		/**
		 * Perform the exchange without a request body.
		 * @return a spec for decoding the response
		 */
		ResponseSpec exchange();
	}


	/**
	 * Specification for providing the body of a request.
	 */
	interface RequestBodySpec extends RequestHeadersSpec<RequestBodySpec> {

		/**
		 * Set the length of the body in bytes, as specified by the
		 * {@code Content-Length} header.
		 * @param contentLength the content length
		 * @return this spec for further declaration of the request
		 * @see HttpHeaders#setContentLength(long)
		 */
		RequestBodySpec contentLength(long contentLength);

		/**
		 * Set the {@linkplain MediaType media type} of the body, as specified
		 * by the {@code Content-Type} header.
		 * @param contentType the content type
		 * @return this spec for further declaration of the request
		 * @see HttpHeaders#setContentType(MediaType)
		 */
		RequestBodySpec contentType(MediaType contentType);

		/**
		 * Set the body to the given {@code Object} value. This method invokes the
		 * {@link WebClient.RequestBodySpec#bodyValue(Object)
		 * bodyValue} method on the underlying {@code WebClient}.
		 * @param body the value to write to the request body
		 * @return this spec for further declaration of the request
		 * @since 5.2
		 */
		RequestHeadersSpec<?> bodyValue(Object body);

		/**
		 * Set the body from the given {@code Publisher}. Shortcut for
		 * {@link #body(BodyInserter)} with a
		 * {@linkplain BodyInserters#fromPublisher Publisher inserter}.
		 * @param publisher the request body data
		 * @param elementClass the class of elements contained in the publisher
		 * @param <T> the type of the elements contained in the publisher
		 * @param <S> the type of the {@code Publisher}
		 * @return this spec for further declaration of the request
		 */
		<T, S extends Publisher<T>> RequestHeadersSpec<?> body(S publisher, Class<T> elementClass);

		/**
		 * Variant of {@link #body(Publisher, Class)} that allows providing
		 * element type information with generics.
		 * @param publisher the request body data
		 * @param elementTypeRef the type reference of elements contained in the publisher
		 * @param <T> the type of the elements contained in the publisher
		 * @param <S> the type of the {@code Publisher}
		 * @return this spec for further declaration of the request
		 * @since 5.2
		 */
		<T, S extends Publisher<T>> RequestHeadersSpec<?> body(
				S publisher, ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * Set the body from the given producer. This method invokes the
		 * {@link WebClient.RequestBodySpec#body(Object, Class)
		 * body(Object, Class)} method on the underlying {@code WebClient}.
		 * @param producer the producer to write to the request. This must be a
		 * {@link Publisher} or another producer adaptable to a
		 * {@code Publisher} via {@link ReactiveAdapterRegistry}
		 * @param elementClass the class of elements contained in the producer
		 * @return this spec for further declaration of the request
		 * @since 5.2
		 */
		RequestHeadersSpec<?> body(Object producer, Class<?> elementClass);

		/**
		 * Set the body from the given producer. This method invokes the
		 * {@link WebClient.RequestBodySpec#body(Object, ParameterizedTypeReference)
		 * body(Object, ParameterizedTypeReference)} method on the underlying {@code WebClient}.
		 * @param producer the producer to write to the request. This must be a
		 * {@link Publisher} or another producer adaptable to a
		 * {@code Publisher} via {@link ReactiveAdapterRegistry}
		 * @param elementTypeRef the type reference of elements contained in the producer
		 * @return this spec for further declaration of the request
		 * @since 5.2
		 */
		RequestHeadersSpec<?> body(Object producer, ParameterizedTypeReference<?> elementTypeRef);

		/**
		 * Set the body of the request to the given {@code BodyInserter}.
		 * <p>This method invokes the
		 * {@link WebClient.RequestBodySpec#body(BodyInserter)
		 * body(BodyInserter)} method on the underlying {@code WebClient}.
		 * @param inserter the body inserter to use
		 * @return this spec for further declaration of the request
		 * @see org.springframework.web.reactive.function.BodyInserters
		 */
		RequestHeadersSpec<?> body(BodyInserter<?, ? super ClientHttpRequest> inserter);
	}


	/**
	 * Specification for providing request headers and the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface RequestHeadersUriSpec<S extends RequestHeadersSpec<S>> extends UriSpec<S>, RequestHeadersSpec<S> {
	}


	/**
	 * Specification for providing the body and the URI of a request.
	 */
	interface RequestBodyUriSpec extends RequestBodySpec, RequestHeadersUriSpec<RequestBodySpec> {
	}


	/**
	 * Chained API for applying assertions to a response.
	 */
	interface ResponseSpec {

		/**
		 * Apply multiple assertions to a response with the given
		 * {@linkplain ResponseSpecConsumer consumers}, with the guarantee that
		 * all assertions will be applied even if one or more assertions fails
		 * with an exception.
		 * <p>If a single {@link Error} or {@link RuntimeException} is thrown,
		 * it will be rethrown.
		 * <p>If multiple exceptions are thrown, this method will throw an
		 * {@link AssertionError} whose error message is a summary of all the
		 * exceptions. In addition, each exception will be added as a
		 * {@linkplain Throwable#addSuppressed(Throwable) suppressed exception} to
		 * the {@code AssertionError}.
		 * <p>This feature is similar to the {@code SoftAssertions} support in
		 * AssertJ and the {@code assertAll()} support in JUnit Jupiter.
		 *
		 * <h4>Example</h4>
		 * <pre class=""code"">
		 * webTestClient.get().uri(""/hello"").exchange()
		 *     .expectAll(
		 *         responseSpec -&gt; responseSpec.expectStatus().isOk(),
		 *         responseSpec -&gt; responseSpec.expectBody(String.class).isEqualTo(""Hello, World!"")
		 *     );
		 * </pre>
		 * @param consumers the list of {@code ResponseSpec} consumers
		 * @since 5.3.10
		 */
		ResponseSpec expectAll(ResponseSpecConsumer... consumers);

		/**
		 * Assertions on the response status.
		 */
		StatusAssertions expectStatus();

		/**
		 * Assertions on the headers of the response.
		 */
		HeaderAssertions expectHeader();

		/**
		 * Assertions on the cookies of the response.
		 * @since 5.3
		 */
		CookieAssertions expectCookie();

		/**
		 * Consume and decode the response body to a single object of type
		 * {@code <B>} and then apply assertions.
		 * @param bodyType the expected body type
		 */
		<B> BodySpec<B, ?> expectBody(Class<B> bodyType);

		/**
		 * Alternative to {@link #expectBody(Class)} that accepts information
		 * about a target type with generics.
		 */
		<B> BodySpec<B, ?> expectBody(ParameterizedTypeReference<B> bodyType);

		/**
		 * Consume and decode the response body to {@code List<E>} and then apply
		 * List-specific assertions.
		 * @param elementType the expected List element type
		 */
		<E> ListBodySpec<E> expectBodyList(Class<E> elementType);

		/**
		 * Alternative to {@link #expectBodyList(Class)} that accepts information
		 * about a target type with generics.
		 */
		<E> ListBodySpec<E> expectBodyList(ParameterizedTypeReference<E> elementType);

		/**
		 * Consume and decode the response body to {@code byte[]} and then apply
		 * assertions on the raw content (for example, isEmpty, JSONPath, etc.).
		 */
		BodyContentSpec expectBody();

		/**
		 * Exit the chained flow in order to consume the response body externally,
		 * for example, via {@link reactor.test.StepVerifier}.
		 * <p>Note that when {@code Void.class} is passed in, the response body
		 * is consumed and released. If no content is expected, then consider
		 * using {@code .expectBody().isEmpty()} instead which asserts that
		 * there is no content.
		 */
		<T> FluxExchangeResult<T> returnResult(Class<T> elementClass);

		/**
		 * Alternative to {@link #returnResult(Class)} that accepts information
		 * about a target type with generics.
		 */
		<T> FluxExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * {@link Consumer} of a {@link ResponseSpec}.
		 * @since 5.3.10
		 * @see ResponseSpec#expectAll(ResponseSpecConsumer...)
		 */
		@FunctionalInterface
		interface ResponseSpecConsumer extends Consumer<ResponseSpec> {
		}
	}


	/**
	 * Spec for expectations on the response body decoded to a single Object.
	 *
	 * @param <S> a self reference to the spec type
	 * @param <B> the body type
	 */
	interface BodySpec<B, S extends BodySpec<B, S>> {

		/**
		 * Assert the extracted body is equal to the given value.
		 */
		<T extends S> T isEqualTo(@Nullable B expected);

		/**
		 * Assert the extracted body with a {@link Matcher}.
		 * @since 5.1
		 */
		<T extends S> T value(Matcher<? super @Nullable B> matcher);

		/**
		 * Transform the extracted the body with a function, for example, extracting a
		 * property, and assert the mapped value with a {@link Matcher}.
		 * @since 5.1
		 */
		<T extends S, R> T value(Function<@Nullable B, @Nullable R> bodyMapper, Matcher<? super @Nullable R> matcher);

		/**
		 * Assert the extracted body with a {@link Consumer}.
		 * @since 5.1
		 */
		<T extends S> T value(Consumer<@Nullable B> consumer);

		/**
		 * Assert the exchange result with the given {@link Consumer}.
		 */
		<T extends S> T consumeWith(Consumer<EntityExchangeResult<B>> consumer);

		/**
		 * Exit the chained API and return an {@code ExchangeResult} with the
		 * decoded response content.
		 */
		EntityExchangeResult<B> returnResult();
	}


	/**
	 * Spec for expectations on the response body decoded to a List.
	 *
	 * @param <E> the body list element type
	 */
	interface ListBodySpec<E> extends BodySpec<List<@Nullable E>, ListBodySpec<E>> {

		/**
		 * Assert the extracted list of values is of the given size.
		 * @param size the expected size
		 */
		ListBodySpec<E> hasSize(int size);

		/**
		 * Assert the extracted list of values contains the given elements.
		 * @param elements the elements to check
		 */
		@SuppressWarnings(""unchecked"")
		ListBodySpec<E> contains(@Nullable E... elements);

		/**
		 * Assert the extracted list of values doesn't contain the given elements.
		 * @param elements the elements to check
		 */
		@SuppressWarnings(""unchecked"")
		ListBodySpec<E> doesNotContain(@Nullable E... elements);
	}


	/**
	 * Spec for expectations on the response body content.
	 */
	interface BodyContentSpec {
		/**
		 * Assert the response body is empty and return the exchange result.
		 */
		EntityExchangeResult<Void> isEmpty();

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison verifying that they contain the same attribute-value pairs
		 * regardless of formatting with <em>lenient</em> checking (extensible
		 * and non-strict array ordering).
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @see #json(String, JsonCompareMode)
		 */
		default BodyContentSpec json(String expectedJson) {
			return json(expectedJson, JsonCompareMode.LENIENT);
		}

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison verifying that they contain the same attribute-value pairs
		 * regardless of formatting.
		 * <p>Can compare in two modes, depending on the {@code strict} parameter value:
		 * <ul>
		 * <li>{@code true}: strict checking. Not extensible and strict array ordering.</li>
		 * <li>{@code false}: lenient checking. Extensible and non-strict array ordering.</li>
		 * </ul>
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @param strict enables strict checking if {@code true}
		 * @since 5.3.16
		 * @see #json(String)
		 * @deprecated in favor of {@link #json(String, JsonCompareMode)}
		 */
		@Deprecated(since = ""6.2"")
		BodyContentSpec json(String expectedJson, boolean strict);

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison using the given {@linkplain JsonCompareMode mode}. If the
		 * comparison failed, throws an {@link AssertionError} with the message
		 * of the {@link JsonComparison}.
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @param compareMode the compare mode
		 * @since 6.2
		 * @see #json(String)
		 */
		BodyContentSpec json(String expectedJson, JsonCompareMode compareMode);

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison using the given {@link JsonComparator}. If the comparison
		 * failed, throws an {@link AssertionError} with the message  of the
		 * {@link JsonComparison}.
		 * @param expectedJson the expected JSON content
		 * @param comparator the comparator to use
		 * @since 6.2
		 */
		BodyContentSpec json(String expectedJson, JsonComparator comparator);

		/**
		 * Parse expected and actual response content as XML and assert that
		 * the two are ""similar"", i.e. they contain the same elements and
		 * attributes regardless of order.
		 * <p>Use of this method requires the
		 * <a href=""https://github.com/xmlunit/xmlunit"">XMLUnit</a> library on
		 * the classpath.
		 * @param expectedXml the expected XML content.
		 * @since 5.1
		 * @see org.springframework.test.util.XmlExpectationsHelper#assertXmlEqual(String, String)
		 */
		BodyContentSpec xml(String expectedXml);

		/**
		 * Access to response body assertions using a
		 * <a href=""https://github.com/jayway/JsonPath"">JsonPath</a> expression
		 * to inspect a specific subset of the body.
		 * @param expression the JsonPath expression
		 * @since 6.2
		 */
		JsonPathAssertions jsonPath(String expression);

		/**
		 * Access to response body assertions using an XPath expression to
		 * inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param args arguments to parameterize the expression
		 * @since 5.1
		 * @see #xpath(String, Map, Object...)
		 */
		default XpathAssertions xpath(String expression, Object... args) {
			return xpath(expression, null, args);
		}

		/**
		 * Access to response body assertions with specific namespaces using an
		 * XPath expression to inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param namespaces the namespaces to use
		 * @param args arguments to parameterize the expression
		 * @since 5.1
		 */
		XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args);

		/**
		 * Assert the response body content with the given {@link Consumer}.
		 * @param consumer the consumer for the response body; the input
		 * {@code byte[]} may be {@code null} if there was no response body.
		 */
		BodyContentSpec consumeWith(Consumer<EntityExchangeResult<byte[]>> consumer);

		/**
		 * Exit the chained API and return an {@code ExchangeResult} with the
		 * raw response content.
		 */
		EntityExchangeResult<byte[]> returnResult();
	}

}
"
521764e68b7ab425ff7964e0b3d9d303c80adf7b,"Fix links, @since tags, formatting, etc. in RestTestClient",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.test.web.servlet.client;

import java.net.URI;
import java.nio.charset.Charset;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;

import org.hamcrest.Matcher;
import org.jspecify.annotations.Nullable;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.converter.HttpMessageConverters;
import org.springframework.test.json.JsonComparator;
import org.springframework.test.json.JsonCompareMode;
import org.springframework.test.json.JsonComparison;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MockMvcBuilder;
import org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder;
import org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.ApiVersionFormatter;
import org.springframework.web.client.ApiVersionInserter;
import org.springframework.web.client.RestClient;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.function.RouterFunction;
import org.springframework.web.util.UriBuilder;
import org.springframework.web.util.UriBuilderFactory;

/**
 * Client for testing web servers that uses {@link RestClient} internally to
 * perform requests while also providing a fluent API to verify responses.
 * This client can connect to any server over HTTP or to a {@link MockMvc} server
 * with a mock request and response.
 *
 * <p>Use one of the bindToXxx methods to create an instance. For example:
 * <ul>
 * <li>{@link #bindToController(Object...)}
 * <li>{@link #bindToRouterFunction(RouterFunction[])}
 * <li>{@link #bindToApplicationContext(WebApplicationContext)}
 * <li>{@link #bindToServer()}
 * <li>...
 * </ul>
 *
 * @author Rob Worsnop
 * @author Rossen Stoyanchev
 * @since 7.0
 */
public interface RestTestClient {

	/**
	 * The name of a request header used to assign a unique id to every request
	 * performed through the {@code RestTestClient}. This can be useful for
	 * storing contextual information at all phases of request processing (for example,
	 * from a server-side component) under that id and later to look up
	 * that information once an {@link ExchangeResult} is available.
	 */
	String RESTTESTCLIENT_REQUEST_ID = ""RestTestClient-Request-Id"";


	/**
	 * Prepare an HTTP GET request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> get();

	/**
	 * Prepare an HTTP HEAD request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> head();

	/**
	 * Prepare an HTTP POST request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec post();

	/**
	 * Prepare an HTTP PUT request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec put();

	/**
	 * Prepare an HTTP PATCH request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec patch();

	/**
	 * Prepare an HTTP DELETE request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> delete();

	/**
	 * Prepare an HTTP OPTIONS request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> options();

	/**
	 * Prepare a request for the specified {@code HttpMethod}.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec method(HttpMethod method);


	/**
	 * Return a builder to mutate properties of this test client.
	 */
	<B extends Builder<B>> Builder<B> mutate();


	/**
	 * Begin creating a {@link RestTestClient} with a {@link MockMvcBuilders#standaloneSetup
	 * Standalone MockMvc setup}.
	 */
	static StandaloneSetupBuilder bindToController(Object... controllers) {
		return new DefaultRestTestClientBuilder.DefaultStandaloneSetupBuilder(controllers);
	}

	/**
	 * Begin creating a {@link RestTestClient} with a {@link MockMvcBuilders#routerFunctions}
	 * RouterFunction's MockMvc setup}.
	 */
	static RouterFunctionSetupBuilder bindToRouterFunction(RouterFunction<?>... routerFunctions) {
		return new DefaultRestTestClientBuilder.DefaultRouterFunctionSetupBuilder(routerFunctions);
	}

	/**
	 * Begin creating a {@link RestTestClient} with a {@link MockMvcBuilders#webAppContextSetup}
	 * WebAppContext MockMvc setup}.
	 */
	static WebAppContextSetupBuilder bindToApplicationContext(WebApplicationContext context) {
		return new DefaultRestTestClientBuilder.DefaultWebAppContextSetupBuilder(context);
	}

	/**
	 * Begin creating a {@link RestTestClient} by providing an already
	 * initialized {@link MockMvc} instance to use as the server.
	 */
	static Builder<?> bindTo(MockMvc mockMvc) {
		ClientHttpRequestFactory requestFactory = new MockMvcClientHttpRequestFactory(mockMvc);
		return RestTestClient.bindToServer(requestFactory);
	}

	/**
	 * This server setup option allows you to connect to a live server.
	 * <p><pre class=""code"">
	 * RestTestClient client = RestTestClient.bindToServer()
	 *         .baseUrl(""http://localhost:8080"")
	 *         .build();
	 * </pre>
	 * @return chained API to customize client config
	 */
	static Builder<?> bindToServer() {
		return new DefaultRestTestClientBuilder<>();
	}

	/**
	 * A variant of {@link #bindToServer()} with a pre-configured request factory.
	 * @return chained API to customize client config
	 */
	static Builder<?> bindToServer(ClientHttpRequestFactory requestFactory) {
		return new DefaultRestTestClientBuilder<>(RestClient.builder().requestFactory(requestFactory));
	}


	/**
	 * Steps to customize the underlying {@link RestClient} via {@link RestClient.Builder}.
	 * @param <B> the type of builder
	 */
	interface Builder<B extends Builder<B>> {

		/**
		 * Configure a base URI as described in {@link RestClient#create(String)}.
		 */
		<T extends B> T baseUrl(String baseUrl);

		/**
		 * Provide a pre-configured {@link UriBuilderFactory} instance as an
		 * alternative to and effectively overriding {@link #baseUrl(String)}.
		 */
		<T extends B> T uriBuilderFactory(UriBuilderFactory uriBuilderFactory);

		/**
		 * Add the given header to all requests that haven't added it.
		 * @param headerName the header name
		 * @param headerValues the header values
		 */
		<T extends B> T defaultHeader(String headerName, String... headerValues);

		/**
		 * Manipulate the default headers with the given consumer. The
		 * headers provided to the consumer are ""live"", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this builder
		 */
		<T extends B> T defaultHeaders(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Add the given cookie to all requests that haven't already added it.
		 * @param cookieName the cookie name
		 * @param cookieValues the cookie values
		 */
		<T extends B> T defaultCookie(String cookieName, String... cookieValues);

		/**
		 * Manipulate the default cookies with the given consumer. The
		 * map provided to the consumer is ""live"", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this builder
		 */
		<T extends B> T defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Global option to specify an API version to add to every request,
		 * if not already set.
		 * @param version the version to use
		 * @return this builder
		 * @since 7.0
		 */
		<T extends B> T defaultApiVersion(Object version);

		/**
		 * Configure an {@link ApiVersionInserter} to abstract how an API version
		 * specified via {@link RequestHeadersSpec#apiVersion(Object)}
		 * is inserted into the request.
		 * @param apiVersionInserter the inserter to use
		 * @since 7.0
		 */
		<T extends B> T apiVersionInserter(ApiVersionInserter apiVersionInserter);

		/**
		 * Add the given request interceptor to the end of the interceptor chain.
		 * @param interceptor the interceptor to be added to the chain
		 */
		<T extends B> T requestInterceptor(ClientHttpRequestInterceptor interceptor);

		/**
		 * Manipulate the interceptors with the given consumer. The list provided to
		 * the consumer is ""live"", so that the consumer can be used to remove
		 * interceptors, change ordering, etc.
		 * @param interceptorsConsumer a function that consumes the interceptors list
		 * @return this builder
		 */
		<T extends B> T requestInterceptors(Consumer<List<ClientHttpRequestInterceptor>> interceptorsConsumer);

		/**
		 * Configure the message converters to use for the request and response body.
		 * @param configurer the configurer to apply on an empty {@link HttpMessageConverters.ClientBuilder}.
		 * @return this builder
		 */
		<T extends B> T configureMessageConverters(Consumer<HttpMessageConverters.ClientBuilder> configurer);

		/**
		 * Configure an {@code EntityExchangeResult} callback that is invoked
		 * every time after a response is fully decoded to a single entity, to a
		 * List of entities, or to a byte[]. In effect, equivalent to each and
		 * all of the below but registered once, globally:
		 * <pre>
		 * client.get().uri(""/accounts/1"")
		 *         .exchange()
		 *         .expectBody(Person.class).consumeWith(exchangeResult -&gt; ... ));
		 *
		 * client.get().uri(""/accounts"")
		 *         .exchange()
		 *         .expectBodyList(Person.class).consumeWith(exchangeResult -&gt; ... ));
		 *
		 * client.get().uri(""/accounts/1"")
		 *         .exchange()
		 *         .expectBody().consumeWith(exchangeResult -&gt; ... ));
		 * </pre>
		 * <p>Note that the configured consumer does not apply to responses
		 * decoded to {@code Flux<T>} which can be consumed outside the workflow
		 * of the test client, for example via {@code reactor.test.StepVerifier}.
		 * @param consumer the consumer to apply to entity responses
		 * @return the builder
		 */
		<T extends B> T entityExchangeResultConsumer(Consumer<EntityExchangeResult<?>> consumer);

		/**
		 * Build the {@link RestTestClient} instance.
		 */
		RestTestClient build();
	}


	/**
	 * Extension of {@link Builder} for tests against a MockMvc server.
	 * @param <S> the builder type
	 * @param <M> the type of {@link MockMvc} setup
	 */
	interface MockMvcSetupBuilder<S extends Builder<S>, M extends MockMvcBuilder> extends Builder<S> {

		<T extends S> T configureServer(Consumer<M> consumer);
	}


	/**
	 * Extension of {@link Builder} for tests  
	 * {@link MockMvcBuilders#standaloneSetup(Object...) standalone MockMvc setup}.
	 */
	interface StandaloneSetupBuilder extends MockMvcSetupBuilder<StandaloneSetupBuilder, StandaloneMockMvcBuilder> {
	}


	/**
	 * Extension of {@link Builder} for tests  
	 * {@link MockMvcBuilders#routerFunctions(RouterFunction[]) RouterFunction MockMvc setup}.
	 */
	interface RouterFunctionSetupBuilder extends MockMvcSetupBuilder<RouterFunctionSetupBuilder, RouterFunctionMockMvcBuilder> {
	}


	/**
	 * Extension of {@link Builder} for tests  
	 * {@link MockMvcBuilders#webAppContextSetup(WebApplicationContext) WebAppContext MockMvc setup}.
	 */
	interface WebAppContextSetupBuilder extends MockMvcSetupBuilder<WebAppContextSetupBuilder, DefaultMockMvcBuilder> {
	}


	/**
	 * Specification for providing the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface UriSpec<S extends RequestHeadersSpec<?>> {

		/**
		 * Specify the URI using an absolute, fully constructed {@link java.net.URI}.
		 * <p>If a {@link UriBuilderFactory} was configured for the client with
		 * a base URI, that base URI will <strong>not</strong> be applied to the
		 * supplied {@code java.net.URI}. If you wish to have a base URI applied to a
		 * {@code java.net.URI} you must invoke either {@link #uri(String, Object...)}
		 * or {@link #uri(String, Map)} &mdash; for example, {@code uri(myUri.toString())}.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(URI uri);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * <p>If a {@link UriBuilderFactory} was configured for the client (for example,
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(String uri, @Nullable Object... uriVariables);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * <p>If a {@link UriBuilderFactory} was configured for the client (for example,
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(String uri, Map<String, ? extends @Nullable Object> uriVariables);

		/**
		 * Build the URI for the request with a {@link UriBuilder} obtained
		 * through the {@link UriBuilderFactory} configured for this client.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(Function<UriBuilder, URI> uriFunction);
	}


	/**
	 * Specification for adding request headers and performing an exchange.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface RequestHeadersSpec<S extends RequestHeadersSpec<S>> {

		/**
		 * Set the list of acceptable {@linkplain MediaType media types}, as
		 * specified by the {@code Accept} header.
		 * @param acceptableMediaTypes the acceptable media types
		 * @return the same instance
		 */
		S accept(MediaType... acceptableMediaTypes);

		/**
		 * Set the list of acceptable {@linkplain Charset charsets}, as specified
		 * by the {@code Accept-Charset} header.
		 * @param acceptableCharsets the acceptable charsets
		 * @return the same instance
		 */
		S acceptCharset(Charset... acceptableCharsets);

		/**
		 * Add a cookie with the given name and value.
		 * @param name the cookie name
		 * @param value the cookie value
		 * @return the same instance
		 */
		S cookie(String name, String value);

		/**
		 * Manipulate this request's cookies with the given consumer. The
		 * map provided to the consumer is ""live"", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this builder
		 */
		S cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Set the value of the {@code If-Modified-Since} header.
		 * <p>The date should be specified as the number of milliseconds since
		 * January 1, 1970 GMT.
		 * @param ifModifiedSince the new value of the header
		 * @return the same instance
		 */
		S ifModifiedSince(ZonedDateTime ifModifiedSince);

		/**
		 * Set the values of the {@code If-None-Match} header.
		 * @param ifNoneMatches the new value of the header
		 * @return the same instance
		 */
		S ifNoneMatch(String... ifNoneMatches);

		/**
		 * Add the given, single header value under the given name.
		 * @param headerName  the header name
		 * @param headerValues the header value(s)
		 * @return the same instance
		 */
		S header(String headerName, String... headerValues);

		/**
		 * Manipulate the request's headers with the given consumer. The
		 * headers provided to the consumer are ""live"", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this builder
		 */
		S headers(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Set an API version for the request. The version is inserted into the
		 * request by the {@linkplain Builder#apiVersionInserter(ApiVersionInserter)
		 * configured} {@code ApiVersionInserter}.
		 * @param version the API version of the request; this can be a String or
		 * some Object that can be formatted by the inserter &mdash; for example,
		 * through an {@link ApiVersionFormatter}
		 * @since 7.0
		 */
		S apiVersion(Object version);

		/**
		 * Set the attribute with the given name to the given value.
		 * @param name the name of the attribute to add
		 * @param value the value of the attribute to add
		 * @return this builder
		 */
		S attribute(String name, Object value);

		/**
		 * Manipulate the request attributes with the given consumer. The attributes provided to
		 * the consumer are ""live"", so that the consumer can be used to inspect attributes,
		 * remove attributes, or use any of the other map-provided methods.
		 * @param attributesConsumer a function that consumes the attributes
		 * @return this builder
		 */
		S attributes(Consumer<Map<String, Object>> attributesConsumer);

		/**
		 * Perform the exchange without a request body.
		 * @return spec for decoding the response
		 */
		ResponseSpec exchange();
	}


	/**
	 * Specification for providing body of a request.
	 */
	interface RequestBodySpec extends RequestHeadersSpec<RequestBodySpec> {

		/**
		 * Set the length of the body in bytes, as specified by the
		 * {@code Content-Length} header.
		 * @param contentLength the content length
		 * @return the same instance
		 * @see HttpHeaders#setContentLength(long)
		 */
		RequestBodySpec contentLength(long contentLength);

		/**
		 * Set the {@linkplain MediaType media type} of the body, as specified
		 * by the {@code Content-Type} header.
		 * @param contentType the content type
		 * @return the same instance
		 * @see HttpHeaders#setContentType(MediaType)
		 */
		RequestBodySpec contentType(MediaType contentType);

		/**
		 * Set the body to the given {@code Object} value. This method invokes the
		 * {@link RestClient.RequestBodySpec#body(Object)} (Object)
		 * bodyValue} method on the underlying {@code RestClient}.
		 * @param body the value to write to the request body
		 * @return spec for further declaration of the request
		 */
		RequestHeadersSpec<?> body(Object body);
	}


	/**
	 * Specification for providing request headers and the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface RequestHeadersUriSpec<S extends RequestHeadersSpec<S>> extends UriSpec<S>, RequestHeadersSpec<S> {
	}


	/**
	 * Specification for providing the body and the URI of a request.
	 */
	interface RequestBodyUriSpec extends RequestBodySpec, RequestHeadersUriSpec<RequestBodySpec> {
	}


	/**
	 * Chained API for applying assertions to a response.
	 */
	interface ResponseSpec {

		/**
		 * Apply multiple assertions to a response with the given
		 * {@linkplain ResponseSpecConsumer consumers}, with the guarantee that
		 * all assertions will be applied even if one or more assertions fails
		 * with an exception.
		 * <p>If a single {@link Error} or {@link RuntimeException} is thrown,
		 * it will be rethrown.
		 * <p>If multiple exceptions are thrown, this method will throw an
		 * {@link AssertionError} whose error message is a summary of all the
		 * exceptions. In addition, each exception will be added as a
		 * {@linkplain Throwable#addSuppressed(Throwable) suppressed exception} to
		 * the {@code AssertionError}.
		 * <p>This feature is similar to the {@code SoftAssertions} support in
		 * AssertJ and the {@code assertAll()} support in JUnit Jupiter.
		 *
		 * <h4>Example</h4>
		 * <pre class=""code"">
		 * restTestClient.get().uri(""/hello"").exchange()
		 *     .expectAll(
		 *         responseSpec -&gt; responseSpec.expectStatus().isOk(),
		 *         responseSpec -&gt; responseSpec.expectBody(String.class).isEqualTo(""Hello, World!"")
		 *     );
		 * </pre>
		 * @param consumers the list of {@code ResponseSpec} consumers
		 */
		ResponseSpec expectAll(ResponseSpecConsumer... consumers);

		/**
		 * Assertions on the response status.
		 */
		StatusAssertions expectStatus();

		/**
		 * Assertions on the headers of the response.
		 */
		HeaderAssertions expectHeader();

		/**
		 * Assertions on the cookies of the response.
		 */
		CookieAssertions expectCookie();

		/**
		 * Consume and decode the response body to a single object of type
		 * {@code <B>} and then apply assertions.
		 * @param bodyType the expected body type
		 */
		<B> BodySpec<B, ?> expectBody(Class<B> bodyType);

		/**
		 * Alternative to {@link #expectBody(Class)} that accepts information
		 * about a target type with generics.
		 */
		<B> BodySpec<B, ?> expectBody(ParameterizedTypeReference<B> bodyType);

		/**
		 * Consume and decode the response body to {@code byte[]} and then apply
		 * assertions on the raw content (for example, isEmpty, JSONPath, etc.).
		 */
		BodyContentSpec expectBody();

		/**
		 * Exit the chained flow in order to consume the response body externally.
		 */
		<T> EntityExchangeResult<T> returnResult(Class<T> elementClass);

		/**
		 * Alternative to {@link #returnResult(Class)} that accepts information
		 * about a target type with generics.
		 */
		<T> EntityExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * {@link Consumer} of a {@link ResponseSpec}.
		 * @see ResponseSpec#expectAll(ResponseSpecConsumer...)
		 */
		@FunctionalInterface
		interface ResponseSpecConsumer extends Consumer<ResponseSpec> {
		}
	}


	/**
	 * Spec for expectations on the response body decoded to a single Object.
	 *
	 * @param <S> a self reference to the spec type
	 * @param <B> the body type
	 */
	interface BodySpec<B, S extends BodySpec<B, S>> {

		/**
		 * Assert the extracted body is equal to the given value.
		 */
		<T extends S> T isEqualTo(@Nullable B expected);

		/**
		 * Assert the extracted body with a {@link Matcher}.
		 * @since 5.1
		 */
		<T extends S> T value(Matcher<? super @Nullable B> matcher);

		/**
		 * Transform the extracted the body with a function, for example, extracting a
		 * property, and assert the mapped value with a {@link Matcher}.
		 */
		<T extends S, R> T value(Function<@Nullable B, @Nullable R> bodyMapper, Matcher<? super @Nullable R> matcher);

		/**
		 * Assert the extracted body with a {@link Consumer}.
		 */
		<T extends S> T value(Consumer<@Nullable B> consumer);

		/**
		 * Assert the exchange result with the given {@link Consumer}.
		 */
		<T extends S> T consumeWith(Consumer<EntityExchangeResult<B>> consumer);

		/**
		 * Exit the chained API and return an {@code EntityExchangeResult} with the
		 * decoded response content.
		 */
		EntityExchangeResult<B> returnResult();
	}


	/**
	 * Spec for expectations on the response body content.
	 */
	interface BodyContentSpec {
		/**
		 * Assert the response body is empty and return the exchange result.
		 */
		EntityExchangeResult<Void> isEmpty();

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison verifying that they contain the same attribute-value pairs
		 * regardless of formatting with <em>lenient</em> checking (extensible
		 * and non-strict array ordering).
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @see #json(String, JsonCompareMode)
		 */
		default BodyContentSpec json(String expectedJson) {
			return json(expectedJson, JsonCompareMode.LENIENT);
		}

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison using the given {@linkplain JsonCompareMode mode}. If the
		 * comparison failed, throws an {@link AssertionError} with the message
		 * of the {@link JsonComparison}.
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @param compareMode the compare mode
		 * @see #json(String)
		 */
		BodyContentSpec json(String expectedJson, JsonCompareMode compareMode);

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison using the given {@link JsonComparator}. If the comparison
		 * failed, throws an {@link AssertionError} with the message  of the
		 * {@link JsonComparison}.
		 * @param expectedJson the expected JSON content
		 * @param comparator the comparator to use
		 */
		BodyContentSpec json(String expectedJson, JsonComparator comparator);

		/**
		 * Parse expected and actual response content as XML and assert that
		 * the two are ""similar"", i.e. they contain the same elements and
		 * attributes regardless of order.
		 * <p>Use of this method requires the
		 * <a href=""https://github.com/xmlunit/xmlunit"">XMLUnit</a> library on
		 * the classpath.
		 * @param expectedXml the expected XML content.
		 * @see org.springframework.test.util.XmlExpectationsHelper#assertXmlEqual(String, String)
		 */
		BodyContentSpec xml(String expectedXml);

		/**
		 * Access to response body assertions using a
		 * <a href=""https://github.com/jayway/JsonPath"">JsonPath</a> expression
		 * to inspect a specific subset of the body.
		 * @param expression the JsonPath expression
		 */
		JsonPathAssertions jsonPath(String expression);

		/**
		 * Access to response body assertions using an XPath expression to
		 * inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param args arguments to parameterize the expression
		 * @see #xpath(String, Map, Object...)
		 */
		default XpathAssertions xpath(String expression, Object... args) {
			return xpath(expression, null, args);
		}

		/**
		 * Access to response body assertions with specific namespaces using an
		 * XPath expression to inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param namespaces the namespaces to use
		 * @param args arguments to parameterize the expression
		 */
		XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args);

		/**
		 * Assert the response body content with the given {@link Consumer}.
		 * @param consumer the consumer for the response body; the input
		 * {@code byte[]} may be {@code null} if there was no response body.
		 */
		BodyContentSpec consumeWith(Consumer<EntityExchangeResult<byte[]>> consumer);

		/**
		 * Exit the chained API and return an {@code ExchangeResult} with the
		 * raw response content.
		 */
		EntityExchangeResult<byte[]> returnResult();
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.test.web.servlet.client;

import java.net.URI;
import java.nio.charset.Charset;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;

import org.hamcrest.Matcher;
import org.jspecify.annotations.Nullable;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.converter.HttpMessageConverters;
import org.springframework.test.json.JsonComparator;
import org.springframework.test.json.JsonCompareMode;
import org.springframework.test.json.JsonComparison;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MockMvcBuilder;
import org.springframework.test.web.servlet.setup.DefaultMockMvcBuilder;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.test.web.servlet.setup.RouterFunctionMockMvcBuilder;
import org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.ApiVersionFormatter;
import org.springframework.web.client.ApiVersionInserter;
import org.springframework.web.client.RestClient;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.function.RouterFunction;
import org.springframework.web.util.UriBuilder;
import org.springframework.web.util.UriBuilderFactory;

/**
 * Client for testing web servers that uses {@link RestClient} internally to
 * perform requests while also providing a fluent API to verify responses.
 *
 * <p>This client can connect to any server over HTTP or to a {@link MockMvc}
 * server with a mock request and response.
 *
 * <p>Use one of the {@code bindToXxx()} methods to create an instance. For example:
 * <ul>
 * <li>{@link #bindToController(Object...)}
 * <li>{@link #bindToRouterFunction(RouterFunction[])}
 * <li>{@link #bindToApplicationContext(WebApplicationContext)}
 * <li>{@link #bindToServer()}
 * <li>...
 * </ul>
 *
 * @author Rob Worsnop
 * @author Rossen Stoyanchev
 * @since 7.0
 */
public interface RestTestClient {

	/**
	 * The name of a request header used to assign a unique ID to every request
	 * performed through the {@code RestTestClient}. This can be useful to
	 * store contextual information under that ID at all phases of request
	 * processing (for example, from a server-side component) and later look up
	 * that information once an {@link ExchangeResult} is available.
	 */
	String RESTTESTCLIENT_REQUEST_ID = ""RestTestClient-Request-Id"";


	/**
	 * Prepare an HTTP GET request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> get();

	/**
	 * Prepare an HTTP HEAD request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> head();

	/**
	 * Prepare an HTTP POST request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec post();

	/**
	 * Prepare an HTTP PUT request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec put();

	/**
	 * Prepare an HTTP PATCH request.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec patch();

	/**
	 * Prepare an HTTP DELETE request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> delete();

	/**
	 * Prepare an HTTP OPTIONS request.
	 * @return a spec for specifying the target URL
	 */
	RequestHeadersUriSpec<?> options();

	/**
	 * Prepare a request for the specified {@code HttpMethod}.
	 * @return a spec for specifying the target URL
	 */
	RequestBodyUriSpec method(HttpMethod method);


	/**
	 * Return a builder to mutate properties of this test client.
	 */
	<B extends Builder<B>> Builder<B> mutate();


	/**
	 * Begin creating a {@link RestTestClient} with a {@linkplain MockMvcBuilders#standaloneSetup
	 * Standalone MockMvc setup}.
	 */
	static StandaloneSetupBuilder bindToController(Object... controllers) {
		return new DefaultRestTestClientBuilder.DefaultStandaloneSetupBuilder(controllers);
	}

	/**
	 * Begin creating a {@link RestTestClient} with a {@linkplain MockMvcBuilders#routerFunctions
	 * RouterFunction MockMvc setup}.
	 */
	static RouterFunctionSetupBuilder bindToRouterFunction(RouterFunction<?>... routerFunctions) {
		return new DefaultRestTestClientBuilder.DefaultRouterFunctionSetupBuilder(routerFunctions);
	}

	/**
	 * Begin creating a {@link RestTestClient} with a {@linkplain MockMvcBuilders#webAppContextSetup
	 * WebApplicationContext MockMvc setup}.
	 */
	static WebAppContextSetupBuilder bindToApplicationContext(WebApplicationContext context) {
		return new DefaultRestTestClientBuilder.DefaultWebAppContextSetupBuilder(context);
	}

	/**
	 * Begin creating a {@link RestTestClient} by providing an already
	 * initialized {@link MockMvc} instance to use as the server.
	 */
	static Builder<?> bindTo(MockMvc mockMvc) {
		ClientHttpRequestFactory requestFactory = new MockMvcClientHttpRequestFactory(mockMvc);
		return RestTestClient.bindToServer(requestFactory);
	}

	/**
	 * This server setup option allows you to connect to a live server.
	 * <p><pre class=""code"">
	 * RestTestClient client = RestTestClient.bindToServer()
	 *         .baseUrl(""http://localhost:8080"")
	 *         .build();
	 * </pre>
	 * @return chained API to customize client config
	 */
	static Builder<?> bindToServer() {
		return new DefaultRestTestClientBuilder<>();
	}

	/**
	 * A variant of {@link #bindToServer()} with a pre-configured request factory.
	 * @return chained API to customize client config
	 */
	static Builder<?> bindToServer(ClientHttpRequestFactory requestFactory) {
		return new DefaultRestTestClientBuilder<>(RestClient.builder().requestFactory(requestFactory));
	}


	/**
	 * Steps to customize the underlying {@link RestClient} via {@link RestClient.Builder}.
	 * @param <B> the type of builder
	 */
	interface Builder<B extends Builder<B>> {

		/**
		 * Configure a base URI as described in {@link RestClient#create(String)}.
		 * @return this builder
		 */
		<T extends B> T baseUrl(String baseUrl);

		/**
		 * Provide a pre-configured {@link UriBuilderFactory} instance as an
		 * alternative to and effectively overriding {@link #baseUrl(String)}.
		 * @return this builder
		 */
		<T extends B> T uriBuilderFactory(UriBuilderFactory uriBuilderFactory);

		/**
		 * Add the given header to all requests that have not added it.
		 * @param headerName the header name
		 * @param headerValues the header values
		 * @return this builder
		 */
		<T extends B> T defaultHeader(String headerName, String... headerValues);

		/**
		 * Manipulate the default headers with the given consumer. The headers
		 * provided to the consumer are ""live"", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this builder
		 */
		<T extends B> T defaultHeaders(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Add the given cookie to all requests that have not already added it.
		 * @param cookieName the cookie name
		 * @param cookieValues the cookie values
		 * @return this builder
		 */
		<T extends B> T defaultCookie(String cookieName, String... cookieValues);

		/**
		 * Manipulate the default cookies with the given consumer. The map provided
		 * to the consumer is ""live"", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this builder
		 */
		<T extends B> T defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Global option to specify an API version to add to every request,
		 * if not already set.
		 * @param version the version to use
		 * @return this builder
		 */
		<T extends B> T defaultApiVersion(Object version);

		/**
		 * Configure an {@link ApiVersionInserter} to abstract how an API version
		 * specified via {@link RequestHeadersSpec#apiVersion(Object)}
		 * is inserted into the request.
		 * @param apiVersionInserter the inserter to use
		 */
		<T extends B> T apiVersionInserter(ApiVersionInserter apiVersionInserter);

		/**
		 * Add the given request interceptor to the end of the interceptor chain.
		 * @param interceptor the interceptor to be added to the chain
		 */
		<T extends B> T requestInterceptor(ClientHttpRequestInterceptor interceptor);

		/**
		 * Manipulate the interceptors with the given consumer. The list provided to
		 * the consumer is ""live"", so that the consumer can be used to remove
		 * interceptors, change ordering, etc.
		 * @param interceptorsConsumer a function that consumes the interceptors list
		 * @return this builder
		 */
		<T extends B> T requestInterceptors(Consumer<List<ClientHttpRequestInterceptor>> interceptorsConsumer);

		/**
		 * Configure the message converters to use for the request and response body.
		 * @param configurer the configurer to apply on an empty {@link HttpMessageConverters.ClientBuilder}.
		 * @return this builder
		 */
		<T extends B> T configureMessageConverters(Consumer<HttpMessageConverters.ClientBuilder> configurer);

		/**
		 * Configure an {@link EntityExchangeResult} callback that is invoked
		 * every time after a response is fully decoded to a single entity, to a
		 * List of entities, or to a byte[]. In effect, this is equivalent to each
		 * of the below but registered only once, globally.
		 * <pre>
		 * client.get().uri(""/accounts/1"")
		 *         .exchange()
		 *         .expectBody(Person.class).consumeWith(exchangeResult -&gt; ... ));
		 *
		 * client.get().uri(""/accounts"")
		 *         .exchange()
		 *         .expectBodyList(Person.class).consumeWith(exchangeResult -&gt; ... ));
		 *
		 * client.get().uri(""/accounts/1"")
		 *         .exchange()
		 *         .expectBody().consumeWith(exchangeResult -&gt; ... ));
		 * </pre>
		 * <p>Note that the configured consumer does not apply to responses
		 * decoded to {@code Flux<T>} which can be consumed outside the workflow
		 * of the test client, for example via {@code reactor.test.StepVerifier}.
		 * @param consumer the consumer to apply to entity responses
		 * @return the builder
		 */
		<T extends B> T entityExchangeResultConsumer(Consumer<EntityExchangeResult<?>> consumer);

		/**
		 * Build the {@link RestTestClient} instance.
		 */
		RestTestClient build();
	}


	/**
	 * Extension of {@link Builder} for tests against a MockMvc server.
	 * @param <S> the builder type
	 * @param <M> the type of {@link MockMvc} setup
	 */
	interface MockMvcSetupBuilder<S extends Builder<S>, M extends MockMvcBuilder> extends Builder<S> {

		<T extends S> T configureServer(Consumer<M> consumer);
	}


	/**
	 * Extension of {@link Builder} for tests against 
	 * {@linkplain MockMvcBuilders#standaloneSetup(Object...) standalone MockMvc setup}.
	 */
	interface StandaloneSetupBuilder extends MockMvcSetupBuilder<StandaloneSetupBuilder, StandaloneMockMvcBuilder> {
	}


	/**
	 * Extension of {@link Builder} for tests against 
	 * {@linkplain MockMvcBuilders#routerFunctions(RouterFunction[]) RouterFunction MockMvc setup}.
	 */
	interface RouterFunctionSetupBuilder extends MockMvcSetupBuilder<RouterFunctionSetupBuilder, RouterFunctionMockMvcBuilder> {
	}


	/**
	 * Extension of {@link Builder} for tests against 
	 * {@linkplain MockMvcBuilders#webAppContextSetup(WebApplicationContext) WebAppContext MockMvc setup}.
	 */
	interface WebAppContextSetupBuilder extends MockMvcSetupBuilder<WebAppContextSetupBuilder, DefaultMockMvcBuilder> {
	}


	/**
	 * Specification for providing the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface UriSpec<S extends RequestHeadersSpec<?>> {

		/**
		 * Specify the URI using an absolute, fully constructed {@link java.net.URI}.
		 * <p>If a {@link UriBuilderFactory} was configured for the client with
		 * a base URI, that base URI will <strong>not</strong> be applied to the
		 * supplied {@code java.net.URI}. If you wish to have a base URI applied to a
		 * {@code java.net.URI} you must invoke either {@link #uri(String, Object...)}
		 * or {@link #uri(String, Map)} &mdash; for example, {@code uri(myUri.toString())}.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(URI uri);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * <p>If a {@link UriBuilderFactory} was configured for the client (for example,
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(String uri, @Nullable Object... uriVariables);

		/**
		 * Specify the URI for the request using a URI template and URI variables.
		 * <p>If a {@link UriBuilderFactory} was configured for the client (for example,
		 * with a base URI) it will be used to expand the URI template.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(String uri, Map<String, ? extends @Nullable Object> uriVariables);

		/**
		 * Build the URI for the request with a {@link UriBuilder} obtained
		 * through the {@link UriBuilderFactory} configured for this client.
		 * @return spec to add headers or perform the exchange
		 */
		S uri(Function<UriBuilder, URI> uriFunction);
	}


	/**
	 * Specification for adding request headers and performing an exchange.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface RequestHeadersSpec<S extends RequestHeadersSpec<S>> {

		/**
		 * Set the list of acceptable {@linkplain MediaType media types}, as
		 * specified by the {@code Accept} header.
		 * @param acceptableMediaTypes the acceptable media types
		 * @return this spec for further declaration of the request
		 */
		S accept(MediaType... acceptableMediaTypes);

		/**
		 * Set the list of acceptable {@linkplain Charset charsets}, as specified
		 * by the {@code Accept-Charset} header.
		 * @param acceptableCharsets the acceptable charsets
		 * @return this spec for further declaration of the request
		 */
		S acceptCharset(Charset... acceptableCharsets);

		/**
		 * Add a cookie with the given name and value.
		 * @param name the cookie name
		 * @param value the cookie value
		 * @return this spec for further declaration of the request
		 */
		S cookie(String name, String value);

		/**
		 * Manipulate this request's cookies with the given consumer. The
		 * map provided to the consumer is ""live"", so that the consumer can be used to
		 * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,
		 * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other
		 * {@link MultiValueMap} methods.
		 * @param cookiesConsumer a function that consumes the cookies map
		 * @return this spec for further declaration of the request
		 */
		S cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer);

		/**
		 * Set the value of the {@code If-Modified-Since} header.
		 * <p>The date should be specified as the number of milliseconds since
		 * January 1, 1970 GMT.
		 * @param ifModifiedSince the new value of the header
		 * @return this spec for further declaration of the request
		 */
		S ifModifiedSince(ZonedDateTime ifModifiedSince);

		/**
		 * Set the values of the {@code If-None-Match} header.
		 * @param ifNoneMatches the new value of the header
		 * @return this spec for further declaration of the request
		 */
		S ifNoneMatch(String... ifNoneMatches);

		/**
		 * Add the given, single header value under the given name.
		 * @param headerName  the header name
		 * @param headerValues the header value(s)
		 * @return this spec for further declaration of the request
		 */
		S header(String headerName, String... headerValues);

		/**
		 * Manipulate the request's headers with the given consumer. The
		 * headers provided to the consumer are ""live"", so that the consumer can be used to
		 * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,
		 * {@linkplain HttpHeaders#remove(String) remove} values, or use any of the other
		 * {@link HttpHeaders} methods.
		 * @param headersConsumer a function that consumes the {@code HttpHeaders}
		 * @return this spec for further declaration of the request
		 */
		S headers(Consumer<HttpHeaders> headersConsumer);

		/**
		 * Set an API version for the request. The version is inserted into the
		 * request by the {@linkplain Builder#apiVersionInserter(ApiVersionInserter)
		 * configured} {@code ApiVersionInserter}.
		 * @param version the API version of the request; this can be a String or
		 * some Object that can be formatted by the inserter &mdash; for example,
		 * through an {@link ApiVersionFormatter}
		 * @return this spec for further declaration of the request
		 */
		S apiVersion(Object version);

		/**
		 * Set the attribute with the given name to the given value.
		 * @param name the name of the attribute to add
		 * @param value the value of the attribute to add
		 * @return this spec for further declaration of the request
		 */
		S attribute(String name, Object value);

		/**
		 * Manipulate the request attributes with the given consumer. The attributes provided to
		 * the consumer are ""live"", so that the consumer can be used to inspect attributes,
		 * remove attributes, or use any of the other map-provided methods.
		 * @param attributesConsumer a function that consumes the attributes
		 * @return this spec for further declaration of the request
		 */
		S attributes(Consumer<Map<String, Object>> attributesConsumer);

		/**
		 * Perform the exchange without a request body.
		 * @return a spec for decoding the response
		 */
		ResponseSpec exchange();
	}


	/**
	 * Specification for providing the body of a request.
	 */
	interface RequestBodySpec extends RequestHeadersSpec<RequestBodySpec> {

		/**
		 * Set the length of the body in bytes, as specified by the
		 * {@code Content-Length} header.
		 * @param contentLength the content length
		 * @return this spec for further declaration of the request
		 * @see HttpHeaders#setContentLength(long)
		 */
		RequestBodySpec contentLength(long contentLength);

		/**
		 * Set the {@linkplain MediaType media type} of the body, as specified
		 * by the {@code Content-Type} header.
		 * @param contentType the content type
		 * @return this spec for further declaration of the request
		 * @see HttpHeaders#setContentType(MediaType)
		 */
		RequestBodySpec contentType(MediaType contentType);

		/**
		 * Set the body to the given {@code Object} value. This method invokes the
		 * {@link RestClient.RequestBodySpec#body(Object)} (Object)
		 * bodyValue} method on the underlying {@code RestClient}.
		 * @param body the value to write to the request body
		 * @return a spec for further declaration of the request
		 */
		RequestHeadersSpec<?> body(Object body);
	}


	/**
	 * Specification for providing request headers and the URI of a request.
	 *
	 * @param <S> a self reference to the spec type
	 */
	interface RequestHeadersUriSpec<S extends RequestHeadersSpec<S>> extends UriSpec<S>, RequestHeadersSpec<S> {
	}


	/**
	 * Specification for providing the body and the URI of a request.
	 */
	interface RequestBodyUriSpec extends RequestBodySpec, RequestHeadersUriSpec<RequestBodySpec> {
	}


	/**
	 * Chained API for applying assertions to a response.
	 */
	interface ResponseSpec {

		/**
		 * Apply multiple assertions to a response with the given
		 * {@linkplain ResponseSpecConsumer consumers}, with the guarantee that
		 * all assertions will be applied even if one or more assertions fails
		 * with an exception.
		 * <p>If a single {@link Error} or {@link RuntimeException} is thrown,
		 * it will be rethrown.
		 * <p>If multiple exceptions are thrown, this method will throw an
		 * {@link AssertionError} whose error message is a summary of all the
		 * exceptions. In addition, each exception will be added as a
		 * {@linkplain Throwable#addSuppressed(Throwable) suppressed exception} to
		 * the {@code AssertionError}.
		 * <p>This feature is similar to the {@code SoftAssertions} support in
		 * AssertJ and the {@code assertAll()} support in JUnit Jupiter.
		 *
		 * <h4>Example</h4>
		 * <pre class=""code"">
		 * restTestClient.get().uri(""/hello"").exchange()
		 *     .expectAll(
		 *         responseSpec -&gt; responseSpec.expectStatus().isOk(),
		 *         responseSpec -&gt; responseSpec.expectBody(String.class).isEqualTo(""Hello, World!"")
		 *     );
		 * </pre>
		 * @param consumers the list of {@code ResponseSpec} consumers
		 */
		ResponseSpec expectAll(ResponseSpecConsumer... consumers);

		/**
		 * Assertions on the response status.
		 */
		StatusAssertions expectStatus();

		/**
		 * Assertions on the headers of the response.
		 */
		HeaderAssertions expectHeader();

		/**
		 * Assertions on the cookies of the response.
		 */
		CookieAssertions expectCookie();

		/**
		 * Consume and decode the response body to a single object of type
		 * {@code <B>} and then apply assertions.
		 * @param bodyType the expected body type
		 */
		<B> BodySpec<B, ?> expectBody(Class<B> bodyType);

		/**
		 * Alternative to {@link #expectBody(Class)} that accepts information
		 * about a target type with generics.
		 */
		<B> BodySpec<B, ?> expectBody(ParameterizedTypeReference<B> bodyType);

		/**
		 * Consume and decode the response body to {@code byte[]} and then apply
		 * assertions on the raw content (for example, isEmpty, JSONPath, etc.).
		 */
		BodyContentSpec expectBody();

		/**
		 * Exit the chained flow in order to consume the response body externally.
		 */
		<T> EntityExchangeResult<T> returnResult(Class<T> elementClass);

		/**
		 * Alternative to {@link #returnResult(Class)} that accepts information
		 * about a target type with generics.
		 */
		<T> EntityExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementTypeRef);

		/**
		 * {@link Consumer} of a {@link ResponseSpec}.
		 * @see ResponseSpec#expectAll(ResponseSpecConsumer...)
		 */
		@FunctionalInterface
		interface ResponseSpecConsumer extends Consumer<ResponseSpec> {
		}
	}


	/**
	 * Spec for expectations on the response body decoded to a single Object.
	 *
	 * @param <S> a self reference to the spec type
	 * @param <B> the body type
	 */
	interface BodySpec<B, S extends BodySpec<B, S>> {

		/**
		 * Assert the extracted body is equal to the given value.
		 */
		<T extends S> T isEqualTo(@Nullable B expected);

		/**
		 * Assert the extracted body with a {@link Matcher}.
		 */
		<T extends S> T value(Matcher<? super @Nullable B> matcher);

		/**
		 * Transform the extracted the body with a function, for example, extracting a
		 * property, and assert the mapped value with a {@link Matcher}.
		 */
		<T extends S, R> T value(Function<@Nullable B, @Nullable R> bodyMapper, Matcher<? super @Nullable R> matcher);

		/**
		 * Assert the extracted body with a {@link Consumer}.
		 */
		<T extends S> T value(Consumer<@Nullable B> consumer);

		/**
		 * Assert the exchange result with the given {@link Consumer}.
		 */
		<T extends S> T consumeWith(Consumer<EntityExchangeResult<B>> consumer);

		/**
		 * Exit the chained API and return an {@code EntityExchangeResult} with the
		 * decoded response content.
		 */
		EntityExchangeResult<B> returnResult();
	}


	/**
	 * Spec for expectations on the response body content.
	 */
	interface BodyContentSpec {

		/**
		 * Assert the response body is empty and return the exchange result.
		 */
		EntityExchangeResult<Void> isEmpty();

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison verifying that they contain the same attribute-value pairs
		 * regardless of formatting with <em>lenient</em> checking (extensible
		 * and non-strict array ordering).
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @see #json(String, JsonCompareMode)
		 */
		default BodyContentSpec json(String expectedJson) {
			return json(expectedJson, JsonCompareMode.LENIENT);
		}

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison using the given {@linkplain JsonCompareMode mode}. If the
		 * comparison failed, throws an {@link AssertionError} with the message
		 * of the {@link JsonComparison}.
		 * <p>Use of this method requires the
		 * <a href=""https://jsonassert.skyscreamer.org/"">JSONassert</a> library
		 * to be on the classpath.
		 * @param expectedJson the expected JSON content
		 * @param compareMode the compare mode
		 * @see #json(String)
		 */
		BodyContentSpec json(String expectedJson, JsonCompareMode compareMode);

		/**
		 * Parse the expected and actual response content as JSON and perform a
		 * comparison using the given {@link JsonComparator}. If the comparison
		 * failed, throws an {@link AssertionError} with the message  of the
		 * {@link JsonComparison}.
		 * @param expectedJson the expected JSON content
		 * @param comparator the comparator to use
		 */
		BodyContentSpec json(String expectedJson, JsonComparator comparator);

		/**
		 * Parse expected and actual response content as XML and assert that
		 * the two are ""similar"", i.e. they contain the same elements and
		 * attributes regardless of order.
		 * <p>Use of this method requires the
		 * <a href=""https://github.com/xmlunit/xmlunit"">XMLUnit</a> library on
		 * the classpath.
		 * @param expectedXml the expected XML content.
		 * @see org.springframework.test.util.XmlExpectationsHelper#assertXmlEqual(String, String)
		 */
		BodyContentSpec xml(String expectedXml);

		/**
		 * Access to response body assertions using a
		 * <a href=""https://github.com/jayway/JsonPath"">JsonPath</a> expression
		 * to inspect a specific subset of the body.
		 * @param expression the JsonPath expression
		 */
		JsonPathAssertions jsonPath(String expression);

		/**
		 * Access to response body assertions using an XPath expression to
		 * inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param args arguments to parameterize the expression
		 * @see #xpath(String, Map, Object...)
		 */
		default XpathAssertions xpath(String expression, Object... args) {
			return xpath(expression, null, args);
		}

		/**
		 * Access to response body assertions with specific namespaces using an
		 * XPath expression to inspect a specific subset of the body.
		 * <p>The XPath expression can be a parameterized string using
		 * formatting specifiers as defined in {@link String#format}.
		 * @param expression the XPath expression
		 * @param namespaces the namespaces to use
		 * @param args arguments to parameterize the expression
		 */
		XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args);

		/**
		 * Assert the response body content with the given {@link Consumer}.
		 * @param consumer the consumer for the response body; the input
		 * {@code byte[]} may be {@code null} if there was no response body.
		 */
		BodyContentSpec consumeWith(Consumer<EntityExchangeResult<byte[]>> consumer);

		/**
		 * Exit the chained API and return an {@code ExchangeResult} with the
		 * raw response content.
		 */
		EntityExchangeResult<byte[]> returnResult();
	}

}
"
3a4315bf16c1f69bbe099f51c73f3d19facf0731,"Keep mainThreadPrefix exposed until background init threads finished

Closes gh-35409",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory.support;

import java.io.IOException;
import java.io.NotSerializableException;
import java.io.ObjectInputStream;
import java.io.ObjectStreamException;
import java.io.Serial;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.ref.Reference;
import java.lang.ref.WeakReference;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executor;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Stream;

import jakarta.inject.Provider;

import org.springframework.beans.BeansException;
import org.springframework.beans.TypeConverter;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.beans.factory.BeanCurrentlyInCreationException;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.BeanNotOfRequiredTypeException;
import org.springframework.beans.factory.CannotLoadBeanClassException;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InjectionPoint;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;
import org.springframework.beans.factory.ObjectFactory;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.beans.factory.SmartFactoryBean;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.config.DependencyDescriptor;
import org.springframework.beans.factory.config.NamedBeanHolder;
import org.springframework.core.NamedThreadLocal;
import org.springframework.core.OrderComparator;
import org.springframework.core.Ordered;
import org.springframework.core.ResolvableType;
import org.springframework.core.SpringProperties;
import org.springframework.core.annotation.MergedAnnotation;
import org.springframework.core.annotation.MergedAnnotations;
import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;
import org.springframework.core.log.LogMessage;
import org.springframework.core.metrics.StartupStep;
import org.springframework.lang.Contract;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.CollectionUtils;
import org.springframework.util.CompositeIterator;
import org.springframework.util.ObjectUtils;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

/**
 * Spring's default implementation of the {@link ConfigurableListableBeanFactory}
 * and {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory
 * based on bean definition metadata, extensible through post-processors.
 *
 * <p>Typical usage is registering all bean definitions first (possibly read
 * from a bean definition file), before accessing beans. Bean lookup by name
 * is therefore an inexpensive operation in a local bean definition table,
 * operating on pre-resolved bean definition metadata objects.
 *
 * <p>Note that readers for specific bean definition formats are typically
 * implemented separately rather than as bean factory subclasses: see for example
 * {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader}.
 *
 * <p>For an alternative implementation of the
 * {@link org.springframework.beans.factory.ListableBeanFactory} interface,
 * have a look at {@link StaticListableBeanFactory}, which manages existing
 * bean instances rather than creating new ones based on bean definitions.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @author Costin Leau
 * @author Chris Beams
 * @author Phillip Webb
 * @author Stephane Nicoll
 * @author Sebastien Deleuze
 * @since 16 April 2001
 * @see #registerBeanDefinition
 * @see #addBeanPostProcessor
 * @see #getBean
 * @see #resolveDependency
 */
@SuppressWarnings(""serial"")
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
		implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {

	/**
	 * System property that instructs Spring to enforce strict locking during bean creation,
	 * rather than the mix of strict and lenient locking that 6.2 applies by default. Setting
	 * this flag to ""true"" restores 6.1.x style locking in the entire pre-instantiation phase.
	 * <p>By default, the factory infers strict locking from the encountered thread names:
	 * If additional threads have names that match the thread prefix of the main bootstrap thread,
	 * they are considered external (multiple external bootstrap threads calling into the factory)
	 * and therefore have strict locking applied to them. This inference can be turned off through
	 * explicitly setting this flag to ""false"" rather than leaving it unspecified.
	 * @since 6.2.6
	 * @see #preInstantiateSingletons()
	 */
	public static final String STRICT_LOCKING_PROPERTY_NAME = ""spring.locking.strict"";

	@Nullable
	private static Class<?> jakartaInjectProviderClass;

	static {
		try {
			jakartaInjectProviderClass =
					ClassUtils.forName(""jakarta.inject.Provider"", DefaultListableBeanFactory.class.getClassLoader());
		}
		catch (ClassNotFoundException ex) {
			// JSR-330 API not available - Provider interface simply not supported then.
			jakartaInjectProviderClass = null;
		}
	}


	/** Map from serialized id to factory instance. */
	private static final Map<String, Reference<DefaultListableBeanFactory>> serializableFactories =
			new ConcurrentHashMap<>(8);

	/** Whether strict locking is enforced or relaxed in this factory. */
	@Nullable
	private final Boolean strictLocking = SpringProperties.checkFlag(STRICT_LOCKING_PROPERTY_NAME);

	/** Optional id for this factory, for serialization purposes. */
	@Nullable
	private String serializationId;

	/** Whether to allow re-registration of a different definition with the same name. */
	@Nullable
	private Boolean allowBeanDefinitionOverriding;

	/** Whether to allow eager class loading even for lazy-init beans. */
	private boolean allowEagerClassLoading = true;

	@Nullable
	private Executor bootstrapExecutor;

	/** Optional OrderComparator for dependency Lists and arrays. */
	@Nullable
	private Comparator<Object> dependencyComparator;

	/** Resolver to use for checking if a bean definition is an autowire candidate. */
	private AutowireCandidateResolver autowireCandidateResolver = SimpleAutowireCandidateResolver.INSTANCE;

	/** Map from dependency type to corresponding autowired value. */
	private final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<>(16);

	/** Map of bean definition objects, keyed by bean name. */
	private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

	/** Map from bean name to merged BeanDefinitionHolder. */
	private final Map<String, BeanDefinitionHolder> mergedBeanDefinitionHolders = new ConcurrentHashMap<>(256);

	/** Map of bean definition names with a primary marker plus corresponding type. */
	private final Map<String, Class<?>> primaryBeanNamesWithType = new ConcurrentHashMap<>(16);

	/** Map of singleton and non-singleton bean names, keyed by dependency type. */
	private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<>(64);

	/** Map of singleton-only bean names, keyed by dependency type. */
	private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<>(64);

	/** List of bean definition names, in registration order. */
	private volatile List<String> beanDefinitionNames = new ArrayList<>(256);

	/** List of names of manually registered singletons, in registration order. */
	private volatile Set<String> manualSingletonNames = new LinkedHashSet<>(16);

	/** Cached array of bean definition names in case of frozen configuration. */
	@Nullable
	private volatile String[] frozenBeanDefinitionNames;

	/** Whether bean definition metadata may be cached for all beans. */
	private volatile boolean configurationFrozen;

	/** Name prefix of main thread: only set during pre-instantiation phase. */
	@Nullable
	private volatile String mainThreadPrefix;

	private final NamedThreadLocal<PreInstantiation> preInstantiationThread =
			new NamedThreadLocal<>(""Pre-instantiation thread marker"");


	/**
	 * Create a new DefaultListableBeanFactory.
	 */
	public DefaultListableBeanFactory() {
		super();
	}

	/**
	 * Create a new DefaultListableBeanFactory with the given parent.
	 * @param parentBeanFactory the parent BeanFactory
	 */
	public DefaultListableBeanFactory(@Nullable BeanFactory parentBeanFactory) {
		super(parentBeanFactory);
	}


	/**
	 * Specify an id for serialization purposes, allowing this BeanFactory to be
	 * deserialized from this id back into the BeanFactory object, if needed.
	 */
	public void setSerializationId(@Nullable String serializationId) {
		if (serializationId != null) {
			serializableFactories.put(serializationId, new WeakReference<>(this));
		}
		else if (this.serializationId != null) {
			serializableFactories.remove(this.serializationId);
		}
		this.serializationId = serializationId;
	}

	/**
	 * Return an id for serialization purposes, if specified, allowing this BeanFactory
	 * to be deserialized from this id back into the BeanFactory object, if needed.
	 * @since 4.1.2
	 */
	@Nullable
	public String getSerializationId() {
		return this.serializationId;
	}

	/**
	 * Set whether it should be allowed to override bean definitions by registering
	 * a different definition with the same name, automatically replacing the former.
	 * If not, an exception will be thrown. This also applies to overriding aliases.
	 * <p>Default is ""true"".
	 * @see #registerBeanDefinition
	 */
	public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {
		this.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;
	}

	/**
	 * Return whether it should be allowed to override bean definitions by registering
	 * a different definition with the same name, automatically replacing the former.
	 * @since 4.1.2
	 */
	public boolean isAllowBeanDefinitionOverriding() {
		return !Boolean.FALSE.equals(this.allowBeanDefinitionOverriding);
	}

	/**
	 * Set whether the factory is allowed to eagerly load bean classes
	 * even for bean definitions that are marked as ""lazy-init"".
	 * <p>Default is ""true"". Turn this flag off to suppress class loading
	 * for lazy-init beans unless such a bean is explicitly requested.
	 * In particular, by-type lookups will then simply ignore bean definitions
	 * without resolved class name, instead of loading the bean classes on
	 * demand just to perform a type check.
	 * @see AbstractBeanDefinition#setLazyInit
	 */
	public void setAllowEagerClassLoading(boolean allowEagerClassLoading) {
		this.allowEagerClassLoading = allowEagerClassLoading;
	}

	/**
	 * Return whether the factory is allowed to eagerly load bean classes
	 * even for bean definitions that are marked as ""lazy-init"".
	 * @since 4.1.2
	 */
	public boolean isAllowEagerClassLoading() {
		return this.allowEagerClassLoading;
	}

	@Override
	public void setBootstrapExecutor(@Nullable Executor bootstrapExecutor) {
		this.bootstrapExecutor = bootstrapExecutor;
	}

	@Override
	@Nullable
	public Executor getBootstrapExecutor() {
		return this.bootstrapExecutor;
	}

	/**
	 * Set a {@link java.util.Comparator} for dependency Lists and arrays.
	 * @since 4.0
	 * @see org.springframework.core.OrderComparator
	 * @see org.springframework.core.annotation.AnnotationAwareOrderComparator
	 */
	public void setDependencyComparator(@Nullable Comparator<Object> dependencyComparator) {
		this.dependencyComparator = dependencyComparator;
	}

	/**
	 * Return the dependency comparator for this BeanFactory (may be {@code null}).
	 * @since 4.0
	 */
	@Nullable
	public Comparator<Object> getDependencyComparator() {
		return this.dependencyComparator;
	}

	/**
	 * Set a custom autowire candidate resolver for this BeanFactory to use
	 * when deciding whether a bean definition should be considered as a
	 * candidate for autowiring.
	 */
	public void setAutowireCandidateResolver(AutowireCandidateResolver autowireCandidateResolver) {
		Assert.notNull(autowireCandidateResolver, ""AutowireCandidateResolver must not be null"");
		if (autowireCandidateResolver instanceof BeanFactoryAware beanFactoryAware) {
			beanFactoryAware.setBeanFactory(this);
		}
		this.autowireCandidateResolver = autowireCandidateResolver;
	}

	/**
	 * Return the autowire candidate resolver for this BeanFactory (never {@code null}).
	 */
	public AutowireCandidateResolver getAutowireCandidateResolver() {
		return this.autowireCandidateResolver;
	}


	@Override
	public void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {
		super.copyConfigurationFrom(otherFactory);
		if (otherFactory instanceof DefaultListableBeanFactory otherListableFactory) {
			this.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;
			this.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;
			this.bootstrapExecutor = otherListableFactory.bootstrapExecutor;
			this.dependencyComparator = otherListableFactory.dependencyComparator;
			// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware
			setAutowireCandidateResolver(otherListableFactory.getAutowireCandidateResolver().cloneIfNecessary());
			// Make resolvable dependencies (for example, ResourceLoader) available here as well
			this.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);
		}
	}


	//---------------------------------------------------------------------
	// Implementation of remaining BeanFactory methods
	//---------------------------------------------------------------------

	@Override
	public <T> T getBean(Class<T> requiredType) throws BeansException {
		return getBean(requiredType, (Object[]) null);
	}

	@SuppressWarnings(""unchecked"")
	@Override
	public <T> T getBean(Class<T> requiredType, @Nullable Object... args) throws BeansException {
		Assert.notNull(requiredType, ""Required type must not be null"");
		Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);
		if (resolved == null) {
			throw new NoSuchBeanDefinitionException(requiredType);
		}
		return (T) resolved;
	}

	@Override
	public <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType) {
		Assert.notNull(requiredType, ""Required type must not be null"");
		return getBeanProvider(ResolvableType.forRawClass(requiredType), true);
	}

	@Override
	public <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {
		return getBeanProvider(requiredType, true);
	}


	//---------------------------------------------------------------------
	// Implementation of ListableBeanFactory interface
	//---------------------------------------------------------------------

	@Override
	public boolean containsBeanDefinition(String beanName) {
		Assert.notNull(beanName, ""Bean name must not be null"");
		return this.beanDefinitionMap.containsKey(beanName);
	}

	@Override
	public int getBeanDefinitionCount() {
		return this.beanDefinitionMap.size();
	}

	@Override
	public String[] getBeanDefinitionNames() {
		String[] frozenNames = this.frozenBeanDefinitionNames;
		if (frozenNames != null) {
			return frozenNames.clone();
		}
		else {
			return StringUtils.toStringArray(this.beanDefinitionNames);
		}
	}

	@Override
	public <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType, boolean allowEagerInit) {
		Assert.notNull(requiredType, ""Required type must not be null"");
		return getBeanProvider(ResolvableType.forRawClass(requiredType), allowEagerInit);
	}

	@Override
	public <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {
		return new BeanObjectProvider<>() {
			@Override
			public T getObject() throws BeansException {
				T resolved = resolveBean(requiredType, null, false);
				if (resolved == null) {
					throw new NoSuchBeanDefinitionException(requiredType);
				}
				return resolved;
			}
			@Override
			public T getObject(Object... args) throws BeansException {
				T resolved = resolveBean(requiredType, args, false);
				if (resolved == null) {
					throw new NoSuchBeanDefinitionException(requiredType);
				}
				return resolved;
			}
			@Override
			@Nullable
			public T getIfAvailable() throws BeansException {
				try {
					return resolveBean(requiredType, null, false);
				}
				catch (ScopeNotActiveException ex) {
					// Ignore resolved bean in non-active scope
					return null;
				}
			}
			@Override
			public void ifAvailable(Consumer<T> dependencyConsumer) throws BeansException {
				T dependency = getIfAvailable();
				if (dependency != null) {
					try {
						dependencyConsumer.accept(dependency);
					}
					catch (ScopeNotActiveException ex) {
						// Ignore resolved bean in non-active scope, even on scoped proxy invocation
					}
				}
			}
			@Override
			@Nullable
			public T getIfUnique() throws BeansException {
				try {
					return resolveBean(requiredType, null, true);
				}
				catch (ScopeNotActiveException ex) {
					// Ignore resolved bean in non-active scope
					return null;
				}
			}
			@Override
			public void ifUnique(Consumer<T> dependencyConsumer) throws BeansException {
				T dependency = getIfUnique();
				if (dependency != null) {
					try {
						dependencyConsumer.accept(dependency);
					}
					catch (ScopeNotActiveException ex) {
						// Ignore resolved bean in non-active scope, even on scoped proxy invocation
					}
				}
			}
			@SuppressWarnings(""unchecked"")
			@Override
			public Stream<T> stream() {
				return Arrays.stream(beanNamesForStream(requiredType, true, allowEagerInit))
						.map(name -> (T) getBean(name))
						.filter(bean -> !(bean instanceof NullBean));
			}
			@SuppressWarnings(""unchecked"")
			@Override
			public Stream<T> orderedStream() {
				String[] beanNames = beanNamesForStream(requiredType, true, allowEagerInit);
				if (beanNames.length == 0) {
					return Stream.empty();
				}
				Map<String, T> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);
				for (String beanName : beanNames) {
					Object beanInstance = getBean(beanName);
					if (!(beanInstance instanceof NullBean)) {
						matchingBeans.put(beanName, (T) beanInstance);
					}
				}
				Stream<T> stream = matchingBeans.values().stream();
				return stream.sorted(adaptOrderComparator(matchingBeans));
			}
			@SuppressWarnings(""unchecked"")
			@Override
			public Stream<T> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {
				return Arrays.stream(beanNamesForStream(requiredType, includeNonSingletons, allowEagerInit))
						.filter(name -> customFilter.test(getType(name)))
						.map(name -> (T) getBean(name))
						.filter(bean -> !(bean instanceof NullBean));
			}
			@SuppressWarnings(""unchecked"")
			@Override
			public Stream<T> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {
				String[] beanNames = beanNamesForStream(requiredType, includeNonSingletons, allowEagerInit);
				if (beanNames.length == 0) {
					return Stream.empty();
				}
				Map<String, T> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);
				for (String beanName : beanNames) {
					if (customFilter.test(getType(beanName))) {
						Object beanInstance = getBean(beanName);
						if (!(beanInstance instanceof NullBean)) {
							matchingBeans.put(beanName, (T) beanInstance);
						}
					}
				}
				return matchingBeans.values().stream().sorted(adaptOrderComparator(matchingBeans));
			}
		};
	}

	@Nullable
	private <T> T resolveBean(ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) {
		NamedBeanHolder<T> namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);
		if (namedBean != null) {
			return namedBean.getBeanInstance();
		}
		BeanFactory parent = getParentBeanFactory();
		if (parent instanceof DefaultListableBeanFactory dlbf) {
			return dlbf.resolveBean(requiredType, args, nonUniqueAsNull);
		}
		else if (parent != null) {
			ObjectProvider<T> parentProvider = parent.getBeanProvider(requiredType);
			if (args != null) {
				return parentProvider.getObject(args);
			}
			else {
				return (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());
			}
		}
		return null;
	}

	private String[] beanNamesForStream(ResolvableType requiredType, boolean includeNonSingletons, boolean allowEagerInit) {
		return BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this, requiredType, includeNonSingletons, allowEagerInit);
	}

	@Override
	public String[] getBeanNamesForType(ResolvableType type) {
		return getBeanNamesForType(type, true, true);
	}

	@Override
	public String[] getBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {
		Class<?> resolved = type.resolve();
		if (resolved != null && !type.hasGenerics()) {
			return getBeanNamesForType(resolved, includeNonSingletons, allowEagerInit);
		}
		else {
			return doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);
		}
	}

	@Override
	public String[] getBeanNamesForType(@Nullable Class<?> type) {
		return getBeanNamesForType(type, true, true);
	}

	@Override
	public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {
		if (!isConfigurationFrozen() || type == null || !allowEagerInit) {
			return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);
		}
		Map<Class<?>, String[]> cache =
				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);
		String[] resolvedBeanNames = cache.get(type);
		if (resolvedBeanNames != null) {
			return resolvedBeanNames;
		}
		resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);
		if (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {
			cache.put(type, resolvedBeanNames);
		}
		return resolvedBeanNames;
	}

	private String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {
		List<String> result = new ArrayList<>();

		// Check all bean definitions.
		for (String beanName : this.beanDefinitionNames) {
			// Only consider bean as eligible if the bean name is not defined as alias for some other bean.
			if (!isAlias(beanName)) {
				try {
					RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
					// Only check bean definition if it is complete.
					if (!mbd.isAbstract() && (allowEagerInit ||
							(mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &&
									!requiresEagerInitForType(mbd.getFactoryBeanName()))) {
						boolean isFactoryBean = isFactoryBean(beanName, mbd);
						BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();
						boolean matchFound = false;
						boolean allowFactoryBeanInit = (allowEagerInit || containsSingleton(beanName));
						boolean isNonLazyDecorated = (dbd != null && !mbd.isLazyInit());
						if (!isFactoryBean) {
							if (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {
								matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);
							}
						}
						else {
							if (includeNonSingletons || isNonLazyDecorated) {
								matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);
							}
							else if (allowFactoryBeanInit) {
								// Type check before singleton check, avoiding FactoryBean instantiation
								// for early FactoryBean.isSingleton() calls on non-matching beans.
								matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit) &&
										isSingleton(beanName, mbd, dbd);
							}
							if (!matchFound) {
								// In case of FactoryBean, try to match FactoryBean instance itself next.
								beanName = FACTORY_BEAN_PREFIX + beanName;
								if (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {
									matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);
								}
							}
						}
						if (matchFound) {
							result.add(beanName);
						}
					}
				}
				catch (CannotLoadBeanClassException | BeanDefinitionStoreException ex) {
					if (allowEagerInit) {
						throw ex;
					}
					// Probably a placeholder: let's ignore it for type matching purposes.
					LogMessage message = (ex instanceof CannotLoadBeanClassException ?
							LogMessage.format(""Ignoring bean class loading failure for bean '%s'"", beanName) :
							LogMessage.format(""Ignoring unresolvable metadata in bean definition '%s'"", beanName));
					logger.trace(message, ex);
					// Register exception, in case the bean was accidentally unresolvable.
					onSuppressedException(ex);
				}
				catch (NoSuchBeanDefinitionException ex) {
					// Bean definition got removed while we were iterating -> ignore.
				}
			}
		}

		// Check manually registered singletons too.
		for (String beanName : this.manualSingletonNames) {
			try {
				// In case of FactoryBean, match object created by FactoryBean.
				if (isFactoryBean(beanName)) {
					if ((includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type)) {
						result.add(beanName);
						// Match found for this bean: do not match FactoryBean itself anymore.
						continue;
					}
					// In case of FactoryBean, try to match FactoryBean itself next.
					beanName = FACTORY_BEAN_PREFIX + beanName;
				}
				// Match raw bean instance (might be raw FactoryBean).
				if (isTypeMatch(beanName, type)) {
					result.add(beanName);
				}
			}
			catch (NoSuchBeanDefinitionException ex) {
				// Shouldn't happen - probably a result of circular reference resolution...
				logger.trace(LogMessage.format(
						""Failed to check manually registered singleton with name '%s'"", beanName), ex);
			}
		}

		return StringUtils.toStringArray(result);
	}

	private boolean isSingleton(String beanName, RootBeanDefinition mbd, @Nullable BeanDefinitionHolder dbd) {
		return (dbd != null ? mbd.isSingleton() : isSingleton(beanName));
	}

	/**
	 * Check whether the specified bean would need to be eagerly initialized
	 * in order to determine its type.
	 * @param factoryBeanName a factory-bean reference that the bean definition
	 * defines a factory method for
	 * @return whether eager initialization is necessary
	 */
	private boolean requiresEagerInitForType(@Nullable String factoryBeanName) {
		return (factoryBeanName != null && isFactoryBean(factoryBeanName) && !containsSingleton(factoryBeanName));
	}

	@Override
	public <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException {
		return getBeansOfType(type, true, true);
	}

	@Override
	@SuppressWarnings(""unchecked"")
	public <T> Map<String, T> getBeansOfType(
			@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException {

		String[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);
		Map<String, T> result = CollectionUtils.newLinkedHashMap(beanNames.length);
		for (String beanName : beanNames) {
			try {
				Object beanInstance = getBean(beanName);
				if (!(beanInstance instanceof NullBean)) {
					result.put(beanName, (T) beanInstance);
				}
			}
			catch (BeanCreationException ex) {
				Throwable rootCause = ex.getMostSpecificCause();
				if (rootCause instanceof BeanCurrentlyInCreationException bce) {
					String exBeanName = bce.getBeanName();
					if (exBeanName != null && isCurrentlyInCreation(exBeanName)) {
						if (logger.isTraceEnabled()) {
							logger.trace(""Ignoring match to currently created bean '"" + exBeanName + ""': "" +
									ex.getMessage());
						}
						onSuppressedException(ex);
						// Ignore: indicates a circular reference when autowiring constructors.
						// We want to find matches other than the currently created bean itself.
						continue;
					}
				}
				throw ex;
			}
		}
		return result;
	}

	@Override
	public String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType) {
		List<String> result = new ArrayList<>();
		for (String beanName : this.beanDefinitionNames) {
			BeanDefinition bd = this.beanDefinitionMap.get(beanName);
			if (bd != null && !bd.isAbstract() && findAnnotationOnBean(beanName, annotationType) != null) {
				result.add(beanName);
			}
		}
		for (String beanName : this.manualSingletonNames) {
			if (!result.contains(beanName) && findAnnotationOnBean(beanName, annotationType) != null) {
				result.add(beanName);
			}
		}
		return StringUtils.toStringArray(result);
	}

	@Override
	public Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) {
		String[] beanNames = getBeanNamesForAnnotation(annotationType);
		Map<String, Object> result = CollectionUtils.newLinkedHashMap(beanNames.length);
		for (String beanName : beanNames) {
			Object beanInstance = getBean(beanName);
			if (!(beanInstance instanceof NullBean)) {
				result.put(beanName, beanInstance);
			}
		}
		return result;
	}

	@Override
	@Nullable
	public <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)
			throws NoSuchBeanDefinitionException {

		return findAnnotationOnBean(beanName, annotationType, true);
	}

	@Override
	@Nullable
	public <A extends Annotation> A findAnnotationOnBean(
			String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)
			throws NoSuchBeanDefinitionException {

		Class<?> beanType = getType(beanName, allowFactoryBeanInit);
		if (beanType != null) {
			MergedAnnotation<A> annotation =
					MergedAnnotations.from(beanType, SearchStrategy.TYPE_HIERARCHY).get(annotationType);
			if (annotation.isPresent()) {
				return annotation.synthesize();
			}
		}
		if (containsBeanDefinition(beanName)) {
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			// Check raw bean class, for example, in case of a proxy.
			if (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {
				Class<?> beanClass = bd.getBeanClass();
				if (beanClass != beanType) {
					MergedAnnotation<A> annotation =
							MergedAnnotations.from(beanClass, SearchStrategy.TYPE_HIERARCHY).get(annotationType);
					if (annotation.isPresent()) {
						return annotation.synthesize();
					}
				}
			}
			// Check annotations declared on factory method, if any.
			Method factoryMethod = bd.getResolvedFactoryMethod();
			if (factoryMethod != null) {
				MergedAnnotation<A> annotation =
						MergedAnnotations.from(factoryMethod, SearchStrategy.TYPE_HIERARCHY).get(annotationType);
				if (annotation.isPresent()) {
					return annotation.synthesize();
				}
			}
		}
		return null;
	}

	@Override
	public <A extends Annotation> Set<A> findAllAnnotationsOnBean(
			String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)
			throws NoSuchBeanDefinitionException {

		Set<A> annotations = new LinkedHashSet<>();
		Class<?> beanType = getType(beanName, allowFactoryBeanInit);
		if (beanType != null) {
			MergedAnnotations.from(beanType, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)
					.stream(annotationType)
					.filter(MergedAnnotation::isPresent)
					.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));
		}
		if (containsBeanDefinition(beanName)) {
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			// Check raw bean class, for example, in case of a proxy.
			if (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {
				Class<?> beanClass = bd.getBeanClass();
				if (beanClass != beanType) {
					MergedAnnotations.from(beanClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)
							.stream(annotationType)
							.filter(MergedAnnotation::isPresent)
							.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));
				}
			}
			// Check annotations declared on factory method, if any.
			Method factoryMethod = bd.getResolvedFactoryMethod();
			if (factoryMethod != null) {
				MergedAnnotations.from(factoryMethod, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)
						.stream(annotationType)
						.filter(MergedAnnotation::isPresent)
						.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));
			}
		}
		return annotations;
	}


	//---------------------------------------------------------------------
	// Implementation of ConfigurableListableBeanFactory interface
	//---------------------------------------------------------------------

	@Override
	public void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue) {
		Assert.notNull(dependencyType, ""Dependency type must not be null"");
		if (autowiredValue != null) {
			if (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {
				throw new IllegalArgumentException(""Value ["" + autowiredValue +
						""] does not implement specified dependency type ["" + dependencyType.getName() + ""]"");
			}
			this.resolvableDependencies.put(dependencyType, autowiredValue);
		}
	}

	@Override
	public boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)
			throws NoSuchBeanDefinitionException {

		return isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());
	}

	/**
	 * Determine whether the specified bean definition qualifies as an autowire candidate,
	 * to be injected into other beans which declare a dependency of matching type.
	 * @param beanName the name of the bean definition to check
	 * @param descriptor the descriptor of the dependency to resolve
	 * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm
	 * @return whether the bean should be considered as autowire candidate
	 */
	protected boolean isAutowireCandidate(
			String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)
			throws NoSuchBeanDefinitionException {

		String bdName = transformedBeanName(beanName);
		if (containsBeanDefinition(bdName)) {
			return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver);
		}
		else if (containsSingleton(beanName)) {
			return isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);
		}

		BeanFactory parent = getParentBeanFactory();
		if (parent instanceof DefaultListableBeanFactory dlbf) {
			// No bean definition found in this factory -> delegate to parent.
			return dlbf.isAutowireCandidate(beanName, descriptor, resolver);
		}
		else if (parent instanceof ConfigurableListableBeanFactory clbf) {
			// If no DefaultListableBeanFactory, can't pass the resolver along.
			return clbf.isAutowireCandidate(beanName, descriptor);
		}
		else {
			return true;
		}
	}

	/**
	 * Determine whether the specified bean definition qualifies as an autowire candidate,
	 * to be injected into other beans which declare a dependency of matching type.
	 * @param beanName the name of the bean definition to check
	 * @param mbd the merged bean definition to check
	 * @param descriptor the descriptor of the dependency to resolve
	 * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm
	 * @return whether the bean should be considered as autowire candidate
	 */
	protected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,
			DependencyDescriptor descriptor, AutowireCandidateResolver resolver) {

		String bdName = transformedBeanName(beanName);
		resolveBeanClass(mbd, bdName);
		if (mbd.isFactoryMethodUnique && mbd.factoryMethodToIntrospect == null) {
			new ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);
		}
		BeanDefinitionHolder holder = (beanName.equals(bdName) ?
				this.mergedBeanDefinitionHolders.computeIfAbsent(beanName,
						key -> new BeanDefinitionHolder(mbd, beanName, getAliases(bdName))) :
				new BeanDefinitionHolder(mbd, beanName, getAliases(bdName)));
		return resolver.isAutowireCandidate(holder, descriptor);
	}

	@Override
	public BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
		BeanDefinition bd = this.beanDefinitionMap.get(beanName);
		if (bd == null) {
			if (logger.isTraceEnabled()) {
				logger.trace(""No bean named '"" + beanName + ""' found in "" + this);
			}
			throw new NoSuchBeanDefinitionException(beanName);
		}
		return bd;
	}

	@Override
	public Iterator<String> getBeanNamesIterator() {
		CompositeIterator<String> iterator = new CompositeIterator<>();
		iterator.add(this.beanDefinitionNames.iterator());
		iterator.add(this.manualSingletonNames.iterator());
		return iterator;
	}

	@Override
	protected void clearMergedBeanDefinition(String beanName) {
		super.clearMergedBeanDefinition(beanName);
		this.mergedBeanDefinitionHolders.remove(beanName);
	}

	@Override
	public void clearMetadataCache() {
		super.clearMetadataCache();
		this.mergedBeanDefinitionHolders.clear();
		clearByTypeCache();
	}

	@Override
	public void freezeConfiguration() {
		clearMetadataCache();
		this.configurationFrozen = true;
		this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);
	}

	@Override
	public boolean isConfigurationFrozen() {
		return this.configurationFrozen;
	}

	/**
	 * Considers all beans as eligible for metadata caching
	 * if the factory's configuration has been marked as frozen.
	 * @see #freezeConfiguration()
	 */
	@Override
	protected boolean isBeanEligibleForMetadataCaching(String beanName) {
		return (this.configurationFrozen || super.isBeanEligibleForMetadataCaching(beanName));
	}

	@Override
	@Nullable
	protected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)
			throws Exception {

		if (supplier instanceof InstanceSupplier<?> instanceSupplier) {
			return instanceSupplier.get(RegisteredBean.of(this, beanName, mbd));
		}
		return super.obtainInstanceFromSupplier(supplier, beanName, mbd);
	}

	@Override
	protected void cacheMergedBeanDefinition(RootBeanDefinition mbd, String beanName) {
		super.cacheMergedBeanDefinition(mbd, beanName);
		if (mbd.isPrimary()) {
			this.primaryBeanNamesWithType.put(beanName, Void.class);
		}
	}

	@Override
	protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args) {
		super.checkMergedBeanDefinition(mbd, beanName, args);

		if (mbd.isBackgroundInit()) {
			if (this.preInstantiationThread.get() == PreInstantiation.MAIN && getBootstrapExecutor() != null) {
				throw new BeanCurrentlyInCreationException(beanName, ""Bean marked for background "" +
						""initialization but requested in mainline thread - declare ObjectProvider "" +
						""or lazy injection point in dependent mainline beans"");
			}
		}
		else {
			// Bean intended to be initialized in main bootstrap thread.
			if (this.preInstantiationThread.get() == PreInstantiation.BACKGROUND) {
				throw new BeanCurrentlyInCreationException(beanName, ""Bean marked for mainline initialization "" +
						""but requested in background thread - enforce early instantiation in mainline thread "" +
						""through depends-on '"" + beanName + ""' declaration for dependent background beans"");
			}
		}
	}

	@Override
	@Nullable
	protected Boolean isCurrentThreadAllowedToHoldSingletonLock() {
		String mainThreadPrefix = this.mainThreadPrefix;
		if (mainThreadPrefix != null) {
			// We only differentiate in the preInstantiateSingletons phase, using
			// the volatile mainThreadPrefix field as an indicator for that phase.

			PreInstantiation preInstantiation = this.preInstantiationThread.get();
			if (preInstantiation != null) {
				// A Spring-managed bootstrap thread:
				// MAIN is allowed to lock (true) or even forced to lock (null),
				// BACKGROUND is never allowed to lock (false).
				return switch (preInstantiation) {
					case MAIN -> (Boolean.TRUE.equals(this.strictLocking) ? null : true);
					case BACKGROUND -> false;
				};
			}

			// Not a Spring-managed bootstrap thread...
			if (Boolean.FALSE.equals(this.strictLocking)) {
				// Explicitly configured to use lenient locking wherever possible.
				return true;
			}
			else if (this.strictLocking == null) {
				// No explicit locking configuration -> infer appropriate locking.
				if (!getThreadNamePrefix().equals(mainThreadPrefix)) {
					// An unmanaged thread (assumed to be application-internal) with lenient locking,
					// and not part of the same thread pool that provided the main bootstrap thread
					// (excluding scenarios where we are hit by multiple external bootstrap threads).
					return true;
				}
			}
		}

		// Traditional behavior: forced to always hold a full lock.
		return null;
	}

	@Override
	public void preInstantiateSingletons() throws BeansException {
		if (logger.isTraceEnabled()) {
			logger.trace(""Pre-instantiating singletons in "" + this);
		}

		// Iterate over a copy to allow for init methods which in turn register new bean definitions.
		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
		List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

		// Trigger initialization of all non-lazy singleton beans...
		List<CompletableFuture<?>> futures = new ArrayList<>();

		this.preInstantiationThread.set(PreInstantiation.MAIN);
		this.mainThreadPrefix = getThreadNamePrefix();
		try {
			for (String beanName : beanNames) {
				RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				if (!mbd.isAbstract() && mbd.isSingleton()) {
					CompletableFuture<?> future = preInstantiateSingleton(beanName, mbd);
					if (future != null) {
						futures.add(future);
					}
				}
			}
		}
		finally {
			this.mainThreadPrefix = null;
			this.preInstantiationThread.remove();
		}

		if (!futures.isEmpty()) {
			try {
				CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[0])).join();
			}
			catch (CompletionException ex) {
				ReflectionUtils.rethrowRuntimeException(ex.getCause());
			}
		}

		// Trigger post-initialization callback for all applicable beans...
		for (String beanName : beanNames) {
			Object singletonInstance = getSingleton(beanName, false);
			if (singletonInstance instanceof SmartInitializingSingleton smartSingleton) {
				StartupStep smartInitialize = getApplicationStartup().start(""spring.beans.smart-initialize"")
						.tag(""beanName"", beanName);
				smartSingleton.afterSingletonsInstantiated();
				smartInitialize.end();
			}
		}
	}

	@Nullable
	private CompletableFuture<?> preInstantiateSingleton(String beanName, RootBeanDefinition mbd) {
		if (mbd.isBackgroundInit()) {
			Executor executor = getBootstrapExecutor();
			if (executor != null) {
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						getBean(dep);
					}
				}
				CompletableFuture<?> future = CompletableFuture.runAsync(
						() -> instantiateSingletonInBackgroundThread(beanName), executor);
				addSingletonFactory(beanName, () -> {
					try {
						future.join();
					}
					catch (CompletionException ex) {
						ReflectionUtils.rethrowRuntimeException(ex.getCause());
					}
					return future;  // not to be exposed, just to lead to ClassCastException in case of mismatch
				});
				return (!mbd.isLazyInit() ? future : null);
			}
			else if (logger.isInfoEnabled()) {
				logger.info(""Bean '"" + beanName + ""' marked for background initialization "" +
						""without bootstrap executor configured - falling back to mainline initialization"");
			}
		}

		if (!mbd.isLazyInit()) {
			try {
				instantiateSingleton(beanName);
			}
			catch (BeanCurrentlyInCreationException ex) {
				logger.info(""Bean '"" + beanName + ""' marked for pre-instantiation (not lazy-init) "" +
						""but currently initialized by other thread - skipping it in mainline thread"");
			}
		}
		return null;
	}

	private void instantiateSingletonInBackgroundThread(String beanName) {
		this.preInstantiationThread.set(PreInstantiation.BACKGROUND);
		try {
			instantiateSingleton(beanName);
		}
		catch (RuntimeException | Error ex) {
			if (logger.isWarnEnabled()) {
				logger.warn(""Failed to instantiate singleton bean '"" + beanName + ""' in background thread"", ex);
			}
			throw ex;
		}
		finally {
			this.preInstantiationThread.remove();
		}
	}

	private void instantiateSingleton(String beanName) {
		if (isFactoryBean(beanName)) {
			Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
			if (bean instanceof SmartFactoryBean<?> smartFactoryBean && smartFactoryBean.isEagerInit()) {
				getBean(beanName);
			}
		}
		else {
			getBean(beanName);
		}
	}

	private static String getThreadNamePrefix() {
		String name = Thread.currentThread().getName();
		int numberSeparator = name.lastIndexOf('-');
		return (numberSeparator >= 0 ? name.substring(0, numberSeparator) : name);
	}


	//---------------------------------------------------------------------
	// Implementation of BeanDefinitionRegistry interface
	//---------------------------------------------------------------------

	@Override
	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException {

		Assert.hasText(beanName, ""Bean name must not be empty"");
		Assert.notNull(beanDefinition, ""BeanDefinition must not be null"");

		if (beanDefinition instanceof AbstractBeanDefinition abd) {
			try {
				abd.validate();
			}
			catch (BeanDefinitionValidationException ex) {
				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						""Validation of bean definition failed"", ex);
			}
		}

		BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
		if (existingDefinition != null) {
			if (!isBeanDefinitionOverridable(beanName)) {
				throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
			}
			else {
				logBeanDefinitionOverriding(beanName, beanDefinition, existingDefinition);
			}
			this.beanDefinitionMap.put(beanName, beanDefinition);
		}
		else {
			if (isAlias(beanName)) {
				String aliasedName = canonicalName(beanName);
				if (!isBeanDefinitionOverridable(aliasedName)) {
					if (containsBeanDefinition(aliasedName)) {  // alias for existing bean definition
						throw new BeanDefinitionOverrideException(
								beanName, beanDefinition, getBeanDefinition(aliasedName));
					}
					else {  // alias pointing to non-existing bean definition
						throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
								""Cannot register bean definition for bean '"" + beanName +
								""' since there is already an alias for bean '"" + aliasedName + ""' bound."");
					}
				}
				else {
					if (logger.isInfoEnabled()) {
						logger.info(""Removing alias '"" + beanName + ""' for bean '"" + aliasedName +
								""' due to registration of bean definition for bean '"" + beanName + ""': ["" +
								beanDefinition + ""]"");
					}
					removeAlias(beanName);
				}
			}
			if (hasBeanCreationStarted()) {
				// Cannot modify startup-time collection elements anymore (for stable iteration)
				synchronized (this.beanDefinitionMap) {
					this.beanDefinitionMap.put(beanName, beanDefinition);
					List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
					updatedDefinitions.addAll(this.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					this.beanDefinitionNames = updatedDefinitions;
					removeManualSingletonName(beanName);
				}
			}
			else {
				// Still in startup registration phase
				this.beanDefinitionMap.put(beanName, beanDefinition);
				this.beanDefinitionNames.add(beanName);
				removeManualSingletonName(beanName);
			}
			this.frozenBeanDefinitionNames = null;
		}

		if (existingDefinition != null || containsSingleton(beanName)) {
			resetBeanDefinition(beanName);
		}
		else if (isConfigurationFrozen()) {
			clearByTypeCache();
		}

		// Cache a primary marker for the given bean.
		if (beanDefinition.isPrimary()) {
			this.primaryBeanNamesWithType.put(beanName, Void.class);
		}
	}

	private void logBeanDefinitionOverriding(String beanName, BeanDefinition beanDefinition,
			BeanDefinition existingDefinition) {

		boolean explicitBeanOverride = (this.allowBeanDefinitionOverriding != null);
		if (existingDefinition.getRole() < beanDefinition.getRole()) {
			// for example, was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
			if (logger.isInfoEnabled()) {
				logger.info(""Overriding user-defined bean definition for bean '"" + beanName +
						""' with a framework-generated bean definition: replacing ["" +
						existingDefinition + ""] with ["" + beanDefinition + ""]"");
			}
		}
		else if (!beanDefinition.equals(existingDefinition)) {
			if (explicitBeanOverride && logger.isInfoEnabled()) {
				logger.info(""Overriding bean definition for bean '"" + beanName +
						""' with a different definition: replacing ["" + existingDefinition +
						""] with ["" + beanDefinition + ""]"");
			}
			if (logger.isDebugEnabled()) {
				logger.debug(""Overriding bean definition for bean '"" + beanName +
						""' with a different definition: replacing ["" + existingDefinition +
						""] with ["" + beanDefinition + ""]"");
			}
		}
		else {
			if (explicitBeanOverride && logger.isInfoEnabled()) {
				logger.info(""Overriding bean definition for bean '"" + beanName +
						""' with an equivalent definition: replacing ["" + existingDefinition +
						""] with ["" + beanDefinition + ""]"");
			}
			if (logger.isTraceEnabled()) {
				logger.trace(""Overriding bean definition for bean '"" + beanName +
						""' with an equivalent definition: replacing ["" + existingDefinition +
						""] with ["" + beanDefinition + ""]"");
			}
		}
	}

	@Override
	public void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
		Assert.hasText(beanName, ""'beanName' must not be empty"");

		BeanDefinition bd = this.beanDefinitionMap.remove(beanName);
		if (bd == null) {
			if (logger.isTraceEnabled()) {
				logger.trace(""No bean named '"" + beanName + ""' found in "" + this);
			}
			throw new NoSuchBeanDefinitionException(beanName);
		}

		if (hasBeanCreationStarted()) {
			// Cannot modify startup-time collection elements anymore (for stable iteration)
			synchronized (this.beanDefinitionMap) {
				List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames);
				updatedDefinitions.remove(beanName);
				this.beanDefinitionNames = updatedDefinitions;
			}
		}
		else {
			// Still in startup registration phase
			this.beanDefinitionNames.remove(beanName);
		}
		this.frozenBeanDefinitionNames = null;

		resetBeanDefinition(beanName);
	}

	/**
	 * Reset all bean definition caches for the given bean,
	 * including the caches of beans that are derived from it.
	 * <p>Called after an existing bean definition has been replaced or removed,
	 * triggering {@link #clearMergedBeanDefinition}, {@link #destroySingleton}
	 * and {@link MergedBeanDefinitionPostProcessor#resetBeanDefinition} on the
	 * given bean and on all bean definitions that have the given bean as parent.
	 * @param beanName the name of the bean to reset
	 * @see #registerBeanDefinition
	 * @see #removeBeanDefinition
	 */
	protected void resetBeanDefinition(String beanName) {
		// Remove the merged bean definition for the given bean, if already created.
		clearMergedBeanDefinition(beanName);

		// Remove corresponding bean from singleton cache, if any. Shouldn't usually
		// be necessary, rather just meant for overriding a context's default beans
		// (for example, the default StaticMessageSource in a StaticApplicationContext).
		destroySingleton(beanName);

		// Remove a cached primary marker for the given bean.
		this.primaryBeanNamesWithType.remove(beanName);

		// Notify all post-processors that the specified bean definition has been reset.
		for (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {
			processor.resetBeanDefinition(beanName);
		}

		// Reset all bean definitions that have the given bean as parent (recursively).
		for (String bdName : this.beanDefinitionNames) {
			if (!beanName.equals(bdName)) {
				BeanDefinition bd = this.beanDefinitionMap.get(bdName);
				// Ensure bd is non-null due to potential concurrent modification of beanDefinitionMap.
				if (bd != null && beanName.equals(bd.getParentName())) {
					resetBeanDefinition(bdName);
				}
			}
		}
	}

	/**
	 * This implementation returns {@code true} if bean definition overriding
	 * is generally allowed.
	 * @see #setAllowBeanDefinitionOverriding
	 */
	@Override
	public boolean isBeanDefinitionOverridable(String beanName) {
		return isAllowBeanDefinitionOverriding();
	}

	/**
	 * Only allows alias overriding if bean definition overriding is allowed.
	 * @see #setAllowBeanDefinitionOverriding
	 */
	@Override
	protected boolean allowAliasOverriding() {
		return isAllowBeanDefinitionOverriding();
	}

	/**
	 * Also checks for an alias overriding a bean definition of the same name.
	 */
	@Override
	protected void checkForAliasCircle(String name, String alias) {
		super.checkForAliasCircle(name, alias);
		if (!isBeanDefinitionOverridable(alias) && containsBeanDefinition(alias)) {
			throw new IllegalStateException(""Cannot register alias '"" + alias +
					""' for name '"" + name + ""': Alias would override bean definition '"" + alias + ""'"");
		}
	}

	@Override
	protected void addSingleton(String beanName, Object singletonObject) {
		super.addSingleton(beanName, singletonObject);

		Predicate<Class<?>> filter = (beanType -> beanType != Object.class && beanType.isInstance(singletonObject));
		this.allBeanNamesByType.keySet().removeIf(filter);
		this.singletonBeanNamesByType.keySet().removeIf(filter);

		if (this.primaryBeanNamesWithType.containsKey(beanName) && singletonObject.getClass() != NullBean.class) {
			Class<?> beanType = (singletonObject instanceof FactoryBean<?> fb ?
					getTypeForFactoryBean(fb) : singletonObject.getClass());
			if (beanType != null) {
				this.primaryBeanNamesWithType.put(beanName, beanType);
			}
		}
	}

	@Override
	public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {
		super.registerSingleton(beanName, singletonObject);
		updateManualSingletonNames(set -> set.add(beanName), set -> !this.beanDefinitionMap.containsKey(beanName));
	}

	@Override
	public void destroySingletons() {
		super.destroySingletons();
		updateManualSingletonNames(Set::clear, set -> !set.isEmpty());
		clearByTypeCache();
	}

	@Override
	public void destroySingleton(String beanName) {
		super.destroySingleton(beanName);
		removeManualSingletonName(beanName);
		clearByTypeCache();
	}

	private void removeManualSingletonName(String beanName) {
		updateManualSingletonNames(set -> set.remove(beanName), set -> set.contains(beanName));
	}

	/**
	 * Update the factory's internal set of manual singleton names.
	 * @param action the modification action
	 * @param condition a precondition for the modification action
	 * (if this condition does not apply, the action can be skipped)
	 */
	private void updateManualSingletonNames(Consumer<Set<String>> action, Predicate<Set<String>> condition) {
		if (hasBeanCreationStarted()) {
			// Cannot modify startup-time collection elements anymore (for stable iteration)
			synchronized (this.beanDefinitionMap) {
				if (condition.test(this.manualSingletonNames)) {
					Set<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames);
					action.accept(updatedSingletons);
					this.manualSingletonNames = updatedSingletons;
				}
			}
		}
		else {
			// Still in startup registration phase
			if (condition.test(this.manualSingletonNames)) {
				action.accept(this.manualSingletonNames);
			}
		}
	}

	/**
	 * Remove any assumptions about by-type mappings.
	 */
	private void clearByTypeCache() {
		this.allBeanNamesByType.clear();
		this.singletonBeanNamesByType.clear();
	}


	//---------------------------------------------------------------------
	// Dependency resolution functionality
	//---------------------------------------------------------------------

	@Override
	public <T> NamedBeanHolder<T> resolveNamedBean(Class<T> requiredType) throws BeansException {
		Assert.notNull(requiredType, ""Required type must not be null"");
		NamedBeanHolder<T> namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), null, false);
		if (namedBean != null) {
			return namedBean;
		}
		BeanFactory parent = getParentBeanFactory();
		if (parent instanceof AutowireCapableBeanFactory acbf) {
			return acbf.resolveNamedBean(requiredType);
		}
		throw new NoSuchBeanDefinitionException(requiredType);
	}

	@SuppressWarnings(""unchecked"")
	@Nullable
	private <T> NamedBeanHolder<T> resolveNamedBean(
			ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) throws BeansException {

		Assert.notNull(requiredType, ""Required type must not be null"");
		String[] candidateNames = getBeanNamesForType(requiredType);

		if (candidateNames.length > 1) {
			List<String> autowireCandidates = new ArrayList<>(candidateNames.length);
			for (String beanName : candidateNames) {
				if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {
					autowireCandidates.add(beanName);
				}
			}
			if (!autowireCandidates.isEmpty()) {
				candidateNames = StringUtils.toStringArray(autowireCandidates);
			}
		}

		if (candidateNames.length == 1) {
			return resolveNamedBean(candidateNames[0], requiredType, args);
		}
		else if (candidateNames.length > 1) {
			Map<String, Object> candidates = CollectionUtils.newLinkedHashMap(candidateNames.length);
			for (String beanName : candidateNames) {
				if (containsSingleton(beanName) && args == null) {
					Object beanInstance = getBean(beanName);
					candidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));
				}
				else {
					candidates.put(beanName, getType(beanName));
				}
			}
			String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());
			if (candidateName == null) {
				candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());
			}
			if (candidateName == null) {
				candidateName = determineDefaultCandidate(candidates);
			}
			if (candidateName != null) {
				Object beanInstance = candidates.get(candidateName);
				if (beanInstance == null) {
					return null;
				}
				if (beanInstance instanceof Class) {
					return resolveNamedBean(candidateName, requiredType, args);
				}
				return new NamedBeanHolder<>(candidateName, (T) beanInstance);
			}
			if (!nonUniqueAsNull) {
				throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());
			}
		}

		return null;
	}

	@Nullable
	private <T> NamedBeanHolder<T> resolveNamedBean(
			String beanName, ResolvableType requiredType, @Nullable Object[] args) throws BeansException {

		Object bean = getBean(beanName, null, args);
		if (bean instanceof NullBean) {
			return null;
		}
		return new NamedBeanHolder<>(beanName, adaptBeanInstance(beanName, bean, requiredType.toClass()));
	}

	@Override
	@Nullable
	public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

		descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
		if (Optional.class == descriptor.getDependencyType()) {
			return createOptionalDependency(descriptor, requestingBeanName);
		}
		else if (ObjectFactory.class == descriptor.getDependencyType() ||
				ObjectProvider.class == descriptor.getDependencyType()) {
			return new DependencyObjectProvider(descriptor, requestingBeanName);
		}
		else if (jakartaInjectProviderClass == descriptor.getDependencyType()) {
			return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
		}
		else if (descriptor.supportsLazyResolution()) {
			Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
					descriptor, requestingBeanName);
			if (result != null) {
				return result;
			}
		}
		return doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
	}

	@Nullable
	@SuppressWarnings(""NullAway"")
	public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

		InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
		try {
			// Step 1: pre-resolved shortcut for single bean match, for example, from @Autowired
			Object shortcut = descriptor.resolveShortcut(this);
			if (shortcut != null) {
				return shortcut;
			}

			Class<?> type = descriptor.getDependencyType();

			// Step 2: pre-defined value or expression, for example, from @Value
			Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
			if (value != null) {
				if (value instanceof String strValue) {
					String resolvedValue = resolveEmbeddedValue(strValue);
					BeanDefinition bd = (beanName != null && containsBean(beanName) ?
							getMergedBeanDefinition(beanName) : null);
					value = evaluateBeanDefinitionString(resolvedValue, bd);
				}
				TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
				try {
					return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
				}
				catch (UnsupportedOperationException ex) {
					// A custom TypeConverter which does not support TypeDescriptor resolution...
					return (descriptor.getField() != null ?
							converter.convertIfNecessary(value, type, descriptor.getField()) :
							converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
				}
			}

			// Step 3: shortcut for declared dependency name or qualifier-suggested name matching target bean name
			if (descriptor.usesStandardBeanLookup()) {
				String dependencyName = descriptor.getDependencyName();
				if (dependencyName == null || !containsBean(dependencyName)) {
					String suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);
					dependencyName = (suggestedName != null && containsBean(suggestedName) ? suggestedName : null);
				}
				if (dependencyName != null) {
					dependencyName = canonicalName(dependencyName);  // dependency name can be alias of target name
					if (isTypeMatch(dependencyName, type) && isAutowireCandidate(dependencyName, descriptor) &&
							!isFallback(dependencyName) && !hasPrimaryConflict(dependencyName, type) &&
							!isSelfReference(beanName, dependencyName)) {
						if (autowiredBeanNames != null) {
							autowiredBeanNames.add(dependencyName);
						}
						boolean preExisting = containsSingleton(dependencyName);
						Object dependencyBean = getBean(dependencyName);
						if (preExisting && dependencyBean instanceof NullBean) {
							// for backwards compatibility with addCandidateEntry in the regular code path
							dependencyBean = null;
						}
						return resolveInstance(dependencyBean, descriptor, type, dependencyName);
					}
				}
			}

			// Step 4a: multiple beans as stream / array / standard collection / plain map
			Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
			if (multipleBeans != null) {
				return multipleBeans;
			}
			// Step 4b: direct bean matches, possibly direct beans of type Collection / Map
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
			if (matchingBeans.isEmpty()) {
				// Step 4c (fallback): custom Collection / Map declarations for collecting multiple beans
				multipleBeans = resolveMultipleBeansFallback(descriptor, beanName, autowiredBeanNames, typeConverter);
				if (multipleBeans != null) {
					return multipleBeans;
				}
				// Raise exception if nothing found for required injection point
				if (isRequired(descriptor)) {
					raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
				}
				return null;
			}

			String autowiredBeanName;
			Object instanceCandidate;

			// Step 5: determine single candidate
			if (matchingBeans.size() > 1) {
				autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
				if (autowiredBeanName == null) {
					if (isRequired(descriptor) || !indicatesArrayCollectionOrMap(type)) {
						// Raise exception if no clear match found for required injection point
						return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
					}
					else {
						// In case of an optional Collection/Map, silently ignore a non-unique case:
						// possibly it was meant to be an empty collection of multiple regular beans
						// (before 4.3 in particular when we didn't even look for collection beans).
						return null;
					}
				}
				instanceCandidate = matchingBeans.get(autowiredBeanName);
			}
			else {
				// We have exactly one match.
				Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
				autowiredBeanName = entry.getKey();
				instanceCandidate = entry.getValue();
			}

			// Step 6: validate single result
			if (autowiredBeanNames != null) {
				autowiredBeanNames.add(autowiredBeanName);
			}
			if (instanceCandidate instanceof Class) {
				instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
			}
			return resolveInstance(instanceCandidate, descriptor, type, autowiredBeanName);
		}
		finally {
			ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
		}
	}

	@Nullable
	private Object resolveInstance(Object candidate, DependencyDescriptor descriptor, Class<?> type, String name) {
		Object result = candidate;
		if (result instanceof NullBean) {
			// Raise exception if null encountered for required injection point
			if (isRequired(descriptor)) {
				raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
			}
			result = null;
		}
		if (!ClassUtils.isAssignableValue(type, result)) {
			throw new BeanNotOfRequiredTypeException(name, type, candidate.getClass());
		}
		return result;
	}

	@Nullable
	private Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

		Class<?> type = descriptor.getDependencyType();

		if (descriptor instanceof StreamDependencyDescriptor streamDependencyDescriptor) {
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
			if (autowiredBeanNames != null) {
				autowiredBeanNames.addAll(matchingBeans.keySet());
			}
			Stream<Object> stream = matchingBeans.keySet().stream()
					.map(name -> descriptor.resolveCandidate(name, type, this))
					.filter(bean -> !(bean instanceof NullBean));
			if (streamDependencyDescriptor.isOrdered()) {
				stream = stream.sorted(adaptOrderComparator(matchingBeans));
			}
			return stream;
		}
		else if (type.isArray()) {
			Class<?> componentType = type.componentType();
			ResolvableType resolvableType = descriptor.getResolvableType();
			Class<?> resolvedArrayType = resolvableType.resolve(type);
			if (resolvedArrayType != type) {
				componentType = resolvableType.getComponentType().resolve();
			}
			if (componentType == null) {
				return null;
			}
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType,
					new MultiElementDescriptor(descriptor));
			if (matchingBeans.isEmpty()) {
				return null;
			}
			if (autowiredBeanNames != null) {
				autowiredBeanNames.addAll(matchingBeans.keySet());
			}
			TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
			Object result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);
			if (result instanceof Object[] array && array.length > 1) {
				Comparator<Object> comparator = adaptDependencyComparator(matchingBeans);
				if (comparator != null) {
					Arrays.sort(array, comparator);
				}
			}
			return result;
		}
		else if (Collection.class == type || Set.class == type || List.class == type) {
			return resolveMultipleBeanCollection(descriptor, beanName, autowiredBeanNames, typeConverter);
		}
		else if (Map.class == type) {
			return resolveMultipleBeanMap(descriptor, beanName, autowiredBeanNames, typeConverter);
		}
		return null;
	}


	@Nullable
	private Object resolveMultipleBeansFallback(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

		Class<?> type = descriptor.getDependencyType();

		if (Collection.class.isAssignableFrom(type) && type.isInterface()) {
			return resolveMultipleBeanCollection(descriptor, beanName, autowiredBeanNames, typeConverter);
		}
		else if (Map.class.isAssignableFrom(type) && type.isInterface()) {
			return resolveMultipleBeanMap(descriptor, beanName, autowiredBeanNames, typeConverter);
		}
		return null;
	}

	@Nullable
	private Object resolveMultipleBeanCollection(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

		Class<?> elementType = descriptor.getResolvableType().asCollection().resolveGeneric();
		if (elementType == null) {
			return null;
		}
		Map<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType,
				new MultiElementDescriptor(descriptor));
		if (matchingBeans.isEmpty()) {
			return null;
		}
		if (autowiredBeanNames != null) {
			autowiredBeanNames.addAll(matchingBeans.keySet());
		}
		TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
		Object result = converter.convertIfNecessary(matchingBeans.values(), descriptor.getDependencyType());
		if (result instanceof List<?> list && list.size() > 1) {
			Comparator<Object> comparator = adaptDependencyComparator(matchingBeans);
			if (comparator != null) {
				list.sort(comparator);
			}
		}
		return result;
	}

	@Nullable
	private Object resolveMultipleBeanMap(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

		ResolvableType mapType = descriptor.getResolvableType().asMap();
		Class<?> keyType = mapType.resolveGeneric(0);
		if (String.class != keyType) {
			return null;
		}
		Class<?> valueType = mapType.resolveGeneric(1);
		if (valueType == null) {
			return null;
		}
		Map<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType,
				new MultiElementDescriptor(descriptor));
		if (matchingBeans.isEmpty()) {
			return null;
		}
		if (autowiredBeanNames != null) {
			autowiredBeanNames.addAll(matchingBeans.keySet());
		}
		TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
		return converter.convertIfNecessary(matchingBeans, descriptor.getDependencyType());
	}

	private boolean indicatesArrayCollectionOrMap(Class<?> type) {
		return (type.isArray() || (type.isInterface() &&
				(Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type))));
	}

	private boolean isRequired(DependencyDescriptor descriptor) {
		return getAutowireCandidateResolver().isRequired(descriptor);
	}

	@Nullable
	private Comparator<Object> adaptDependencyComparator(Map<String, ?> matchingBeans) {
		Comparator<Object> comparator = getDependencyComparator();
		if (comparator instanceof OrderComparator orderComparator) {
			return orderComparator.withSourceProvider(
					createFactoryAwareOrderSourceProvider(matchingBeans));
		}
		else {
			return comparator;
		}
	}

	private Comparator<Object> adaptOrderComparator(Map<String, ?> matchingBeans) {
		Comparator<Object> dependencyComparator = getDependencyComparator();
		OrderComparator comparator = (dependencyComparator instanceof OrderComparator orderComparator ?
				orderComparator : OrderComparator.INSTANCE);
		return comparator.withSourceProvider(createFactoryAwareOrderSourceProvider(matchingBeans));
	}

	private OrderComparator.OrderSourceProvider createFactoryAwareOrderSourceProvider(Map<String, ?> beans) {
		IdentityHashMap<Object, String> instancesToBeanNames = new IdentityHashMap<>();
		beans.forEach((beanName, instance) -> instancesToBeanNames.put(instance, beanName));
		return new FactoryAwareOrderSourceProvider(instancesToBeanNames);
	}

	/**
	 * Find bean instances that match the required type.
	 * Called during autowiring for the specified bean.
	 * @param beanName the name of the bean that is about to be wired
	 * @param requiredType the actual type of bean to look for
	 * (may be an array component type or collection element type)
	 * @param descriptor the descriptor of the dependency to resolve
	 * @return a Map of candidate names and candidate instances that match
	 * the required type (never {@code null})
	 * @throws BeansException in case of errors
	 * @see #autowireByType
	 * @see #autowireConstructor
	 */
	protected Map<String, Object> findAutowireCandidates(
			@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {

		String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
				this, requiredType, true, descriptor.isEager());
		Map<String, Object> result = CollectionUtils.newLinkedHashMap(candidateNames.length);
		for (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) {
			Class<?> autowiringType = classObjectEntry.getKey();
			if (autowiringType.isAssignableFrom(requiredType)) {
				Object autowiringValue = classObjectEntry.getValue();
				autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);
				if (requiredType.isInstance(autowiringValue)) {
					result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);
					break;
				}
			}
		}
		for (String candidate : candidateNames) {
			if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {
				addCandidateEntry(result, candidate, descriptor, requiredType);
			}
		}
		if (result.isEmpty()) {
			boolean multiple = indicatesArrayCollectionOrMap(requiredType);
			// Consider fallback matches if the first pass failed to find anything...
			DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();
			for (String candidate : candidateNames) {
				if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) &&
						(!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) {
					addCandidateEntry(result, candidate, descriptor, requiredType);
				}
			}
			if (result.isEmpty() && !multiple) {
				// Consider self references as a final pass...
				// but in the case of a dependency collection, not the very same bean itself.
				for (String candidate : candidateNames) {
					if (isSelfReference(beanName, candidate) &&
							(!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) &&
							isAutowireCandidate(candidate, fallbackDescriptor)) {
						addCandidateEntry(result, candidate, descriptor, requiredType);
					}
				}
			}
		}
		return result;
	}

	/**
	 * Add an entry to the candidate map: a bean instance if available or just the resolved
	 * type, preventing early bean initialization ahead of primary candidate selection.
	 */
	private void addCandidateEntry(Map<String, Object> candidates, String candidateName,
			DependencyDescriptor descriptor, Class<?> requiredType) {

		if (descriptor instanceof MultiElementDescriptor) {
			Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);
			if (!(beanInstance instanceof NullBean)) {
				candidates.put(candidateName, beanInstance);
			}
		}
		else if (containsSingleton(candidateName) ||
				(descriptor instanceof StreamDependencyDescriptor streamDescriptor && streamDescriptor.isOrdered())) {
			Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);
			candidates.put(candidateName, (beanInstance instanceof NullBean ? null : beanInstance));
		}
		else {
			candidates.put(candidateName, getType(candidateName));
		}
	}

	/**
	 * Determine the autowire candidate in the given set of beans.
	 * <p>Looks for {@code @Primary} and {@code @Priority} (in that order).
	 * @param candidates a Map of candidate names and candidate instances
	 * that match the required type, as returned by {@link #findAutowireCandidates}
	 * @param descriptor the target dependency to match against
	 * @return the name of the autowire candidate, or {@code null} if none found
	 */
	@Nullable
	protected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {
		Class<?> requiredType = descriptor.getDependencyType();
		// Step 1: check primary candidate
		String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);
		if (primaryCandidate != null) {
			return primaryCandidate;
		}
		// Step 2a: match bean name against declared dependency name
		String dependencyName = descriptor.getDependencyName();
		if (dependencyName != null) {
			for (String beanName : candidates.keySet()) {
				if (matchesBeanName(beanName, dependencyName)) {
					return beanName;
				}
			}
		}
		// Step 2b: match bean name against qualifier-suggested name
		String suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);
		if (suggestedName != null) {
			for (String beanName : candidates.keySet()) {
				if (matchesBeanName(beanName, suggestedName)) {
					return beanName;
				}
			}
		}
		// Step 3: check highest priority candidate
		String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);
		if (priorityCandidate != null) {
			return priorityCandidate;
		}
		// Step 4: pick unique default-candidate
		String defaultCandidate = determineDefaultCandidate(candidates);
		if (defaultCandidate != null) {
			return defaultCandidate;
		}
		// Step 5: pick directly registered dependency
		for (Map.Entry<String, Object> entry : candidates.entrySet()) {
			String candidateName = entry.getKey();
			Object beanInstance = entry.getValue();
			if (beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) {
				return candidateName;
			}
		}
		return null;
	}

	/**
	 * Determine the primary candidate in the given set of beans.
	 * @param candidates a Map of candidate names and candidate instances
	 * (or candidate classes if not created yet) that match the required type
	 * @param requiredType the target dependency type to match against
	 * @return the name of the primary candidate, or {@code null} if none found
	 * @see #isPrimary(String, Object)
	 */
	@Nullable
	protected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType) {
		String primaryBeanName = null;
		// First pass: identify unique primary candidate
		for (Map.Entry<String, Object> entry : candidates.entrySet()) {
			String candidateBeanName = entry.getKey();
			Object beanInstance = entry.getValue();
			if (isPrimary(candidateBeanName, beanInstance)) {
				if (primaryBeanName != null) {
					boolean candidateLocal = containsBeanDefinition(candidateBeanName);
					boolean primaryLocal = containsBeanDefinition(primaryBeanName);
					if (candidateLocal == primaryLocal) {
						throw new NoUniqueBeanDefinitionException(requiredType, candidates.size(),
								""more than one 'primary' bean found among candidates: "" + candidates.keySet());
					}
					else if (candidateLocal) {
						primaryBeanName = candidateBeanName;
					}
				}
				else {
					primaryBeanName = candidateBeanName;
				}
			}
		}
		// Second pass: identify unique non-fallback candidate
		if (primaryBeanName == null) {
			for (String candidateBeanName : candidates.keySet()) {
				if (!isFallback(candidateBeanName)) {
					if (primaryBeanName != null) {
						return null;
					}
					primaryBeanName = candidateBeanName;
				}
			}
		}
		return primaryBeanName;
	}

	/**
	 * Determine the candidate with the highest priority in the given set of beans.
	 * <p>Based on {@code @jakarta.annotation.Priority}. As defined by the related
	 * {@link org.springframework.core.Ordered} interface, the lowest value has
	 * the highest priority.
	 * @param candidates a Map of candidate names and candidate instances
	 * (or candidate classes if not created yet) that match the required type
	 * @param requiredType the target dependency type to match against
	 * @return the name of the candidate with the highest priority,
	 * or {@code null} if none found
	 * @throws NoUniqueBeanDefinitionException if multiple beans are detected with
	 * the same highest priority value
	 * @see #getPriority(Object)
	 */
	@Nullable
	protected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType) {
		String highestPriorityBeanName = null;
		Integer highestPriority = null;
		boolean highestPriorityConflictDetected = false;
		for (Map.Entry<String, Object> entry : candidates.entrySet()) {
			String candidateBeanName = entry.getKey();
			Object beanInstance = entry.getValue();
			if (beanInstance != null) {
				Integer candidatePriority = getPriority(beanInstance);
				if (candidatePriority != null) {
					if (highestPriority != null) {
						if (candidatePriority.equals(highestPriority)) {
							highestPriorityConflictDetected = true;
						}
						else if (candidatePriority < highestPriority) {
							highestPriorityBeanName = candidateBeanName;
							highestPriority = candidatePriority;
							highestPriorityConflictDetected = false;
						}
					}
					else {
						highestPriorityBeanName = candidateBeanName;
						highestPriority = candidatePriority;
					}
				}
			}
		}

		if (highestPriorityConflictDetected) {
			throw new NoUniqueBeanDefinitionException(requiredType, candidates.size(),
					""Multiple beans found with the same highest priority ("" + highestPriority +
					"") among candidates: "" + candidates.keySet());

		}
		return highestPriorityBeanName;
	}

	/**
	 * Return whether the bean definition for the given bean name has been
	 * marked as a primary bean.
	 * @param beanName the name of the bean
	 * @param beanInstance the corresponding bean instance (can be {@code null})
	 * @return whether the given bean qualifies as primary
	 */
	protected boolean isPrimary(String beanName, Object beanInstance) {
		String transformedBeanName = transformedBeanName(beanName);
		if (containsBeanDefinition(transformedBeanName)) {
			return getMergedLocalBeanDefinition(transformedBeanName).isPrimary();
		}
		return (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&
				parent.isPrimary(transformedBeanName, beanInstance));
	}

	/**
	 * Return whether the bean definition for the given bean name has been
	 * marked as a fallback bean.
	 * @param beanName the name of the bean
	 * @since 6.2
	 */
	private boolean isFallback(String beanName) {
		String transformedBeanName = transformedBeanName(beanName);
		if (containsBeanDefinition(transformedBeanName)) {
			return getMergedLocalBeanDefinition(transformedBeanName).isFallback();
		}
		return (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&
				parent.isFallback(transformedBeanName));
	}

	/**
	 * Return the priority assigned for the given bean instance by
	 * the {@code jakarta.annotation.Priority} annotation.
	 * <p>The default implementation delegates to the specified
	 * {@link #setDependencyComparator dependency comparator}, checking its
	 * {@link OrderComparator#getPriority method} if it is an extension of
	 * Spring's common {@link OrderComparator} - typically, an
	 * {@link org.springframework.core.annotation.AnnotationAwareOrderComparator}.
	 * If no such comparator is present, this implementation returns {@code null}.
	 * @param beanInstance the bean instance to check (can be {@code null})
	 * @return the priority assigned to that bean or {@code null} if none is set
	 */
	@Nullable
	protected Integer getPriority(Object beanInstance) {
		Comparator<Object> comparator = getDependencyComparator();
		if (comparator instanceof OrderComparator orderComparator) {
			return orderComparator.getPriority(beanInstance);
		}
		return null;
	}

	/**
	 * Return a unique ""default-candidate"" among remaining non-default candidates.
	 * @param candidates a Map of candidate names and candidate instances
	 * (or candidate classes if not created yet) that match the required type
	 * @return the name of the default candidate, or {@code null} if none found
	 * @since 6.2.4
	 * @see AbstractBeanDefinition#isDefaultCandidate()
	 */
	@Nullable
	private String determineDefaultCandidate(Map<String, Object> candidates) {
		String defaultBeanName = null;
		for (String candidateBeanName : candidates.keySet()) {
			if (AutowireUtils.isDefaultCandidate(this, candidateBeanName)) {
				if (defaultBeanName != null) {
					return null;
				}
				defaultBeanName = candidateBeanName;
			}
		}
		return defaultBeanName;
	}

	/**
	 * Determine whether the given candidate name matches the bean name or the aliases
	 * stored in this bean definition.
	 */
	protected boolean matchesBeanName(String beanName, @Nullable String candidateName) {
		return (candidateName != null &&
				(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));
	}

	/**
	 * Determine whether the given beanName/candidateName pair indicates a self reference,
	 * i.e. whether the candidate points back to the original bean or to a factory method
	 * on the original bean.
	 */
	@Contract(""null, _ -> false; _, null -> false;"")
	private boolean isSelfReference(@Nullable String beanName, @Nullable String candidateName) {
		return (beanName != null && candidateName != null &&
				(beanName.equals(candidateName) || (containsBeanDefinition(candidateName) &&
						beanName.equals(getMergedLocalBeanDefinition(candidateName).getFactoryBeanName()))));
	}

	/**
	 * Determine whether there is a primary bean registered for the given dependency type,
	 * not matching the given bean name.
	 */
	private boolean hasPrimaryConflict(String beanName, Class<?> dependencyType) {
		for (Map.Entry<String, Class<?>> candidate : this.primaryBeanNamesWithType.entrySet()) {
			String candidateName = candidate.getKey();
			Class<?> candidateType = candidate.getValue();
			if (!candidateName.equals(beanName) && (candidateType != Void.class ?
					dependencyType.isAssignableFrom(candidateType) :  // cached singleton class for primary bean
					isTypeMatch(candidateName, dependencyType))) {  // not instantiated yet or not a singleton
				return true;
			}
		}
		return (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&
				parent.hasPrimaryConflict(beanName, dependencyType));
	}

	/**
	 * Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException
	 * for an unresolvable dependency.
	 */
	private void raiseNoMatchingBeanFound(
			Class<?> type, ResolvableType resolvableType, DependencyDescriptor descriptor) throws BeansException {

		checkBeanNotOfRequiredType(type, descriptor);

		throw new NoSuchBeanDefinitionException(resolvableType,
				""expected at least 1 bean which qualifies as autowire candidate. "" +
				""Dependency annotations: "" + ObjectUtils.nullSafeToString(descriptor.getAnnotations()));
	}

	/**
	 * Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable,
	 * i.e. if the target type of the bean would match but an exposed proxy doesn't.
	 */
	private void checkBeanNotOfRequiredType(Class<?> type, DependencyDescriptor descriptor) {
		for (String beanName : this.beanDefinitionNames) {
			try {
				RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				Class<?> targetType = mbd.getTargetType();
				if (targetType != null && type.isAssignableFrom(targetType) &&
						isAutowireCandidate(beanName, mbd, descriptor, getAutowireCandidateResolver())) {
					// Probably a proxy interfering with target type match -> throw meaningful exception.
					Object beanInstance = getSingleton(beanName, false);
					Class<?> beanType = (beanInstance != null && beanInstance.getClass() != NullBean.class ?
							beanInstance.getClass() : predictBeanType(beanName, mbd));
					if (beanType != null && !type.isAssignableFrom(beanType)) {
						throw new BeanNotOfRequiredTypeException(beanName, type, beanType);
					}
				}
			}
			catch (NoSuchBeanDefinitionException ex) {
				// Bean definition got removed while we were iterating -> ignore.
			}
		}

		if (getParentBeanFactory() instanceof DefaultListableBeanFactory parent) {
			parent.checkBeanNotOfRequiredType(type, descriptor);
		}
	}

	/**
	 * Create an {@link Optional} wrapper for the specified dependency.
	 */
	private Optional<?> createOptionalDependency(
			DependencyDescriptor descriptor, @Nullable String beanName, final Object... args) {

		DependencyDescriptor descriptorToUse = new NestedDependencyDescriptor(descriptor) {
			@Override
			public boolean isRequired() {
				return false;
			}
			@Override
			public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {
				return (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) :
						super.resolveCandidate(beanName, requiredType, beanFactory));
			}
			@Override
			public boolean usesStandardBeanLookup() {
				return ObjectUtils.isEmpty(args);
			}
		};
		Object result = doResolveDependency(descriptorToUse, beanName, null, null);
		return (result instanceof Optional<?> optional ? optional : Optional.ofNullable(result));
	}


	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder(ObjectUtils.identityToString(this));
		sb.append("": defining beans ["");
		sb.append(StringUtils.collectionToCommaDelimitedString(this.beanDefinitionNames));
		sb.append(""]; "");
		BeanFactory parent = getParentBeanFactory();
		if (parent == null) {
			sb.append(""root of factory hierarchy"");
		}
		else {
			sb.append(""parent: "").append(ObjectUtils.identityToString(parent));
		}
		return sb.toString();
	}


	//---------------------------------------------------------------------
	// Serialization support
	//---------------------------------------------------------------------

	@Serial
	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
		throw new NotSerializableException(""DefaultListableBeanFactory itself is not deserializable - "" +
				""just a SerializedBeanFactoryReference is"");
	}

	@Serial
	protected Object writeReplace() throws ObjectStreamException {
		if (this.serializationId != null) {
			return new SerializedBeanFactoryReference(this.serializationId);
		}
		else {
			throw new NotSerializableException(""DefaultListableBeanFactory has no serialization id"");
		}
	}


	/**
	 * Minimal id reference to the factory.
	 * Resolved to the actual factory instance on deserialization.
	 */
	private static class SerializedBeanFactoryReference implements Serializable {

		private final String id;

		public SerializedBeanFactoryReference(String id) {
			this.id = id;
		}

		private Object readResolve() {
			Reference<?> ref = serializableFactories.get(this.id);
			if (ref != null) {
				Object result = ref.get();
				if (result != null) {
					return result;
				}
			}
			// Lenient fallback: dummy factory in case of original factory not found...
			DefaultListableBeanFactory dummyFactory = new DefaultListableBeanFactory();
			dummyFactory.serializationId = this.id;
			return dummyFactory;
		}
	}


	/**
	 * A dependency descriptor marker for nested elements.
	 */
	private static class NestedDependencyDescriptor extends DependencyDescriptor {

		public NestedDependencyDescriptor(DependencyDescriptor original) {
			super(original);
			increaseNestingLevel();
		}

		@Override
		public boolean usesStandardBeanLookup() {
			return true;
		}
	}


	/**
	 * A dependency descriptor for a multi-element declaration with nested elements.
	 */
	private static class MultiElementDescriptor extends NestedDependencyDescriptor {

		public MultiElementDescriptor(DependencyDescriptor original) {
			super(original);
		}
	}


	/**
	 * A dependency descriptor marker for stream access to multiple elements.
	 */
	private static class StreamDependencyDescriptor extends DependencyDescriptor {

		private final boolean ordered;

		public StreamDependencyDescriptor(DependencyDescriptor original, boolean ordered) {
			super(original);
			this.ordered = ordered;
		}

		public boolean isOrdered() {
			return this.ordered;
		}
	}


	private interface BeanObjectProvider<T> extends ObjectProvider<T>, Serializable {
	}


	/**
	 * Serializable ObjectFactory/ObjectProvider for lazy resolution of a dependency.
	 */
	private class DependencyObjectProvider implements BeanObjectProvider<Object> {

		private final DependencyDescriptor descriptor;

		private final boolean optional;

		@Nullable
		private final String beanName;

		public DependencyObjectProvider(DependencyDescriptor descriptor, @Nullable String beanName) {
			this.descriptor = new NestedDependencyDescriptor(descriptor);
			this.optional = (this.descriptor.getDependencyType() == Optional.class);
			this.beanName = beanName;
		}

		@Override
		public Object getObject() throws BeansException {
			if (this.optional) {
				return createOptionalDependency(this.descriptor, this.beanName);
			}
			else {
				Object result = doResolveDependency(this.descriptor, this.beanName, null, null);
				if (result == null) {
					throw new NoSuchBeanDefinitionException(this.descriptor.getResolvableType());
				}
				return result;
			}
		}

		@Override
		public Object getObject(final Object... args) throws BeansException {
			if (this.optional) {
				return createOptionalDependency(this.descriptor, this.beanName, args);
			}
			else {
				DependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {
					@Override
					public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {
						return beanFactory.getBean(beanName, args);
					}
				};
				Object result = doResolveDependency(descriptorToUse, this.beanName, null, null);
				if (result == null) {
					throw new NoSuchBeanDefinitionException(this.descriptor.getResolvableType());
				}
				return result;
			}
		}

		@Override
		@Nullable
		public Object getIfAvailable() throws BeansException {
			try {
				if (this.optional) {
					return createOptionalDependency(this.descriptor, this.beanName);
				}
				else {
					DependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {
						@Override
						public boolean isRequired() {
							return false;
						}
						@Override
						public boolean usesStandardBeanLookup() {
							return true;
						}
					};
					return doResolveDependency(descriptorToUse, this.beanName, null, null);
				}
			}
			catch (ScopeNotActiveException ex) {
				// Ignore resolved bean in non-active scope
				return null;
			}
		}

		@Override
		public void ifAvailable(Consumer<Object> dependencyConsumer) throws BeansException {
			Object dependency = getIfAvailable();
			if (dependency != null) {
				try {
					dependencyConsumer.accept(dependency);
				}
				catch (ScopeNotActiveException ex) {
					// Ignore resolved bean in non-active scope, even on scoped proxy invocation
				}
			}
		}

		@Override
		@Nullable
		public Object getIfUnique() throws BeansException {
			DependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {
				@Override
				public boolean isRequired() {
					return false;
				}
				@Override
				public boolean usesStandardBeanLookup() {
					return true;
				}
				@Override
				@Nullable
				public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) {
					return null;
				}
			};
			try {
				if (this.optional) {
					return createOptionalDependency(descriptorToUse, this.beanName);
				}
				else {
					return doResolveDependency(descriptorToUse, this.beanName, null, null);
				}
			}
			catch (ScopeNotActiveException ex) {
				// Ignore resolved bean in non-active scope
				return null;
			}
		}

		@Override
		public void ifUnique(Consumer<Object> dependencyConsumer) throws BeansException {
			Object dependency = getIfUnique();
			if (dependency != null) {
				try {
					dependencyConsumer.accept(dependency);
				}
				catch (ScopeNotActiveException ex) {
					// Ignore resolved bean in non-active scope, even on scoped proxy invocation
				}
			}
		}

		@Nullable
		protected Object getValue() throws BeansException {
			if (this.optional) {
				return createOptionalDependency(this.descriptor, this.beanName);
			}
			else {
				return doResolveDependency(this.descriptor, this.beanName, null, null);
			}
		}

		@Override
		public Stream<Object> stream() {
			return resolveStream(false);
		}

		@Override
		public Stream<Object> orderedStream() {
			return resolveStream(true);
		}

		@SuppressWarnings({""rawtypes"", ""unchecked""})
		private Stream<Object> resolveStream(boolean ordered) {
			DependencyDescriptor descriptorToUse = new StreamDependencyDescriptor(this.descriptor, ordered);
			Object result = doResolveDependency(descriptorToUse, this.beanName, null, null);
			return (result instanceof Stream stream ? stream : Stream.of(result));
		}

		@Override
		public Stream<Object> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {
			return Arrays.stream(beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true))
					.filter(name -> AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, name))
					.filter(name -> customFilter.test(getType(name)))
					.map(name -> getBean(name))
					.filter(bean -> !(bean instanceof NullBean));
		}

		@Override
		public Stream<Object> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {
			String[] beanNames = beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true);
			if (beanNames.length == 0) {
				return Stream.empty();
			}
			Map<String, Object> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);
			for (String beanName : beanNames) {
				if (AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, beanName) &&
						customFilter.test(getType(beanName))) {
					Object beanInstance = getBean(beanName);
					if (!(beanInstance instanceof NullBean)) {
						matchingBeans.put(beanName, beanInstance);
					}
				}
			}
			return matchingBeans.values().stream().sorted(adaptOrderComparator(matchingBeans));
		}
	}


	/**
	 * Separate inner class for avoiding a hard dependency on the {@code jakarta.inject} API.
	 * Actual {@code jakarta.inject.Provider} implementation is nested here in order to make it
	 * invisible for Graal's introspection of DefaultListableBeanFactory's nested classes.
	 */
	private class Jsr330Factory implements Serializable {

		public Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName) {
			return new Jsr330Provider(descriptor, beanName);
		}

		private class Jsr330Provider extends DependencyObjectProvider implements Provider<Object> {

			public Jsr330Provider(DependencyDescriptor descriptor, @Nullable String beanName) {
				super(descriptor, beanName);
			}

			@Override
			@Nullable
			public Object get() throws BeansException {
				return getValue();
			}
		}
	}


	/**
	 * An {@link org.springframework.core.OrderComparator.OrderSourceProvider} implementation
	 * that is aware of the bean metadata of the instances to sort.
	 * <p>Lookup for the method factory of an instance to sort, if any, and let the
	 * comparator retrieve the {@link org.springframework.core.annotation.Order}
	 * value defined on it.
	 * <p>As of 6.1.2, this class takes the {@link AbstractBeanDefinition#ORDER_ATTRIBUTE}
	 * attribute into account.
	 */
	private class FactoryAwareOrderSourceProvider implements OrderComparator.OrderSourceProvider {

		private final Map<Object, String> instancesToBeanNames;

		public FactoryAwareOrderSourceProvider(Map<Object, String> instancesToBeanNames) {
			this.instancesToBeanNames = instancesToBeanNames;
		}

		@Override
		@Nullable
		public Object getOrderSource(Object obj) {
			String beanName = this.instancesToBeanNames.get(obj);
			if (beanName == null) {
				return null;
			}
			try {
				BeanDefinition beanDefinition = getMergedBeanDefinition(beanName);
				List<Object> sources = new ArrayList<>(3);
				Object orderAttribute = beanDefinition.getAttribute(AbstractBeanDefinition.ORDER_ATTRIBUTE);
				if (orderAttribute != null) {
					if (orderAttribute instanceof Integer order) {
						sources.add((Ordered) () -> order);
					}
					else {
						throw new IllegalStateException(""Invalid value type for attribute '"" +
								AbstractBeanDefinition.ORDER_ATTRIBUTE + ""': "" + orderAttribute.getClass().getName());
					}
				}
				if (beanDefinition instanceof RootBeanDefinition rootBeanDefinition) {
					Method factoryMethod = rootBeanDefinition.getResolvedFactoryMethod();
					if (factoryMethod != null) {
						sources.add(factoryMethod);
					}
					Class<?> targetType = rootBeanDefinition.getTargetType();
					if (targetType != null && targetType != obj.getClass()) {
						sources.add(targetType);
					}
				}
				return sources.toArray();
			}
			catch (NoSuchBeanDefinitionException ex) {
				return null;
			}
		}
	}


	private enum PreInstantiation {

		MAIN, BACKGROUND
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory.support;

import java.io.IOException;
import java.io.NotSerializableException;
import java.io.ObjectInputStream;
import java.io.ObjectStreamException;
import java.io.Serial;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.ref.Reference;
import java.lang.ref.WeakReference;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executor;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Stream;

import jakarta.inject.Provider;

import org.springframework.beans.BeansException;
import org.springframework.beans.TypeConverter;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.beans.factory.BeanCurrentlyInCreationException;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.BeanNotOfRequiredTypeException;
import org.springframework.beans.factory.CannotLoadBeanClassException;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InjectionPoint;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;
import org.springframework.beans.factory.ObjectFactory;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.beans.factory.SmartFactoryBean;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.config.DependencyDescriptor;
import org.springframework.beans.factory.config.NamedBeanHolder;
import org.springframework.core.NamedThreadLocal;
import org.springframework.core.OrderComparator;
import org.springframework.core.Ordered;
import org.springframework.core.ResolvableType;
import org.springframework.core.SpringProperties;
import org.springframework.core.annotation.MergedAnnotation;
import org.springframework.core.annotation.MergedAnnotations;
import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;
import org.springframework.core.log.LogMessage;
import org.springframework.core.metrics.StartupStep;
import org.springframework.lang.Contract;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.CollectionUtils;
import org.springframework.util.CompositeIterator;
import org.springframework.util.ObjectUtils;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

/**
 * Spring's default implementation of the {@link ConfigurableListableBeanFactory}
 * and {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory
 * based on bean definition metadata, extensible through post-processors.
 *
 * <p>Typical usage is registering all bean definitions first (possibly read
 * from a bean definition file), before accessing beans. Bean lookup by name
 * is therefore an inexpensive operation in a local bean definition table,
 * operating on pre-resolved bean definition metadata objects.
 *
 * <p>Note that readers for specific bean definition formats are typically
 * implemented separately rather than as bean factory subclasses: see for example
 * {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader}.
 *
 * <p>For an alternative implementation of the
 * {@link org.springframework.beans.factory.ListableBeanFactory} interface,
 * have a look at {@link StaticListableBeanFactory}, which manages existing
 * bean instances rather than creating new ones based on bean definitions.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @author Costin Leau
 * @author Chris Beams
 * @author Phillip Webb
 * @author Stephane Nicoll
 * @author Sebastien Deleuze
 * @since 16 April 2001
 * @see #registerBeanDefinition
 * @see #addBeanPostProcessor
 * @see #getBean
 * @see #resolveDependency
 */
@SuppressWarnings(""serial"")
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
		implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {

	/**
	 * System property that instructs Spring to enforce strict locking during bean creation,
	 * rather than the mix of strict and lenient locking that 6.2 applies by default. Setting
	 * this flag to ""true"" restores 6.1.x style locking in the entire pre-instantiation phase.
	 * <p>By default, the factory infers strict locking from the encountered thread names:
	 * If additional threads have names that match the thread prefix of the main bootstrap thread,
	 * they are considered external (multiple external bootstrap threads calling into the factory)
	 * and therefore have strict locking applied to them. This inference can be turned off through
	 * explicitly setting this flag to ""false"" rather than leaving it unspecified.
	 * @since 6.2.6
	 * @see #preInstantiateSingletons()
	 */
	public static final String STRICT_LOCKING_PROPERTY_NAME = ""spring.locking.strict"";

	@Nullable
	private static Class<?> jakartaInjectProviderClass;

	static {
		try {
			jakartaInjectProviderClass =
					ClassUtils.forName(""jakarta.inject.Provider"", DefaultListableBeanFactory.class.getClassLoader());
		}
		catch (ClassNotFoundException ex) {
			// JSR-330 API not available - Provider interface simply not supported then.
			jakartaInjectProviderClass = null;
		}
	}


	/** Map from serialized id to factory instance. */
	private static final Map<String, Reference<DefaultListableBeanFactory>> serializableFactories =
			new ConcurrentHashMap<>(8);

	/** Whether strict locking is enforced or relaxed in this factory. */
	@Nullable
	private final Boolean strictLocking = SpringProperties.checkFlag(STRICT_LOCKING_PROPERTY_NAME);

	/** Optional id for this factory, for serialization purposes. */
	@Nullable
	private String serializationId;

	/** Whether to allow re-registration of a different definition with the same name. */
	@Nullable
	private Boolean allowBeanDefinitionOverriding;

	/** Whether to allow eager class loading even for lazy-init beans. */
	private boolean allowEagerClassLoading = true;

	@Nullable
	private Executor bootstrapExecutor;

	/** Optional OrderComparator for dependency Lists and arrays. */
	@Nullable
	private Comparator<Object> dependencyComparator;

	/** Resolver to use for checking if a bean definition is an autowire candidate. */
	private AutowireCandidateResolver autowireCandidateResolver = SimpleAutowireCandidateResolver.INSTANCE;

	/** Map from dependency type to corresponding autowired value. */
	private final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<>(16);

	/** Map of bean definition objects, keyed by bean name. */
	private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

	/** Map from bean name to merged BeanDefinitionHolder. */
	private final Map<String, BeanDefinitionHolder> mergedBeanDefinitionHolders = new ConcurrentHashMap<>(256);

	/** Map of bean definition names with a primary marker plus corresponding type. */
	private final Map<String, Class<?>> primaryBeanNamesWithType = new ConcurrentHashMap<>(16);

	/** Map of singleton and non-singleton bean names, keyed by dependency type. */
	private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<>(64);

	/** Map of singleton-only bean names, keyed by dependency type. */
	private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<>(64);

	/** List of bean definition names, in registration order. */
	private volatile List<String> beanDefinitionNames = new ArrayList<>(256);

	/** List of names of manually registered singletons, in registration order. */
	private volatile Set<String> manualSingletonNames = new LinkedHashSet<>(16);

	/** Cached array of bean definition names in case of frozen configuration. */
	@Nullable
	private volatile String[] frozenBeanDefinitionNames;

	/** Whether bean definition metadata may be cached for all beans. */
	private volatile boolean configurationFrozen;

	/** Name prefix of main thread: only set during pre-instantiation phase. */
	@Nullable
	private volatile String mainThreadPrefix;

	private final NamedThreadLocal<PreInstantiation> preInstantiationThread =
			new NamedThreadLocal<>(""Pre-instantiation thread marker"");


	/**
	 * Create a new DefaultListableBeanFactory.
	 */
	public DefaultListableBeanFactory() {
		super();
	}

	/**
	 * Create a new DefaultListableBeanFactory with the given parent.
	 * @param parentBeanFactory the parent BeanFactory
	 */
	public DefaultListableBeanFactory(@Nullable BeanFactory parentBeanFactory) {
		super(parentBeanFactory);
	}


	/**
	 * Specify an id for serialization purposes, allowing this BeanFactory to be
	 * deserialized from this id back into the BeanFactory object, if needed.
	 */
	public void setSerializationId(@Nullable String serializationId) {
		if (serializationId != null) {
			serializableFactories.put(serializationId, new WeakReference<>(this));
		}
		else if (this.serializationId != null) {
			serializableFactories.remove(this.serializationId);
		}
		this.serializationId = serializationId;
	}

	/**
	 * Return an id for serialization purposes, if specified, allowing this BeanFactory
	 * to be deserialized from this id back into the BeanFactory object, if needed.
	 * @since 4.1.2
	 */
	@Nullable
	public String getSerializationId() {
		return this.serializationId;
	}

	/**
	 * Set whether it should be allowed to override bean definitions by registering
	 * a different definition with the same name, automatically replacing the former.
	 * If not, an exception will be thrown. This also applies to overriding aliases.
	 * <p>Default is ""true"".
	 * @see #registerBeanDefinition
	 */
	public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {
		this.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;
	}

	/**
	 * Return whether it should be allowed to override bean definitions by registering
	 * a different definition with the same name, automatically replacing the former.
	 * @since 4.1.2
	 */
	public boolean isAllowBeanDefinitionOverriding() {
		return !Boolean.FALSE.equals(this.allowBeanDefinitionOverriding);
	}

	/**
	 * Set whether the factory is allowed to eagerly load bean classes
	 * even for bean definitions that are marked as ""lazy-init"".
	 * <p>Default is ""true"". Turn this flag off to suppress class loading
	 * for lazy-init beans unless such a bean is explicitly requested.
	 * In particular, by-type lookups will then simply ignore bean definitions
	 * without resolved class name, instead of loading the bean classes on
	 * demand just to perform a type check.
	 * @see AbstractBeanDefinition#setLazyInit
	 */
	public void setAllowEagerClassLoading(boolean allowEagerClassLoading) {
		this.allowEagerClassLoading = allowEagerClassLoading;
	}

	/**
	 * Return whether the factory is allowed to eagerly load bean classes
	 * even for bean definitions that are marked as ""lazy-init"".
	 * @since 4.1.2
	 */
	public boolean isAllowEagerClassLoading() {
		return this.allowEagerClassLoading;
	}

	@Override
	public void setBootstrapExecutor(@Nullable Executor bootstrapExecutor) {
		this.bootstrapExecutor = bootstrapExecutor;
	}

	@Override
	@Nullable
	public Executor getBootstrapExecutor() {
		return this.bootstrapExecutor;
	}

	/**
	 * Set a {@link java.util.Comparator} for dependency Lists and arrays.
	 * @since 4.0
	 * @see org.springframework.core.OrderComparator
	 * @see org.springframework.core.annotation.AnnotationAwareOrderComparator
	 */
	public void setDependencyComparator(@Nullable Comparator<Object> dependencyComparator) {
		this.dependencyComparator = dependencyComparator;
	}

	/**
	 * Return the dependency comparator for this BeanFactory (may be {@code null}).
	 * @since 4.0
	 */
	@Nullable
	public Comparator<Object> getDependencyComparator() {
		return this.dependencyComparator;
	}

	/**
	 * Set a custom autowire candidate resolver for this BeanFactory to use
	 * when deciding whether a bean definition should be considered as a
	 * candidate for autowiring.
	 */
	public void setAutowireCandidateResolver(AutowireCandidateResolver autowireCandidateResolver) {
		Assert.notNull(autowireCandidateResolver, ""AutowireCandidateResolver must not be null"");
		if (autowireCandidateResolver instanceof BeanFactoryAware beanFactoryAware) {
			beanFactoryAware.setBeanFactory(this);
		}
		this.autowireCandidateResolver = autowireCandidateResolver;
	}

	/**
	 * Return the autowire candidate resolver for this BeanFactory (never {@code null}).
	 */
	public AutowireCandidateResolver getAutowireCandidateResolver() {
		return this.autowireCandidateResolver;
	}


	@Override
	public void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {
		super.copyConfigurationFrom(otherFactory);
		if (otherFactory instanceof DefaultListableBeanFactory otherListableFactory) {
			this.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;
			this.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;
			this.bootstrapExecutor = otherListableFactory.bootstrapExecutor;
			this.dependencyComparator = otherListableFactory.dependencyComparator;
			// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware
			setAutowireCandidateResolver(otherListableFactory.getAutowireCandidateResolver().cloneIfNecessary());
			// Make resolvable dependencies (for example, ResourceLoader) available here as well
			this.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);
		}
	}


	//---------------------------------------------------------------------
	// Implementation of remaining BeanFactory methods
	//---------------------------------------------------------------------

	@Override
	public <T> T getBean(Class<T> requiredType) throws BeansException {
		return getBean(requiredType, (Object[]) null);
	}

	@SuppressWarnings(""unchecked"")
	@Override
	public <T> T getBean(Class<T> requiredType, @Nullable Object... args) throws BeansException {
		Assert.notNull(requiredType, ""Required type must not be null"");
		Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);
		if (resolved == null) {
			throw new NoSuchBeanDefinitionException(requiredType);
		}
		return (T) resolved;
	}

	@Override
	public <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType) {
		Assert.notNull(requiredType, ""Required type must not be null"");
		return getBeanProvider(ResolvableType.forRawClass(requiredType), true);
	}

	@Override
	public <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {
		return getBeanProvider(requiredType, true);
	}


	//---------------------------------------------------------------------
	// Implementation of ListableBeanFactory interface
	//---------------------------------------------------------------------

	@Override
	public boolean containsBeanDefinition(String beanName) {
		Assert.notNull(beanName, ""Bean name must not be null"");
		return this.beanDefinitionMap.containsKey(beanName);
	}

	@Override
	public int getBeanDefinitionCount() {
		return this.beanDefinitionMap.size();
	}

	@Override
	public String[] getBeanDefinitionNames() {
		String[] frozenNames = this.frozenBeanDefinitionNames;
		if (frozenNames != null) {
			return frozenNames.clone();
		}
		else {
			return StringUtils.toStringArray(this.beanDefinitionNames);
		}
	}

	@Override
	public <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType, boolean allowEagerInit) {
		Assert.notNull(requiredType, ""Required type must not be null"");
		return getBeanProvider(ResolvableType.forRawClass(requiredType), allowEagerInit);
	}

	@Override
	public <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {
		return new BeanObjectProvider<>() {
			@Override
			public T getObject() throws BeansException {
				T resolved = resolveBean(requiredType, null, false);
				if (resolved == null) {
					throw new NoSuchBeanDefinitionException(requiredType);
				}
				return resolved;
			}
			@Override
			public T getObject(Object... args) throws BeansException {
				T resolved = resolveBean(requiredType, args, false);
				if (resolved == null) {
					throw new NoSuchBeanDefinitionException(requiredType);
				}
				return resolved;
			}
			@Override
			@Nullable
			public T getIfAvailable() throws BeansException {
				try {
					return resolveBean(requiredType, null, false);
				}
				catch (ScopeNotActiveException ex) {
					// Ignore resolved bean in non-active scope
					return null;
				}
			}
			@Override
			public void ifAvailable(Consumer<T> dependencyConsumer) throws BeansException {
				T dependency = getIfAvailable();
				if (dependency != null) {
					try {
						dependencyConsumer.accept(dependency);
					}
					catch (ScopeNotActiveException ex) {
						// Ignore resolved bean in non-active scope, even on scoped proxy invocation
					}
				}
			}
			@Override
			@Nullable
			public T getIfUnique() throws BeansException {
				try {
					return resolveBean(requiredType, null, true);
				}
				catch (ScopeNotActiveException ex) {
					// Ignore resolved bean in non-active scope
					return null;
				}
			}
			@Override
			public void ifUnique(Consumer<T> dependencyConsumer) throws BeansException {
				T dependency = getIfUnique();
				if (dependency != null) {
					try {
						dependencyConsumer.accept(dependency);
					}
					catch (ScopeNotActiveException ex) {
						// Ignore resolved bean in non-active scope, even on scoped proxy invocation
					}
				}
			}
			@SuppressWarnings(""unchecked"")
			@Override
			public Stream<T> stream() {
				return Arrays.stream(beanNamesForStream(requiredType, true, allowEagerInit))
						.map(name -> (T) getBean(name))
						.filter(bean -> !(bean instanceof NullBean));
			}
			@SuppressWarnings(""unchecked"")
			@Override
			public Stream<T> orderedStream() {
				String[] beanNames = beanNamesForStream(requiredType, true, allowEagerInit);
				if (beanNames.length == 0) {
					return Stream.empty();
				}
				Map<String, T> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);
				for (String beanName : beanNames) {
					Object beanInstance = getBean(beanName);
					if (!(beanInstance instanceof NullBean)) {
						matchingBeans.put(beanName, (T) beanInstance);
					}
				}
				Stream<T> stream = matchingBeans.values().stream();
				return stream.sorted(adaptOrderComparator(matchingBeans));
			}
			@SuppressWarnings(""unchecked"")
			@Override
			public Stream<T> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {
				return Arrays.stream(beanNamesForStream(requiredType, includeNonSingletons, allowEagerInit))
						.filter(name -> customFilter.test(getType(name)))
						.map(name -> (T) getBean(name))
						.filter(bean -> !(bean instanceof NullBean));
			}
			@SuppressWarnings(""unchecked"")
			@Override
			public Stream<T> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {
				String[] beanNames = beanNamesForStream(requiredType, includeNonSingletons, allowEagerInit);
				if (beanNames.length == 0) {
					return Stream.empty();
				}
				Map<String, T> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);
				for (String beanName : beanNames) {
					if (customFilter.test(getType(beanName))) {
						Object beanInstance = getBean(beanName);
						if (!(beanInstance instanceof NullBean)) {
							matchingBeans.put(beanName, (T) beanInstance);
						}
					}
				}
				return matchingBeans.values().stream().sorted(adaptOrderComparator(matchingBeans));
			}
		};
	}

	@Nullable
	private <T> T resolveBean(ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) {
		NamedBeanHolder<T> namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);
		if (namedBean != null) {
			return namedBean.getBeanInstance();
		}
		BeanFactory parent = getParentBeanFactory();
		if (parent instanceof DefaultListableBeanFactory dlbf) {
			return dlbf.resolveBean(requiredType, args, nonUniqueAsNull);
		}
		else if (parent != null) {
			ObjectProvider<T> parentProvider = parent.getBeanProvider(requiredType);
			if (args != null) {
				return parentProvider.getObject(args);
			}
			else {
				return (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());
			}
		}
		return null;
	}

	private String[] beanNamesForStream(ResolvableType requiredType, boolean includeNonSingletons, boolean allowEagerInit) {
		return BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this, requiredType, includeNonSingletons, allowEagerInit);
	}

	@Override
	public String[] getBeanNamesForType(ResolvableType type) {
		return getBeanNamesForType(type, true, true);
	}

	@Override
	public String[] getBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {
		Class<?> resolved = type.resolve();
		if (resolved != null && !type.hasGenerics()) {
			return getBeanNamesForType(resolved, includeNonSingletons, allowEagerInit);
		}
		else {
			return doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);
		}
	}

	@Override
	public String[] getBeanNamesForType(@Nullable Class<?> type) {
		return getBeanNamesForType(type, true, true);
	}

	@Override
	public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {
		if (!isConfigurationFrozen() || type == null || !allowEagerInit) {
			return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);
		}
		Map<Class<?>, String[]> cache =
				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);
		String[] resolvedBeanNames = cache.get(type);
		if (resolvedBeanNames != null) {
			return resolvedBeanNames;
		}
		resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);
		if (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {
			cache.put(type, resolvedBeanNames);
		}
		return resolvedBeanNames;
	}

	private String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {
		List<String> result = new ArrayList<>();

		// Check all bean definitions.
		for (String beanName : this.beanDefinitionNames) {
			// Only consider bean as eligible if the bean name is not defined as alias for some other bean.
			if (!isAlias(beanName)) {
				try {
					RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
					// Only check bean definition if it is complete.
					if (!mbd.isAbstract() && (allowEagerInit ||
							(mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &&
									!requiresEagerInitForType(mbd.getFactoryBeanName()))) {
						boolean isFactoryBean = isFactoryBean(beanName, mbd);
						BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();
						boolean matchFound = false;
						boolean allowFactoryBeanInit = (allowEagerInit || containsSingleton(beanName));
						boolean isNonLazyDecorated = (dbd != null && !mbd.isLazyInit());
						if (!isFactoryBean) {
							if (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {
								matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);
							}
						}
						else {
							if (includeNonSingletons || isNonLazyDecorated) {
								matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);
							}
							else if (allowFactoryBeanInit) {
								// Type check before singleton check, avoiding FactoryBean instantiation
								// for early FactoryBean.isSingleton() calls on non-matching beans.
								matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit) &&
										isSingleton(beanName, mbd, dbd);
							}
							if (!matchFound) {
								// In case of FactoryBean, try to match FactoryBean instance itself next.
								beanName = FACTORY_BEAN_PREFIX + beanName;
								if (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {
									matchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);
								}
							}
						}
						if (matchFound) {
							result.add(beanName);
						}
					}
				}
				catch (CannotLoadBeanClassException | BeanDefinitionStoreException ex) {
					if (allowEagerInit) {
						throw ex;
					}
					// Probably a placeholder: let's ignore it for type matching purposes.
					LogMessage message = (ex instanceof CannotLoadBeanClassException ?
							LogMessage.format(""Ignoring bean class loading failure for bean '%s'"", beanName) :
							LogMessage.format(""Ignoring unresolvable metadata in bean definition '%s'"", beanName));
					logger.trace(message, ex);
					// Register exception, in case the bean was accidentally unresolvable.
					onSuppressedException(ex);
				}
				catch (NoSuchBeanDefinitionException ex) {
					// Bean definition got removed while we were iterating -> ignore.
				}
			}
		}

		// Check manually registered singletons too.
		for (String beanName : this.manualSingletonNames) {
			try {
				// In case of FactoryBean, match object created by FactoryBean.
				if (isFactoryBean(beanName)) {
					if ((includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type)) {
						result.add(beanName);
						// Match found for this bean: do not match FactoryBean itself anymore.
						continue;
					}
					// In case of FactoryBean, try to match FactoryBean itself next.
					beanName = FACTORY_BEAN_PREFIX + beanName;
				}
				// Match raw bean instance (might be raw FactoryBean).
				if (isTypeMatch(beanName, type)) {
					result.add(beanName);
				}
			}
			catch (NoSuchBeanDefinitionException ex) {
				// Shouldn't happen - probably a result of circular reference resolution...
				logger.trace(LogMessage.format(
						""Failed to check manually registered singleton with name '%s'"", beanName), ex);
			}
		}

		return StringUtils.toStringArray(result);
	}

	private boolean isSingleton(String beanName, RootBeanDefinition mbd, @Nullable BeanDefinitionHolder dbd) {
		return (dbd != null ? mbd.isSingleton() : isSingleton(beanName));
	}

	/**
	 * Check whether the specified bean would need to be eagerly initialized
	 * in order to determine its type.
	 * @param factoryBeanName a factory-bean reference that the bean definition
	 * defines a factory method for
	 * @return whether eager initialization is necessary
	 */
	private boolean requiresEagerInitForType(@Nullable String factoryBeanName) {
		return (factoryBeanName != null && isFactoryBean(factoryBeanName) && !containsSingleton(factoryBeanName));
	}

	@Override
	public <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException {
		return getBeansOfType(type, true, true);
	}

	@Override
	@SuppressWarnings(""unchecked"")
	public <T> Map<String, T> getBeansOfType(
			@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException {

		String[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);
		Map<String, T> result = CollectionUtils.newLinkedHashMap(beanNames.length);
		for (String beanName : beanNames) {
			try {
				Object beanInstance = getBean(beanName);
				if (!(beanInstance instanceof NullBean)) {
					result.put(beanName, (T) beanInstance);
				}
			}
			catch (BeanCreationException ex) {
				Throwable rootCause = ex.getMostSpecificCause();
				if (rootCause instanceof BeanCurrentlyInCreationException bce) {
					String exBeanName = bce.getBeanName();
					if (exBeanName != null && isCurrentlyInCreation(exBeanName)) {
						if (logger.isTraceEnabled()) {
							logger.trace(""Ignoring match to currently created bean '"" + exBeanName + ""': "" +
									ex.getMessage());
						}
						onSuppressedException(ex);
						// Ignore: indicates a circular reference when autowiring constructors.
						// We want to find matches other than the currently created bean itself.
						continue;
					}
				}
				throw ex;
			}
		}
		return result;
	}

	@Override
	public String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType) {
		List<String> result = new ArrayList<>();
		for (String beanName : this.beanDefinitionNames) {
			BeanDefinition bd = this.beanDefinitionMap.get(beanName);
			if (bd != null && !bd.isAbstract() && findAnnotationOnBean(beanName, annotationType) != null) {
				result.add(beanName);
			}
		}
		for (String beanName : this.manualSingletonNames) {
			if (!result.contains(beanName) && findAnnotationOnBean(beanName, annotationType) != null) {
				result.add(beanName);
			}
		}
		return StringUtils.toStringArray(result);
	}

	@Override
	public Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) {
		String[] beanNames = getBeanNamesForAnnotation(annotationType);
		Map<String, Object> result = CollectionUtils.newLinkedHashMap(beanNames.length);
		for (String beanName : beanNames) {
			Object beanInstance = getBean(beanName);
			if (!(beanInstance instanceof NullBean)) {
				result.put(beanName, beanInstance);
			}
		}
		return result;
	}

	@Override
	@Nullable
	public <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)
			throws NoSuchBeanDefinitionException {

		return findAnnotationOnBean(beanName, annotationType, true);
	}

	@Override
	@Nullable
	public <A extends Annotation> A findAnnotationOnBean(
			String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)
			throws NoSuchBeanDefinitionException {

		Class<?> beanType = getType(beanName, allowFactoryBeanInit);
		if (beanType != null) {
			MergedAnnotation<A> annotation =
					MergedAnnotations.from(beanType, SearchStrategy.TYPE_HIERARCHY).get(annotationType);
			if (annotation.isPresent()) {
				return annotation.synthesize();
			}
		}
		if (containsBeanDefinition(beanName)) {
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			// Check raw bean class, for example, in case of a proxy.
			if (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {
				Class<?> beanClass = bd.getBeanClass();
				if (beanClass != beanType) {
					MergedAnnotation<A> annotation =
							MergedAnnotations.from(beanClass, SearchStrategy.TYPE_HIERARCHY).get(annotationType);
					if (annotation.isPresent()) {
						return annotation.synthesize();
					}
				}
			}
			// Check annotations declared on factory method, if any.
			Method factoryMethod = bd.getResolvedFactoryMethod();
			if (factoryMethod != null) {
				MergedAnnotation<A> annotation =
						MergedAnnotations.from(factoryMethod, SearchStrategy.TYPE_HIERARCHY).get(annotationType);
				if (annotation.isPresent()) {
					return annotation.synthesize();
				}
			}
		}
		return null;
	}

	@Override
	public <A extends Annotation> Set<A> findAllAnnotationsOnBean(
			String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)
			throws NoSuchBeanDefinitionException {

		Set<A> annotations = new LinkedHashSet<>();
		Class<?> beanType = getType(beanName, allowFactoryBeanInit);
		if (beanType != null) {
			MergedAnnotations.from(beanType, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)
					.stream(annotationType)
					.filter(MergedAnnotation::isPresent)
					.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));
		}
		if (containsBeanDefinition(beanName)) {
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
			// Check raw bean class, for example, in case of a proxy.
			if (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {
				Class<?> beanClass = bd.getBeanClass();
				if (beanClass != beanType) {
					MergedAnnotations.from(beanClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)
							.stream(annotationType)
							.filter(MergedAnnotation::isPresent)
							.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));
				}
			}
			// Check annotations declared on factory method, if any.
			Method factoryMethod = bd.getResolvedFactoryMethod();
			if (factoryMethod != null) {
				MergedAnnotations.from(factoryMethod, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)
						.stream(annotationType)
						.filter(MergedAnnotation::isPresent)
						.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));
			}
		}
		return annotations;
	}


	//---------------------------------------------------------------------
	// Implementation of ConfigurableListableBeanFactory interface
	//---------------------------------------------------------------------

	@Override
	public void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue) {
		Assert.notNull(dependencyType, ""Dependency type must not be null"");
		if (autowiredValue != null) {
			if (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {
				throw new IllegalArgumentException(""Value ["" + autowiredValue +
						""] does not implement specified dependency type ["" + dependencyType.getName() + ""]"");
			}
			this.resolvableDependencies.put(dependencyType, autowiredValue);
		}
	}

	@Override
	public boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)
			throws NoSuchBeanDefinitionException {

		return isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());
	}

	/**
	 * Determine whether the specified bean definition qualifies as an autowire candidate,
	 * to be injected into other beans which declare a dependency of matching type.
	 * @param beanName the name of the bean definition to check
	 * @param descriptor the descriptor of the dependency to resolve
	 * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm
	 * @return whether the bean should be considered as autowire candidate
	 */
	protected boolean isAutowireCandidate(
			String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)
			throws NoSuchBeanDefinitionException {

		String bdName = transformedBeanName(beanName);
		if (containsBeanDefinition(bdName)) {
			return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver);
		}
		else if (containsSingleton(beanName)) {
			return isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);
		}

		BeanFactory parent = getParentBeanFactory();
		if (parent instanceof DefaultListableBeanFactory dlbf) {
			// No bean definition found in this factory -> delegate to parent.
			return dlbf.isAutowireCandidate(beanName, descriptor, resolver);
		}
		else if (parent instanceof ConfigurableListableBeanFactory clbf) {
			// If no DefaultListableBeanFactory, can't pass the resolver along.
			return clbf.isAutowireCandidate(beanName, descriptor);
		}
		else {
			return true;
		}
	}

	/**
	 * Determine whether the specified bean definition qualifies as an autowire candidate,
	 * to be injected into other beans which declare a dependency of matching type.
	 * @param beanName the name of the bean definition to check
	 * @param mbd the merged bean definition to check
	 * @param descriptor the descriptor of the dependency to resolve
	 * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm
	 * @return whether the bean should be considered as autowire candidate
	 */
	protected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,
			DependencyDescriptor descriptor, AutowireCandidateResolver resolver) {

		String bdName = transformedBeanName(beanName);
		resolveBeanClass(mbd, bdName);
		if (mbd.isFactoryMethodUnique && mbd.factoryMethodToIntrospect == null) {
			new ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);
		}
		BeanDefinitionHolder holder = (beanName.equals(bdName) ?
				this.mergedBeanDefinitionHolders.computeIfAbsent(beanName,
						key -> new BeanDefinitionHolder(mbd, beanName, getAliases(bdName))) :
				new BeanDefinitionHolder(mbd, beanName, getAliases(bdName)));
		return resolver.isAutowireCandidate(holder, descriptor);
	}

	@Override
	public BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
		BeanDefinition bd = this.beanDefinitionMap.get(beanName);
		if (bd == null) {
			if (logger.isTraceEnabled()) {
				logger.trace(""No bean named '"" + beanName + ""' found in "" + this);
			}
			throw new NoSuchBeanDefinitionException(beanName);
		}
		return bd;
	}

	@Override
	public Iterator<String> getBeanNamesIterator() {
		CompositeIterator<String> iterator = new CompositeIterator<>();
		iterator.add(this.beanDefinitionNames.iterator());
		iterator.add(this.manualSingletonNames.iterator());
		return iterator;
	}

	@Override
	protected void clearMergedBeanDefinition(String beanName) {
		super.clearMergedBeanDefinition(beanName);
		this.mergedBeanDefinitionHolders.remove(beanName);
	}

	@Override
	public void clearMetadataCache() {
		super.clearMetadataCache();
		this.mergedBeanDefinitionHolders.clear();
		clearByTypeCache();
	}

	@Override
	public void freezeConfiguration() {
		clearMetadataCache();
		this.configurationFrozen = true;
		this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);
	}

	@Override
	public boolean isConfigurationFrozen() {
		return this.configurationFrozen;
	}

	/**
	 * Considers all beans as eligible for metadata caching
	 * if the factory's configuration has been marked as frozen.
	 * @see #freezeConfiguration()
	 */
	@Override
	protected boolean isBeanEligibleForMetadataCaching(String beanName) {
		return (this.configurationFrozen || super.isBeanEligibleForMetadataCaching(beanName));
	}

	@Override
	@Nullable
	protected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)
			throws Exception {

		if (supplier instanceof InstanceSupplier<?> instanceSupplier) {
			return instanceSupplier.get(RegisteredBean.of(this, beanName, mbd));
		}
		return super.obtainInstanceFromSupplier(supplier, beanName, mbd);
	}

	@Override
	protected void cacheMergedBeanDefinition(RootBeanDefinition mbd, String beanName) {
		super.cacheMergedBeanDefinition(mbd, beanName);
		if (mbd.isPrimary()) {
			this.primaryBeanNamesWithType.put(beanName, Void.class);
		}
	}

	@Override
	protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args) {
		super.checkMergedBeanDefinition(mbd, beanName, args);

		if (mbd.isBackgroundInit()) {
			if (this.preInstantiationThread.get() == PreInstantiation.MAIN && getBootstrapExecutor() != null) {
				throw new BeanCurrentlyInCreationException(beanName, ""Bean marked for background "" +
						""initialization but requested in mainline thread - declare ObjectProvider "" +
						""or lazy injection point in dependent mainline beans"");
			}
		}
		else {
			// Bean intended to be initialized in main bootstrap thread.
			if (this.preInstantiationThread.get() == PreInstantiation.BACKGROUND) {
				throw new BeanCurrentlyInCreationException(beanName, ""Bean marked for mainline initialization "" +
						""but requested in background thread - enforce early instantiation in mainline thread "" +
						""through depends-on '"" + beanName + ""' declaration for dependent background beans"");
			}
		}
	}

	@Override
	@Nullable
	protected Boolean isCurrentThreadAllowedToHoldSingletonLock() {
		String mainThreadPrefix = this.mainThreadPrefix;
		if (mainThreadPrefix != null) {
			// We only differentiate in the preInstantiateSingletons phase, using
			// the volatile mainThreadPrefix field as an indicator for that phase.

			PreInstantiation preInstantiation = this.preInstantiationThread.get();
			if (preInstantiation != null) {
				// A Spring-managed bootstrap thread:
				// MAIN is allowed to lock (true) or even forced to lock (null),
				// BACKGROUND is never allowed to lock (false).
				return switch (preInstantiation) {
					case MAIN -> (Boolean.TRUE.equals(this.strictLocking) ? null : true);
					case BACKGROUND -> false;
				};
			}

			// Not a Spring-managed bootstrap thread...
			if (Boolean.FALSE.equals(this.strictLocking)) {
				// Explicitly configured to use lenient locking wherever possible.
				return true;
			}
			else if (this.strictLocking == null) {
				// No explicit locking configuration -> infer appropriate locking.
				if (!getThreadNamePrefix().equals(mainThreadPrefix)) {
					// An unmanaged thread (assumed to be application-internal) with lenient locking,
					// and not part of the same thread pool that provided the main bootstrap thread
					// (excluding scenarios where we are hit by multiple external bootstrap threads).
					return true;
				}
			}
		}

		// Traditional behavior: forced to always hold a full lock.
		return null;
	}

	@Override
	public void preInstantiateSingletons() throws BeansException {
		if (logger.isTraceEnabled()) {
			logger.trace(""Pre-instantiating singletons in "" + this);
		}

		// Iterate over a copy to allow for init methods which in turn register new bean definitions.
		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.
		List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

		// Trigger initialization of all non-lazy singleton beans...
		this.preInstantiationThread.set(PreInstantiation.MAIN);
		this.mainThreadPrefix = getThreadNamePrefix();
		try {
			List<CompletableFuture<?>> futures = new ArrayList<>();
			for (String beanName : beanNames) {
				RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				if (!mbd.isAbstract() && mbd.isSingleton()) {
					CompletableFuture<?> future = preInstantiateSingleton(beanName, mbd);
					if (future != null) {
						futures.add(future);
					}
				}
			}
			if (!futures.isEmpty()) {
				try {
					CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[0])).join();
				}
				catch (CompletionException ex) {
					ReflectionUtils.rethrowRuntimeException(ex.getCause());
				}
			}
		}
		finally {
			this.mainThreadPrefix = null;
			this.preInstantiationThread.remove();
		}

		// Trigger post-initialization callback for all applicable beans...
		for (String beanName : beanNames) {
			Object singletonInstance = getSingleton(beanName, false);
			if (singletonInstance instanceof SmartInitializingSingleton smartSingleton) {
				StartupStep smartInitialize = getApplicationStartup().start(""spring.beans.smart-initialize"")
						.tag(""beanName"", beanName);
				smartSingleton.afterSingletonsInstantiated();
				smartInitialize.end();
			}
		}
	}

	@Nullable
	private CompletableFuture<?> preInstantiateSingleton(String beanName, RootBeanDefinition mbd) {
		if (mbd.isBackgroundInit()) {
			Executor executor = getBootstrapExecutor();
			if (executor != null) {
				String[] dependsOn = mbd.getDependsOn();
				if (dependsOn != null) {
					for (String dep : dependsOn) {
						getBean(dep);
					}
				}
				CompletableFuture<?> future = CompletableFuture.runAsync(
						() -> instantiateSingletonInBackgroundThread(beanName), executor);
				addSingletonFactory(beanName, () -> {
					try {
						future.join();
					}
					catch (CompletionException ex) {
						ReflectionUtils.rethrowRuntimeException(ex.getCause());
					}
					return future;  // not to be exposed, just to lead to ClassCastException in case of mismatch
				});
				return (!mbd.isLazyInit() ? future : null);
			}
			else if (logger.isInfoEnabled()) {
				logger.info(""Bean '"" + beanName + ""' marked for background initialization "" +
						""without bootstrap executor configured - falling back to mainline initialization"");
			}
		}

		if (!mbd.isLazyInit()) {
			try {
				instantiateSingleton(beanName);
			}
			catch (BeanCurrentlyInCreationException ex) {
				logger.info(""Bean '"" + beanName + ""' marked for pre-instantiation (not lazy-init) "" +
						""but currently initialized by other thread - skipping it in mainline thread"");
			}
		}
		return null;
	}

	private void instantiateSingletonInBackgroundThread(String beanName) {
		this.preInstantiationThread.set(PreInstantiation.BACKGROUND);
		try {
			instantiateSingleton(beanName);
		}
		catch (RuntimeException | Error ex) {
			if (logger.isWarnEnabled()) {
				logger.warn(""Failed to instantiate singleton bean '"" + beanName + ""' in background thread"", ex);
			}
			throw ex;
		}
		finally {
			this.preInstantiationThread.remove();
		}
	}

	private void instantiateSingleton(String beanName) {
		if (isFactoryBean(beanName)) {
			Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
			if (bean instanceof SmartFactoryBean<?> smartFactoryBean && smartFactoryBean.isEagerInit()) {
				getBean(beanName);
			}
		}
		else {
			getBean(beanName);
		}
	}

	private static String getThreadNamePrefix() {
		String name = Thread.currentThread().getName();
		int numberSeparator = name.lastIndexOf('-');
		return (numberSeparator >= 0 ? name.substring(0, numberSeparator) : name);
	}


	//---------------------------------------------------------------------
	// Implementation of BeanDefinitionRegistry interface
	//---------------------------------------------------------------------

	@Override
	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException {

		Assert.hasText(beanName, ""Bean name must not be empty"");
		Assert.notNull(beanDefinition, ""BeanDefinition must not be null"");

		if (beanDefinition instanceof AbstractBeanDefinition abd) {
			try {
				abd.validate();
			}
			catch (BeanDefinitionValidationException ex) {
				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						""Validation of bean definition failed"", ex);
			}
		}

		BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
		if (existingDefinition != null) {
			if (!isBeanDefinitionOverridable(beanName)) {
				throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
			}
			else {
				logBeanDefinitionOverriding(beanName, beanDefinition, existingDefinition);
			}
			this.beanDefinitionMap.put(beanName, beanDefinition);
		}
		else {
			if (isAlias(beanName)) {
				String aliasedName = canonicalName(beanName);
				if (!isBeanDefinitionOverridable(aliasedName)) {
					if (containsBeanDefinition(aliasedName)) {  // alias for existing bean definition
						throw new BeanDefinitionOverrideException(
								beanName, beanDefinition, getBeanDefinition(aliasedName));
					}
					else {  // alias pointing to non-existing bean definition
						throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
								""Cannot register bean definition for bean '"" + beanName +
								""' since there is already an alias for bean '"" + aliasedName + ""' bound."");
					}
				}
				else {
					if (logger.isInfoEnabled()) {
						logger.info(""Removing alias '"" + beanName + ""' for bean '"" + aliasedName +
								""' due to registration of bean definition for bean '"" + beanName + ""': ["" +
								beanDefinition + ""]"");
					}
					removeAlias(beanName);
				}
			}
			if (hasBeanCreationStarted()) {
				// Cannot modify startup-time collection elements anymore (for stable iteration)
				synchronized (this.beanDefinitionMap) {
					this.beanDefinitionMap.put(beanName, beanDefinition);
					List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
					updatedDefinitions.addAll(this.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					this.beanDefinitionNames = updatedDefinitions;
					removeManualSingletonName(beanName);
				}
			}
			else {
				// Still in startup registration phase
				this.beanDefinitionMap.put(beanName, beanDefinition);
				this.beanDefinitionNames.add(beanName);
				removeManualSingletonName(beanName);
			}
			this.frozenBeanDefinitionNames = null;
		}

		if (existingDefinition != null || containsSingleton(beanName)) {
			resetBeanDefinition(beanName);
		}
		else if (isConfigurationFrozen()) {
			clearByTypeCache();
		}

		// Cache a primary marker for the given bean.
		if (beanDefinition.isPrimary()) {
			this.primaryBeanNamesWithType.put(beanName, Void.class);
		}
	}

	private void logBeanDefinitionOverriding(String beanName, BeanDefinition beanDefinition,
			BeanDefinition existingDefinition) {

		boolean explicitBeanOverride = (this.allowBeanDefinitionOverriding != null);
		if (existingDefinition.getRole() < beanDefinition.getRole()) {
			// for example, was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
			if (logger.isInfoEnabled()) {
				logger.info(""Overriding user-defined bean definition for bean '"" + beanName +
						""' with a framework-generated bean definition: replacing ["" +
						existingDefinition + ""] with ["" + beanDefinition + ""]"");
			}
		}
		else if (!beanDefinition.equals(existingDefinition)) {
			if (explicitBeanOverride && logger.isInfoEnabled()) {
				logger.info(""Overriding bean definition for bean '"" + beanName +
						""' with a different definition: replacing ["" + existingDefinition +
						""] with ["" + beanDefinition + ""]"");
			}
			if (logger.isDebugEnabled()) {
				logger.debug(""Overriding bean definition for bean '"" + beanName +
						""' with a different definition: replacing ["" + existingDefinition +
						""] with ["" + beanDefinition + ""]"");
			}
		}
		else {
			if (explicitBeanOverride && logger.isInfoEnabled()) {
				logger.info(""Overriding bean definition for bean '"" + beanName +
						""' with an equivalent definition: replacing ["" + existingDefinition +
						""] with ["" + beanDefinition + ""]"");
			}
			if (logger.isTraceEnabled()) {
				logger.trace(""Overriding bean definition for bean '"" + beanName +
						""' with an equivalent definition: replacing ["" + existingDefinition +
						""] with ["" + beanDefinition + ""]"");
			}
		}
	}

	@Override
	public void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {
		Assert.hasText(beanName, ""'beanName' must not be empty"");

		BeanDefinition bd = this.beanDefinitionMap.remove(beanName);
		if (bd == null) {
			if (logger.isTraceEnabled()) {
				logger.trace(""No bean named '"" + beanName + ""' found in "" + this);
			}
			throw new NoSuchBeanDefinitionException(beanName);
		}

		if (hasBeanCreationStarted()) {
			// Cannot modify startup-time collection elements anymore (for stable iteration)
			synchronized (this.beanDefinitionMap) {
				List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames);
				updatedDefinitions.remove(beanName);
				this.beanDefinitionNames = updatedDefinitions;
			}
		}
		else {
			// Still in startup registration phase
			this.beanDefinitionNames.remove(beanName);
		}
		this.frozenBeanDefinitionNames = null;

		resetBeanDefinition(beanName);
	}

	/**
	 * Reset all bean definition caches for the given bean,
	 * including the caches of beans that are derived from it.
	 * <p>Called after an existing bean definition has been replaced or removed,
	 * triggering {@link #clearMergedBeanDefinition}, {@link #destroySingleton}
	 * and {@link MergedBeanDefinitionPostProcessor#resetBeanDefinition} on the
	 * given bean and on all bean definitions that have the given bean as parent.
	 * @param beanName the name of the bean to reset
	 * @see #registerBeanDefinition
	 * @see #removeBeanDefinition
	 */
	protected void resetBeanDefinition(String beanName) {
		// Remove the merged bean definition for the given bean, if already created.
		clearMergedBeanDefinition(beanName);

		// Remove corresponding bean from singleton cache, if any. Shouldn't usually
		// be necessary, rather just meant for overriding a context's default beans
		// (for example, the default StaticMessageSource in a StaticApplicationContext).
		destroySingleton(beanName);

		// Remove a cached primary marker for the given bean.
		this.primaryBeanNamesWithType.remove(beanName);

		// Notify all post-processors that the specified bean definition has been reset.
		for (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {
			processor.resetBeanDefinition(beanName);
		}

		// Reset all bean definitions that have the given bean as parent (recursively).
		for (String bdName : this.beanDefinitionNames) {
			if (!beanName.equals(bdName)) {
				BeanDefinition bd = this.beanDefinitionMap.get(bdName);
				// Ensure bd is non-null due to potential concurrent modification of beanDefinitionMap.
				if (bd != null && beanName.equals(bd.getParentName())) {
					resetBeanDefinition(bdName);
				}
			}
		}
	}

	/**
	 * This implementation returns {@code true} if bean definition overriding
	 * is generally allowed.
	 * @see #setAllowBeanDefinitionOverriding
	 */
	@Override
	public boolean isBeanDefinitionOverridable(String beanName) {
		return isAllowBeanDefinitionOverriding();
	}

	/**
	 * Only allows alias overriding if bean definition overriding is allowed.
	 * @see #setAllowBeanDefinitionOverriding
	 */
	@Override
	protected boolean allowAliasOverriding() {
		return isAllowBeanDefinitionOverriding();
	}

	/**
	 * Also checks for an alias overriding a bean definition of the same name.
	 */
	@Override
	protected void checkForAliasCircle(String name, String alias) {
		super.checkForAliasCircle(name, alias);
		if (!isBeanDefinitionOverridable(alias) && containsBeanDefinition(alias)) {
			throw new IllegalStateException(""Cannot register alias '"" + alias +
					""' for name '"" + name + ""': Alias would override bean definition '"" + alias + ""'"");
		}
	}

	@Override
	protected void addSingleton(String beanName, Object singletonObject) {
		super.addSingleton(beanName, singletonObject);

		Predicate<Class<?>> filter = (beanType -> beanType != Object.class && beanType.isInstance(singletonObject));
		this.allBeanNamesByType.keySet().removeIf(filter);
		this.singletonBeanNamesByType.keySet().removeIf(filter);

		if (this.primaryBeanNamesWithType.containsKey(beanName) && singletonObject.getClass() != NullBean.class) {
			Class<?> beanType = (singletonObject instanceof FactoryBean<?> fb ?
					getTypeForFactoryBean(fb) : singletonObject.getClass());
			if (beanType != null) {
				this.primaryBeanNamesWithType.put(beanName, beanType);
			}
		}
	}

	@Override
	public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {
		super.registerSingleton(beanName, singletonObject);
		updateManualSingletonNames(set -> set.add(beanName), set -> !this.beanDefinitionMap.containsKey(beanName));
	}

	@Override
	public void destroySingletons() {
		super.destroySingletons();
		updateManualSingletonNames(Set::clear, set -> !set.isEmpty());
		clearByTypeCache();
	}

	@Override
	public void destroySingleton(String beanName) {
		super.destroySingleton(beanName);
		removeManualSingletonName(beanName);
		clearByTypeCache();
	}

	private void removeManualSingletonName(String beanName) {
		updateManualSingletonNames(set -> set.remove(beanName), set -> set.contains(beanName));
	}

	/**
	 * Update the factory's internal set of manual singleton names.
	 * @param action the modification action
	 * @param condition a precondition for the modification action
	 * (if this condition does not apply, the action can be skipped)
	 */
	private void updateManualSingletonNames(Consumer<Set<String>> action, Predicate<Set<String>> condition) {
		if (hasBeanCreationStarted()) {
			// Cannot modify startup-time collection elements anymore (for stable iteration)
			synchronized (this.beanDefinitionMap) {
				if (condition.test(this.manualSingletonNames)) {
					Set<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames);
					action.accept(updatedSingletons);
					this.manualSingletonNames = updatedSingletons;
				}
			}
		}
		else {
			// Still in startup registration phase
			if (condition.test(this.manualSingletonNames)) {
				action.accept(this.manualSingletonNames);
			}
		}
	}

	/**
	 * Remove any assumptions about by-type mappings.
	 */
	private void clearByTypeCache() {
		this.allBeanNamesByType.clear();
		this.singletonBeanNamesByType.clear();
	}


	//---------------------------------------------------------------------
	// Dependency resolution functionality
	//---------------------------------------------------------------------

	@Override
	public <T> NamedBeanHolder<T> resolveNamedBean(Class<T> requiredType) throws BeansException {
		Assert.notNull(requiredType, ""Required type must not be null"");
		NamedBeanHolder<T> namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), null, false);
		if (namedBean != null) {
			return namedBean;
		}
		BeanFactory parent = getParentBeanFactory();
		if (parent instanceof AutowireCapableBeanFactory acbf) {
			return acbf.resolveNamedBean(requiredType);
		}
		throw new NoSuchBeanDefinitionException(requiredType);
	}

	@SuppressWarnings(""unchecked"")
	@Nullable
	private <T> NamedBeanHolder<T> resolveNamedBean(
			ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) throws BeansException {

		Assert.notNull(requiredType, ""Required type must not be null"");
		String[] candidateNames = getBeanNamesForType(requiredType);

		if (candidateNames.length > 1) {
			List<String> autowireCandidates = new ArrayList<>(candidateNames.length);
			for (String beanName : candidateNames) {
				if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {
					autowireCandidates.add(beanName);
				}
			}
			if (!autowireCandidates.isEmpty()) {
				candidateNames = StringUtils.toStringArray(autowireCandidates);
			}
		}

		if (candidateNames.length == 1) {
			return resolveNamedBean(candidateNames[0], requiredType, args);
		}
		else if (candidateNames.length > 1) {
			Map<String, Object> candidates = CollectionUtils.newLinkedHashMap(candidateNames.length);
			for (String beanName : candidateNames) {
				if (containsSingleton(beanName) && args == null) {
					Object beanInstance = getBean(beanName);
					candidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));
				}
				else {
					candidates.put(beanName, getType(beanName));
				}
			}
			String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());
			if (candidateName == null) {
				candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());
			}
			if (candidateName == null) {
				candidateName = determineDefaultCandidate(candidates);
			}
			if (candidateName != null) {
				Object beanInstance = candidates.get(candidateName);
				if (beanInstance == null) {
					return null;
				}
				if (beanInstance instanceof Class) {
					return resolveNamedBean(candidateName, requiredType, args);
				}
				return new NamedBeanHolder<>(candidateName, (T) beanInstance);
			}
			if (!nonUniqueAsNull) {
				throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());
			}
		}

		return null;
	}

	@Nullable
	private <T> NamedBeanHolder<T> resolveNamedBean(
			String beanName, ResolvableType requiredType, @Nullable Object[] args) throws BeansException {

		Object bean = getBean(beanName, null, args);
		if (bean instanceof NullBean) {
			return null;
		}
		return new NamedBeanHolder<>(beanName, adaptBeanInstance(beanName, bean, requiredType.toClass()));
	}

	@Override
	@Nullable
	public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

		descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
		if (Optional.class == descriptor.getDependencyType()) {
			return createOptionalDependency(descriptor, requestingBeanName);
		}
		else if (ObjectFactory.class == descriptor.getDependencyType() ||
				ObjectProvider.class == descriptor.getDependencyType()) {
			return new DependencyObjectProvider(descriptor, requestingBeanName);
		}
		else if (jakartaInjectProviderClass == descriptor.getDependencyType()) {
			return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
		}
		else if (descriptor.supportsLazyResolution()) {
			Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
					descriptor, requestingBeanName);
			if (result != null) {
				return result;
			}
		}
		return doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
	}

	@Nullable
	@SuppressWarnings(""NullAway"")
	public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

		InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
		try {
			// Step 1: pre-resolved shortcut for single bean match, for example, from @Autowired
			Object shortcut = descriptor.resolveShortcut(this);
			if (shortcut != null) {
				return shortcut;
			}

			Class<?> type = descriptor.getDependencyType();

			// Step 2: pre-defined value or expression, for example, from @Value
			Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
			if (value != null) {
				if (value instanceof String strValue) {
					String resolvedValue = resolveEmbeddedValue(strValue);
					BeanDefinition bd = (beanName != null && containsBean(beanName) ?
							getMergedBeanDefinition(beanName) : null);
					value = evaluateBeanDefinitionString(resolvedValue, bd);
				}
				TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
				try {
					return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
				}
				catch (UnsupportedOperationException ex) {
					// A custom TypeConverter which does not support TypeDescriptor resolution...
					return (descriptor.getField() != null ?
							converter.convertIfNecessary(value, type, descriptor.getField()) :
							converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
				}
			}

			// Step 3: shortcut for declared dependency name or qualifier-suggested name matching target bean name
			if (descriptor.usesStandardBeanLookup()) {
				String dependencyName = descriptor.getDependencyName();
				if (dependencyName == null || !containsBean(dependencyName)) {
					String suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);
					dependencyName = (suggestedName != null && containsBean(suggestedName) ? suggestedName : null);
				}
				if (dependencyName != null) {
					dependencyName = canonicalName(dependencyName);  // dependency name can be alias of target name
					if (isTypeMatch(dependencyName, type) && isAutowireCandidate(dependencyName, descriptor) &&
							!isFallback(dependencyName) && !hasPrimaryConflict(dependencyName, type) &&
							!isSelfReference(beanName, dependencyName)) {
						if (autowiredBeanNames != null) {
							autowiredBeanNames.add(dependencyName);
						}
						boolean preExisting = containsSingleton(dependencyName);
						Object dependencyBean = getBean(dependencyName);
						if (preExisting && dependencyBean instanceof NullBean) {
							// for backwards compatibility with addCandidateEntry in the regular code path
							dependencyBean = null;
						}
						return resolveInstance(dependencyBean, descriptor, type, dependencyName);
					}
				}
			}

			// Step 4a: multiple beans as stream / array / standard collection / plain map
			Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
			if (multipleBeans != null) {
				return multipleBeans;
			}
			// Step 4b: direct bean matches, possibly direct beans of type Collection / Map
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
			if (matchingBeans.isEmpty()) {
				// Step 4c (fallback): custom Collection / Map declarations for collecting multiple beans
				multipleBeans = resolveMultipleBeansFallback(descriptor, beanName, autowiredBeanNames, typeConverter);
				if (multipleBeans != null) {
					return multipleBeans;
				}
				// Raise exception if nothing found for required injection point
				if (isRequired(descriptor)) {
					raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
				}
				return null;
			}

			String autowiredBeanName;
			Object instanceCandidate;

			// Step 5: determine single candidate
			if (matchingBeans.size() > 1) {
				autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
				if (autowiredBeanName == null) {
					if (isRequired(descriptor) || !indicatesArrayCollectionOrMap(type)) {
						// Raise exception if no clear match found for required injection point
						return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
					}
					else {
						// In case of an optional Collection/Map, silently ignore a non-unique case:
						// possibly it was meant to be an empty collection of multiple regular beans
						// (before 4.3 in particular when we didn't even look for collection beans).
						return null;
					}
				}
				instanceCandidate = matchingBeans.get(autowiredBeanName);
			}
			else {
				// We have exactly one match.
				Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
				autowiredBeanName = entry.getKey();
				instanceCandidate = entry.getValue();
			}

			// Step 6: validate single result
			if (autowiredBeanNames != null) {
				autowiredBeanNames.add(autowiredBeanName);
			}
			if (instanceCandidate instanceof Class) {
				instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
			}
			return resolveInstance(instanceCandidate, descriptor, type, autowiredBeanName);
		}
		finally {
			ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
		}
	}

	@Nullable
	private Object resolveInstance(Object candidate, DependencyDescriptor descriptor, Class<?> type, String name) {
		Object result = candidate;
		if (result instanceof NullBean) {
			// Raise exception if null encountered for required injection point
			if (isRequired(descriptor)) {
				raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
			}
			result = null;
		}
		if (!ClassUtils.isAssignableValue(type, result)) {
			throw new BeanNotOfRequiredTypeException(name, type, candidate.getClass());
		}
		return result;
	}

	@Nullable
	private Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

		Class<?> type = descriptor.getDependencyType();

		if (descriptor instanceof StreamDependencyDescriptor streamDependencyDescriptor) {
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
			if (autowiredBeanNames != null) {
				autowiredBeanNames.addAll(matchingBeans.keySet());
			}
			Stream<Object> stream = matchingBeans.keySet().stream()
					.map(name -> descriptor.resolveCandidate(name, type, this))
					.filter(bean -> !(bean instanceof NullBean));
			if (streamDependencyDescriptor.isOrdered()) {
				stream = stream.sorted(adaptOrderComparator(matchingBeans));
			}
			return stream;
		}
		else if (type.isArray()) {
			Class<?> componentType = type.componentType();
			ResolvableType resolvableType = descriptor.getResolvableType();
			Class<?> resolvedArrayType = resolvableType.resolve(type);
			if (resolvedArrayType != type) {
				componentType = resolvableType.getComponentType().resolve();
			}
			if (componentType == null) {
				return null;
			}
			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType,
					new MultiElementDescriptor(descriptor));
			if (matchingBeans.isEmpty()) {
				return null;
			}
			if (autowiredBeanNames != null) {
				autowiredBeanNames.addAll(matchingBeans.keySet());
			}
			TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
			Object result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);
			if (result instanceof Object[] array && array.length > 1) {
				Comparator<Object> comparator = adaptDependencyComparator(matchingBeans);
				if (comparator != null) {
					Arrays.sort(array, comparator);
				}
			}
			return result;
		}
		else if (Collection.class == type || Set.class == type || List.class == type) {
			return resolveMultipleBeanCollection(descriptor, beanName, autowiredBeanNames, typeConverter);
		}
		else if (Map.class == type) {
			return resolveMultipleBeanMap(descriptor, beanName, autowiredBeanNames, typeConverter);
		}
		return null;
	}


	@Nullable
	private Object resolveMultipleBeansFallback(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

		Class<?> type = descriptor.getDependencyType();

		if (Collection.class.isAssignableFrom(type) && type.isInterface()) {
			return resolveMultipleBeanCollection(descriptor, beanName, autowiredBeanNames, typeConverter);
		}
		else if (Map.class.isAssignableFrom(type) && type.isInterface()) {
			return resolveMultipleBeanMap(descriptor, beanName, autowiredBeanNames, typeConverter);
		}
		return null;
	}

	@Nullable
	private Object resolveMultipleBeanCollection(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

		Class<?> elementType = descriptor.getResolvableType().asCollection().resolveGeneric();
		if (elementType == null) {
			return null;
		}
		Map<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType,
				new MultiElementDescriptor(descriptor));
		if (matchingBeans.isEmpty()) {
			return null;
		}
		if (autowiredBeanNames != null) {
			autowiredBeanNames.addAll(matchingBeans.keySet());
		}
		TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
		Object result = converter.convertIfNecessary(matchingBeans.values(), descriptor.getDependencyType());
		if (result instanceof List<?> list && list.size() > 1) {
			Comparator<Object> comparator = adaptDependencyComparator(matchingBeans);
			if (comparator != null) {
				list.sort(comparator);
			}
		}
		return result;
	}

	@Nullable
	private Object resolveMultipleBeanMap(DependencyDescriptor descriptor, @Nullable String beanName,
			@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {

		ResolvableType mapType = descriptor.getResolvableType().asMap();
		Class<?> keyType = mapType.resolveGeneric(0);
		if (String.class != keyType) {
			return null;
		}
		Class<?> valueType = mapType.resolveGeneric(1);
		if (valueType == null) {
			return null;
		}
		Map<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType,
				new MultiElementDescriptor(descriptor));
		if (matchingBeans.isEmpty()) {
			return null;
		}
		if (autowiredBeanNames != null) {
			autowiredBeanNames.addAll(matchingBeans.keySet());
		}
		TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
		return converter.convertIfNecessary(matchingBeans, descriptor.getDependencyType());
	}

	private boolean indicatesArrayCollectionOrMap(Class<?> type) {
		return (type.isArray() || (type.isInterface() &&
				(Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type))));
	}

	private boolean isRequired(DependencyDescriptor descriptor) {
		return getAutowireCandidateResolver().isRequired(descriptor);
	}

	@Nullable
	private Comparator<Object> adaptDependencyComparator(Map<String, ?> matchingBeans) {
		Comparator<Object> comparator = getDependencyComparator();
		if (comparator instanceof OrderComparator orderComparator) {
			return orderComparator.withSourceProvider(
					createFactoryAwareOrderSourceProvider(matchingBeans));
		}
		else {
			return comparator;
		}
	}

	private Comparator<Object> adaptOrderComparator(Map<String, ?> matchingBeans) {
		Comparator<Object> dependencyComparator = getDependencyComparator();
		OrderComparator comparator = (dependencyComparator instanceof OrderComparator orderComparator ?
				orderComparator : OrderComparator.INSTANCE);
		return comparator.withSourceProvider(createFactoryAwareOrderSourceProvider(matchingBeans));
	}

	private OrderComparator.OrderSourceProvider createFactoryAwareOrderSourceProvider(Map<String, ?> beans) {
		IdentityHashMap<Object, String> instancesToBeanNames = new IdentityHashMap<>();
		beans.forEach((beanName, instance) -> instancesToBeanNames.put(instance, beanName));
		return new FactoryAwareOrderSourceProvider(instancesToBeanNames);
	}

	/**
	 * Find bean instances that match the required type.
	 * Called during autowiring for the specified bean.
	 * @param beanName the name of the bean that is about to be wired
	 * @param requiredType the actual type of bean to look for
	 * (may be an array component type or collection element type)
	 * @param descriptor the descriptor of the dependency to resolve
	 * @return a Map of candidate names and candidate instances that match
	 * the required type (never {@code null})
	 * @throws BeansException in case of errors
	 * @see #autowireByType
	 * @see #autowireConstructor
	 */
	protected Map<String, Object> findAutowireCandidates(
			@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {

		String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
				this, requiredType, true, descriptor.isEager());
		Map<String, Object> result = CollectionUtils.newLinkedHashMap(candidateNames.length);
		for (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) {
			Class<?> autowiringType = classObjectEntry.getKey();
			if (autowiringType.isAssignableFrom(requiredType)) {
				Object autowiringValue = classObjectEntry.getValue();
				autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);
				if (requiredType.isInstance(autowiringValue)) {
					result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);
					break;
				}
			}
		}
		for (String candidate : candidateNames) {
			if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {
				addCandidateEntry(result, candidate, descriptor, requiredType);
			}
		}
		if (result.isEmpty()) {
			boolean multiple = indicatesArrayCollectionOrMap(requiredType);
			// Consider fallback matches if the first pass failed to find anything...
			DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();
			for (String candidate : candidateNames) {
				if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) &&
						(!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) {
					addCandidateEntry(result, candidate, descriptor, requiredType);
				}
			}
			if (result.isEmpty() && !multiple) {
				// Consider self references as a final pass...
				// but in the case of a dependency collection, not the very same bean itself.
				for (String candidate : candidateNames) {
					if (isSelfReference(beanName, candidate) &&
							(!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) &&
							isAutowireCandidate(candidate, fallbackDescriptor)) {
						addCandidateEntry(result, candidate, descriptor, requiredType);
					}
				}
			}
		}
		return result;
	}

	/**
	 * Add an entry to the candidate map: a bean instance if available or just the resolved
	 * type, preventing early bean initialization ahead of primary candidate selection.
	 */
	private void addCandidateEntry(Map<String, Object> candidates, String candidateName,
			DependencyDescriptor descriptor, Class<?> requiredType) {

		if (descriptor instanceof MultiElementDescriptor) {
			Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);
			if (!(beanInstance instanceof NullBean)) {
				candidates.put(candidateName, beanInstance);
			}
		}
		else if (containsSingleton(candidateName) ||
				(descriptor instanceof StreamDependencyDescriptor streamDescriptor && streamDescriptor.isOrdered())) {
			Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);
			candidates.put(candidateName, (beanInstance instanceof NullBean ? null : beanInstance));
		}
		else {
			candidates.put(candidateName, getType(candidateName));
		}
	}

	/**
	 * Determine the autowire candidate in the given set of beans.
	 * <p>Looks for {@code @Primary} and {@code @Priority} (in that order).
	 * @param candidates a Map of candidate names and candidate instances
	 * that match the required type, as returned by {@link #findAutowireCandidates}
	 * @param descriptor the target dependency to match against
	 * @return the name of the autowire candidate, or {@code null} if none found
	 */
	@Nullable
	protected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {
		Class<?> requiredType = descriptor.getDependencyType();
		// Step 1: check primary candidate
		String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);
		if (primaryCandidate != null) {
			return primaryCandidate;
		}
		// Step 2a: match bean name against declared dependency name
		String dependencyName = descriptor.getDependencyName();
		if (dependencyName != null) {
			for (String beanName : candidates.keySet()) {
				if (matchesBeanName(beanName, dependencyName)) {
					return beanName;
				}
			}
		}
		// Step 2b: match bean name against qualifier-suggested name
		String suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);
		if (suggestedName != null) {
			for (String beanName : candidates.keySet()) {
				if (matchesBeanName(beanName, suggestedName)) {
					return beanName;
				}
			}
		}
		// Step 3: check highest priority candidate
		String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);
		if (priorityCandidate != null) {
			return priorityCandidate;
		}
		// Step 4: pick unique default-candidate
		String defaultCandidate = determineDefaultCandidate(candidates);
		if (defaultCandidate != null) {
			return defaultCandidate;
		}
		// Step 5: pick directly registered dependency
		for (Map.Entry<String, Object> entry : candidates.entrySet()) {
			String candidateName = entry.getKey();
			Object beanInstance = entry.getValue();
			if (beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) {
				return candidateName;
			}
		}
		return null;
	}

	/**
	 * Determine the primary candidate in the given set of beans.
	 * @param candidates a Map of candidate names and candidate instances
	 * (or candidate classes if not created yet) that match the required type
	 * @param requiredType the target dependency type to match against
	 * @return the name of the primary candidate, or {@code null} if none found
	 * @see #isPrimary(String, Object)
	 */
	@Nullable
	protected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType) {
		String primaryBeanName = null;
		// First pass: identify unique primary candidate
		for (Map.Entry<String, Object> entry : candidates.entrySet()) {
			String candidateBeanName = entry.getKey();
			Object beanInstance = entry.getValue();
			if (isPrimary(candidateBeanName, beanInstance)) {
				if (primaryBeanName != null) {
					boolean candidateLocal = containsBeanDefinition(candidateBeanName);
					boolean primaryLocal = containsBeanDefinition(primaryBeanName);
					if (candidateLocal == primaryLocal) {
						throw new NoUniqueBeanDefinitionException(requiredType, candidates.size(),
								""more than one 'primary' bean found among candidates: "" + candidates.keySet());
					}
					else if (candidateLocal) {
						primaryBeanName = candidateBeanName;
					}
				}
				else {
					primaryBeanName = candidateBeanName;
				}
			}
		}
		// Second pass: identify unique non-fallback candidate
		if (primaryBeanName == null) {
			for (String candidateBeanName : candidates.keySet()) {
				if (!isFallback(candidateBeanName)) {
					if (primaryBeanName != null) {
						return null;
					}
					primaryBeanName = candidateBeanName;
				}
			}
		}
		return primaryBeanName;
	}

	/**
	 * Determine the candidate with the highest priority in the given set of beans.
	 * <p>Based on {@code @jakarta.annotation.Priority}. As defined by the related
	 * {@link org.springframework.core.Ordered} interface, the lowest value has
	 * the highest priority.
	 * @param candidates a Map of candidate names and candidate instances
	 * (or candidate classes if not created yet) that match the required type
	 * @param requiredType the target dependency type to match against
	 * @return the name of the candidate with the highest priority,
	 * or {@code null} if none found
	 * @throws NoUniqueBeanDefinitionException if multiple beans are detected with
	 * the same highest priority value
	 * @see #getPriority(Object)
	 */
	@Nullable
	protected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType) {
		String highestPriorityBeanName = null;
		Integer highestPriority = null;
		boolean highestPriorityConflictDetected = false;
		for (Map.Entry<String, Object> entry : candidates.entrySet()) {
			String candidateBeanName = entry.getKey();
			Object beanInstance = entry.getValue();
			if (beanInstance != null) {
				Integer candidatePriority = getPriority(beanInstance);
				if (candidatePriority != null) {
					if (highestPriority != null) {
						if (candidatePriority.equals(highestPriority)) {
							highestPriorityConflictDetected = true;
						}
						else if (candidatePriority < highestPriority) {
							highestPriorityBeanName = candidateBeanName;
							highestPriority = candidatePriority;
							highestPriorityConflictDetected = false;
						}
					}
					else {
						highestPriorityBeanName = candidateBeanName;
						highestPriority = candidatePriority;
					}
				}
			}
		}

		if (highestPriorityConflictDetected) {
			throw new NoUniqueBeanDefinitionException(requiredType, candidates.size(),
					""Multiple beans found with the same highest priority ("" + highestPriority +
					"") among candidates: "" + candidates.keySet());

		}
		return highestPriorityBeanName;
	}

	/**
	 * Return whether the bean definition for the given bean name has been
	 * marked as a primary bean.
	 * @param beanName the name of the bean
	 * @param beanInstance the corresponding bean instance (can be {@code null})
	 * @return whether the given bean qualifies as primary
	 */
	protected boolean isPrimary(String beanName, Object beanInstance) {
		String transformedBeanName = transformedBeanName(beanName);
		if (containsBeanDefinition(transformedBeanName)) {
			return getMergedLocalBeanDefinition(transformedBeanName).isPrimary();
		}
		return (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&
				parent.isPrimary(transformedBeanName, beanInstance));
	}

	/**
	 * Return whether the bean definition for the given bean name has been
	 * marked as a fallback bean.
	 * @param beanName the name of the bean
	 * @since 6.2
	 */
	private boolean isFallback(String beanName) {
		String transformedBeanName = transformedBeanName(beanName);
		if (containsBeanDefinition(transformedBeanName)) {
			return getMergedLocalBeanDefinition(transformedBeanName).isFallback();
		}
		return (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&
				parent.isFallback(transformedBeanName));
	}

	/**
	 * Return the priority assigned for the given bean instance by
	 * the {@code jakarta.annotation.Priority} annotation.
	 * <p>The default implementation delegates to the specified
	 * {@link #setDependencyComparator dependency comparator}, checking its
	 * {@link OrderComparator#getPriority method} if it is an extension of
	 * Spring's common {@link OrderComparator} - typically, an
	 * {@link org.springframework.core.annotation.AnnotationAwareOrderComparator}.
	 * If no such comparator is present, this implementation returns {@code null}.
	 * @param beanInstance the bean instance to check (can be {@code null})
	 * @return the priority assigned to that bean or {@code null} if none is set
	 */
	@Nullable
	protected Integer getPriority(Object beanInstance) {
		Comparator<Object> comparator = getDependencyComparator();
		if (comparator instanceof OrderComparator orderComparator) {
			return orderComparator.getPriority(beanInstance);
		}
		return null;
	}

	/**
	 * Return a unique ""default-candidate"" among remaining non-default candidates.
	 * @param candidates a Map of candidate names and candidate instances
	 * (or candidate classes if not created yet) that match the required type
	 * @return the name of the default candidate, or {@code null} if none found
	 * @since 6.2.4
	 * @see AbstractBeanDefinition#isDefaultCandidate()
	 */
	@Nullable
	private String determineDefaultCandidate(Map<String, Object> candidates) {
		String defaultBeanName = null;
		for (String candidateBeanName : candidates.keySet()) {
			if (AutowireUtils.isDefaultCandidate(this, candidateBeanName)) {
				if (defaultBeanName != null) {
					return null;
				}
				defaultBeanName = candidateBeanName;
			}
		}
		return defaultBeanName;
	}

	/**
	 * Determine whether the given candidate name matches the bean name or the aliases
	 * stored in this bean definition.
	 */
	protected boolean matchesBeanName(String beanName, @Nullable String candidateName) {
		return (candidateName != null &&
				(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));
	}

	/**
	 * Determine whether the given beanName/candidateName pair indicates a self reference,
	 * i.e. whether the candidate points back to the original bean or to a factory method
	 * on the original bean.
	 */
	@Contract(""null, _ -> false; _, null -> false;"")
	private boolean isSelfReference(@Nullable String beanName, @Nullable String candidateName) {
		return (beanName != null && candidateName != null &&
				(beanName.equals(candidateName) || (containsBeanDefinition(candidateName) &&
						beanName.equals(getMergedLocalBeanDefinition(candidateName).getFactoryBeanName()))));
	}

	/**
	 * Determine whether there is a primary bean registered for the given dependency type,
	 * not matching the given bean name.
	 */
	private boolean hasPrimaryConflict(String beanName, Class<?> dependencyType) {
		for (Map.Entry<String, Class<?>> candidate : this.primaryBeanNamesWithType.entrySet()) {
			String candidateName = candidate.getKey();
			Class<?> candidateType = candidate.getValue();
			if (!candidateName.equals(beanName) && (candidateType != Void.class ?
					dependencyType.isAssignableFrom(candidateType) :  // cached singleton class for primary bean
					isTypeMatch(candidateName, dependencyType))) {  // not instantiated yet or not a singleton
				return true;
			}
		}
		return (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&
				parent.hasPrimaryConflict(beanName, dependencyType));
	}

	/**
	 * Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException
	 * for an unresolvable dependency.
	 */
	private void raiseNoMatchingBeanFound(
			Class<?> type, ResolvableType resolvableType, DependencyDescriptor descriptor) throws BeansException {

		checkBeanNotOfRequiredType(type, descriptor);

		throw new NoSuchBeanDefinitionException(resolvableType,
				""expected at least 1 bean which qualifies as autowire candidate. "" +
				""Dependency annotations: "" + ObjectUtils.nullSafeToString(descriptor.getAnnotations()));
	}

	/**
	 * Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable,
	 * i.e. if the target type of the bean would match but an exposed proxy doesn't.
	 */
	private void checkBeanNotOfRequiredType(Class<?> type, DependencyDescriptor descriptor) {
		for (String beanName : this.beanDefinitionNames) {
			try {
				RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
				Class<?> targetType = mbd.getTargetType();
				if (targetType != null && type.isAssignableFrom(targetType) &&
						isAutowireCandidate(beanName, mbd, descriptor, getAutowireCandidateResolver())) {
					// Probably a proxy interfering with target type match -> throw meaningful exception.
					Object beanInstance = getSingleton(beanName, false);
					Class<?> beanType = (beanInstance != null && beanInstance.getClass() != NullBean.class ?
							beanInstance.getClass() : predictBeanType(beanName, mbd));
					if (beanType != null && !type.isAssignableFrom(beanType)) {
						throw new BeanNotOfRequiredTypeException(beanName, type, beanType);
					}
				}
			}
			catch (NoSuchBeanDefinitionException ex) {
				// Bean definition got removed while we were iterating -> ignore.
			}
		}

		if (getParentBeanFactory() instanceof DefaultListableBeanFactory parent) {
			parent.checkBeanNotOfRequiredType(type, descriptor);
		}
	}

	/**
	 * Create an {@link Optional} wrapper for the specified dependency.
	 */
	private Optional<?> createOptionalDependency(
			DependencyDescriptor descriptor, @Nullable String beanName, final Object... args) {

		DependencyDescriptor descriptorToUse = new NestedDependencyDescriptor(descriptor) {
			@Override
			public boolean isRequired() {
				return false;
			}
			@Override
			public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {
				return (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) :
						super.resolveCandidate(beanName, requiredType, beanFactory));
			}
			@Override
			public boolean usesStandardBeanLookup() {
				return ObjectUtils.isEmpty(args);
			}
		};
		Object result = doResolveDependency(descriptorToUse, beanName, null, null);
		return (result instanceof Optional<?> optional ? optional : Optional.ofNullable(result));
	}


	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder(ObjectUtils.identityToString(this));
		sb.append("": defining beans ["");
		sb.append(StringUtils.collectionToCommaDelimitedString(this.beanDefinitionNames));
		sb.append(""]; "");
		BeanFactory parent = getParentBeanFactory();
		if (parent == null) {
			sb.append(""root of factory hierarchy"");
		}
		else {
			sb.append(""parent: "").append(ObjectUtils.identityToString(parent));
		}
		return sb.toString();
	}


	//---------------------------------------------------------------------
	// Serialization support
	//---------------------------------------------------------------------

	@Serial
	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
		throw new NotSerializableException(""DefaultListableBeanFactory itself is not deserializable - "" +
				""just a SerializedBeanFactoryReference is"");
	}

	@Serial
	protected Object writeReplace() throws ObjectStreamException {
		if (this.serializationId != null) {
			return new SerializedBeanFactoryReference(this.serializationId);
		}
		else {
			throw new NotSerializableException(""DefaultListableBeanFactory has no serialization id"");
		}
	}


	/**
	 * Minimal id reference to the factory.
	 * Resolved to the actual factory instance on deserialization.
	 */
	private static class SerializedBeanFactoryReference implements Serializable {

		private final String id;

		public SerializedBeanFactoryReference(String id) {
			this.id = id;
		}

		private Object readResolve() {
			Reference<?> ref = serializableFactories.get(this.id);
			if (ref != null) {
				Object result = ref.get();
				if (result != null) {
					return result;
				}
			}
			// Lenient fallback: dummy factory in case of original factory not found...
			DefaultListableBeanFactory dummyFactory = new DefaultListableBeanFactory();
			dummyFactory.serializationId = this.id;
			return dummyFactory;
		}
	}


	/**
	 * A dependency descriptor marker for nested elements.
	 */
	private static class NestedDependencyDescriptor extends DependencyDescriptor {

		public NestedDependencyDescriptor(DependencyDescriptor original) {
			super(original);
			increaseNestingLevel();
		}

		@Override
		public boolean usesStandardBeanLookup() {
			return true;
		}
	}


	/**
	 * A dependency descriptor for a multi-element declaration with nested elements.
	 */
	private static class MultiElementDescriptor extends NestedDependencyDescriptor {

		public MultiElementDescriptor(DependencyDescriptor original) {
			super(original);
		}
	}


	/**
	 * A dependency descriptor marker for stream access to multiple elements.
	 */
	private static class StreamDependencyDescriptor extends DependencyDescriptor {

		private final boolean ordered;

		public StreamDependencyDescriptor(DependencyDescriptor original, boolean ordered) {
			super(original);
			this.ordered = ordered;
		}

		public boolean isOrdered() {
			return this.ordered;
		}
	}


	private interface BeanObjectProvider<T> extends ObjectProvider<T>, Serializable {
	}


	/**
	 * Serializable ObjectFactory/ObjectProvider for lazy resolution of a dependency.
	 */
	private class DependencyObjectProvider implements BeanObjectProvider<Object> {

		private final DependencyDescriptor descriptor;

		private final boolean optional;

		@Nullable
		private final String beanName;

		public DependencyObjectProvider(DependencyDescriptor descriptor, @Nullable String beanName) {
			this.descriptor = new NestedDependencyDescriptor(descriptor);
			this.optional = (this.descriptor.getDependencyType() == Optional.class);
			this.beanName = beanName;
		}

		@Override
		public Object getObject() throws BeansException {
			if (this.optional) {
				return createOptionalDependency(this.descriptor, this.beanName);
			}
			else {
				Object result = doResolveDependency(this.descriptor, this.beanName, null, null);
				if (result == null) {
					throw new NoSuchBeanDefinitionException(this.descriptor.getResolvableType());
				}
				return result;
			}
		}

		@Override
		public Object getObject(final Object... args) throws BeansException {
			if (this.optional) {
				return createOptionalDependency(this.descriptor, this.beanName, args);
			}
			else {
				DependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {
					@Override
					public Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {
						return beanFactory.getBean(beanName, args);
					}
				};
				Object result = doResolveDependency(descriptorToUse, this.beanName, null, null);
				if (result == null) {
					throw new NoSuchBeanDefinitionException(this.descriptor.getResolvableType());
				}
				return result;
			}
		}

		@Override
		@Nullable
		public Object getIfAvailable() throws BeansException {
			try {
				if (this.optional) {
					return createOptionalDependency(this.descriptor, this.beanName);
				}
				else {
					DependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {
						@Override
						public boolean isRequired() {
							return false;
						}
						@Override
						public boolean usesStandardBeanLookup() {
							return true;
						}
					};
					return doResolveDependency(descriptorToUse, this.beanName, null, null);
				}
			}
			catch (ScopeNotActiveException ex) {
				// Ignore resolved bean in non-active scope
				return null;
			}
		}

		@Override
		public void ifAvailable(Consumer<Object> dependencyConsumer) throws BeansException {
			Object dependency = getIfAvailable();
			if (dependency != null) {
				try {
					dependencyConsumer.accept(dependency);
				}
				catch (ScopeNotActiveException ex) {
					// Ignore resolved bean in non-active scope, even on scoped proxy invocation
				}
			}
		}

		@Override
		@Nullable
		public Object getIfUnique() throws BeansException {
			DependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {
				@Override
				public boolean isRequired() {
					return false;
				}
				@Override
				public boolean usesStandardBeanLookup() {
					return true;
				}
				@Override
				@Nullable
				public Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) {
					return null;
				}
			};
			try {
				if (this.optional) {
					return createOptionalDependency(descriptorToUse, this.beanName);
				}
				else {
					return doResolveDependency(descriptorToUse, this.beanName, null, null);
				}
			}
			catch (ScopeNotActiveException ex) {
				// Ignore resolved bean in non-active scope
				return null;
			}
		}

		@Override
		public void ifUnique(Consumer<Object> dependencyConsumer) throws BeansException {
			Object dependency = getIfUnique();
			if (dependency != null) {
				try {
					dependencyConsumer.accept(dependency);
				}
				catch (ScopeNotActiveException ex) {
					// Ignore resolved bean in non-active scope, even on scoped proxy invocation
				}
			}
		}

		@Nullable
		protected Object getValue() throws BeansException {
			if (this.optional) {
				return createOptionalDependency(this.descriptor, this.beanName);
			}
			else {
				return doResolveDependency(this.descriptor, this.beanName, null, null);
			}
		}

		@Override
		public Stream<Object> stream() {
			return resolveStream(false);
		}

		@Override
		public Stream<Object> orderedStream() {
			return resolveStream(true);
		}

		@SuppressWarnings({""rawtypes"", ""unchecked""})
		private Stream<Object> resolveStream(boolean ordered) {
			DependencyDescriptor descriptorToUse = new StreamDependencyDescriptor(this.descriptor, ordered);
			Object result = doResolveDependency(descriptorToUse, this.beanName, null, null);
			return (result instanceof Stream stream ? stream : Stream.of(result));
		}

		@Override
		public Stream<Object> stream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {
			return Arrays.stream(beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true))
					.filter(name -> AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, name))
					.filter(name -> customFilter.test(getType(name)))
					.map(name -> getBean(name))
					.filter(bean -> !(bean instanceof NullBean));
		}

		@Override
		public Stream<Object> orderedStream(Predicate<Class<?>> customFilter, boolean includeNonSingletons) {
			String[] beanNames = beanNamesForStream(this.descriptor.getResolvableType(), includeNonSingletons, true);
			if (beanNames.length == 0) {
				return Stream.empty();
			}
			Map<String, Object> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);
			for (String beanName : beanNames) {
				if (AutowireUtils.isAutowireCandidate(DefaultListableBeanFactory.this, beanName) &&
						customFilter.test(getType(beanName))) {
					Object beanInstance = getBean(beanName);
					if (!(beanInstance instanceof NullBean)) {
						matchingBeans.put(beanName, beanInstance);
					}
				}
			}
			return matchingBeans.values().stream().sorted(adaptOrderComparator(matchingBeans));
		}
	}


	/**
	 * Separate inner class for avoiding a hard dependency on the {@code jakarta.inject} API.
	 * Actual {@code jakarta.inject.Provider} implementation is nested here in order to make it
	 * invisible for Graal's introspection of DefaultListableBeanFactory's nested classes.
	 */
	private class Jsr330Factory implements Serializable {

		public Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName) {
			return new Jsr330Provider(descriptor, beanName);
		}

		private class Jsr330Provider extends DependencyObjectProvider implements Provider<Object> {

			public Jsr330Provider(DependencyDescriptor descriptor, @Nullable String beanName) {
				super(descriptor, beanName);
			}

			@Override
			@Nullable
			public Object get() throws BeansException {
				return getValue();
			}
		}
	}


	/**
	 * An {@link org.springframework.core.OrderComparator.OrderSourceProvider} implementation
	 * that is aware of the bean metadata of the instances to sort.
	 * <p>Lookup for the method factory of an instance to sort, if any, and let the
	 * comparator retrieve the {@link org.springframework.core.annotation.Order}
	 * value defined on it.
	 * <p>As of 6.1.2, this class takes the {@link AbstractBeanDefinition#ORDER_ATTRIBUTE}
	 * attribute into account.
	 */
	private class FactoryAwareOrderSourceProvider implements OrderComparator.OrderSourceProvider {

		private final Map<Object, String> instancesToBeanNames;

		public FactoryAwareOrderSourceProvider(Map<Object, String> instancesToBeanNames) {
			this.instancesToBeanNames = instancesToBeanNames;
		}

		@Override
		@Nullable
		public Object getOrderSource(Object obj) {
			String beanName = this.instancesToBeanNames.get(obj);
			if (beanName == null) {
				return null;
			}
			try {
				BeanDefinition beanDefinition = getMergedBeanDefinition(beanName);
				List<Object> sources = new ArrayList<>(3);
				Object orderAttribute = beanDefinition.getAttribute(AbstractBeanDefinition.ORDER_ATTRIBUTE);
				if (orderAttribute != null) {
					if (orderAttribute instanceof Integer order) {
						sources.add((Ordered) () -> order);
					}
					else {
						throw new IllegalStateException(""Invalid value type for attribute '"" +
								AbstractBeanDefinition.ORDER_ATTRIBUTE + ""': "" + orderAttribute.getClass().getName());
					}
				}
				if (beanDefinition instanceof RootBeanDefinition rootBeanDefinition) {
					Method factoryMethod = rootBeanDefinition.getResolvedFactoryMethod();
					if (factoryMethod != null) {
						sources.add(factoryMethod);
					}
					Class<?> targetType = rootBeanDefinition.getTargetType();
					if (targetType != null && targetType != obj.getClass()) {
						sources.add(targetType);
					}
				}
				return sources.toArray();
			}
			catch (NoSuchBeanDefinitionException ex) {
				return null;
			}
		}
	}


	private enum PreInstantiation {

		MAIN, BACKGROUND
	}

}
"
9ba954c3307e78a1fc5b61e1154036a5be531da8,"Fix FileSystemUtils for Windows/Linux path difference

See gh-35443",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.util;

import java.io.File;
import java.net.URI;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.util.Map;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link FileSystemUtils}.
 *
 * @author Rob Harrop
 * @author Sam Brannen
 * @author Juergen Hoeller
 */
class FileSystemUtilsTests {

	@Test
	void deleteRecursively(@TempDir File tempDir) throws Exception {
		File root = new File(tempDir, ""root"");
		File child = new File(root, ""child"");
		File grandchild = new File(child, ""grandchild"");

		grandchild.mkdirs();

		File bar = new File(child, ""bar.txt"");
		bar.createNewFile();

		assertThat(root).exists();
		assertThat(child).exists();
		assertThat(grandchild).exists();
		assertThat(bar).exists();

		FileSystemUtils.deleteRecursively(root);

		assertThat(root).doesNotExist();
		assertThat(child).doesNotExist();
		assertThat(grandchild).doesNotExist();
		assertThat(bar).doesNotExist();
	}

	@Test
	void copyRecursively(@TempDir File tempDir) throws Exception {
		File src = new File(tempDir, ""src"");
		File child = new File(src, ""child"");
		File grandchild = new File(child, ""grandchild"");

		grandchild.mkdirs();

		File bar = new File(child, ""bar.txt"");
		bar.createNewFile();

		assertThat(src).exists();
		assertThat(child).exists();
		assertThat(grandchild).exists();
		assertThat(bar).exists();

		File dest = new File(tempDir, ""/dest"");
		FileSystemUtils.copyRecursively(src, dest);

		assertThat(dest).exists();
		assertThat(new File(dest, ""child"")).exists();
		assertThat(new File(dest, ""child/bar.txt"")).exists();

		URI uri = URI.create(""jar:file:/"" + dest.toString().replace('\\', '/') + ""/archive.zip"");
		Map<String, String> env = Map.of(""create"", ""true"");
		FileSystem zipfs = FileSystems.newFileSystem(uri, env);
		Path ziproot = zipfs.getPath(""/"");
		FileSystemUtils.copyRecursively(src.toPath(), ziproot);

		assertThat(zipfs.getPath(""/child"")).exists();
		assertThat(zipfs.getPath(""/child/bar.txt"")).exists();

		zipfs.close();
		FileSystemUtils.deleteRecursively(src);
		assertThat(src).doesNotExist();
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.util;

import java.io.File;
import java.net.URI;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.util.Map;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link FileSystemUtils}.
 *
 * @author Rob Harrop
 * @author Sam Brannen
 * @author Juergen Hoeller
 */
class FileSystemUtilsTests {

	@Test
	void deleteRecursively(@TempDir File tempDir) throws Exception {
		File root = new File(tempDir, ""root"");
		File child = new File(root, ""child"");
		File grandchild = new File(child, ""grandchild"");

		grandchild.mkdirs();

		File bar = new File(child, ""bar.txt"");
		bar.createNewFile();

		assertThat(root).exists();
		assertThat(child).exists();
		assertThat(grandchild).exists();
		assertThat(bar).exists();

		FileSystemUtils.deleteRecursively(root);

		assertThat(root).doesNotExist();
		assertThat(child).doesNotExist();
		assertThat(grandchild).doesNotExist();
		assertThat(bar).doesNotExist();
	}

	@Test
	void copyRecursively(@TempDir File tempDir) throws Exception {
		File src = new File(tempDir, ""src"");
		File child = new File(src, ""child"");
		File grandchild = new File(child, ""grandchild"");

		grandchild.mkdirs();

		File bar = new File(child, ""bar.txt"");
		bar.createNewFile();

		assertThat(src).exists();
		assertThat(child).exists();
		assertThat(grandchild).exists();
		assertThat(bar).exists();

		File dest = new File(tempDir, ""/dest"");
		FileSystemUtils.copyRecursively(src, dest);

		assertThat(dest).exists();
		assertThat(new File(dest, ""child"")).exists();
		assertThat(new File(dest, ""child/bar.txt"")).exists();

		String destPath = dest.toString().replace('\\', '/');
		if (!destPath.startsWith(""/"")) {
			destPath = ""/"" + destPath;
		}
		URI uri = URI.create(""jar:file:"" + destPath + ""/archive.zip"");
		Map<String, String> env = Map.of(""create"", ""true"");
		FileSystem zipfs = FileSystems.newFileSystem(uri, env);
		Path ziproot = zipfs.getPath(""/"");
		FileSystemUtils.copyRecursively(src.toPath(), ziproot);

		assertThat(zipfs.getPath(""/child"")).exists();
		assertThat(zipfs.getPath(""/child/bar.txt"")).exists();

		zipfs.close();
		FileSystemUtils.deleteRecursively(src);
		assertThat(src).doesNotExist();
	}

}
"
20e1149dde7ff042154e4098d49939a886661c3e,"Fix synchronization in ResponseBodyEmitter

See gh-35423
Fixes gh-35466",MODIFY,"/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.servlet.mvc.method.annotation;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;

import org.jspecify.annotations.Nullable;

import org.springframework.http.MediaType;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;

/**
 * A controller method return value type for asynchronous request processing
 * where one or more objects are written to the response.
 *
 * <p>While {@link org.springframework.web.context.request.async.DeferredResult}
 * is used to produce a single result, a {@code ResponseBodyEmitter} can be used
 * to send multiple objects where each object is written with a compatible
 * {@link org.springframework.http.converter.HttpMessageConverter}.
 *
 * <p>Supported as a return type on its own as well as within a
 * {@link org.springframework.http.ResponseEntity}.
 *
 * <pre>
 * &#064;RequestMapping(value=""/stream"", method=RequestMethod.GET)
 * public ResponseBodyEmitter handle() {
 * 	   ResponseBodyEmitter emitter = new ResponseBodyEmitter();
 * 	   // Pass the emitter to another component...
 * 	   return emitter;
 * }
 *
 * // in another thread
 * emitter.send(foo1);
 *
 * // and again
 * emitter.send(foo2);
 *
 * // and done
 * emitter.complete();
 * </pre>
 *
 * @author Rossen Stoyanchev
 * @author Juergen Hoeller
 * @author Brian Clozel
 * @author Taeik Lim
 * @since 4.2
 */
public class ResponseBodyEmitter {

	private final @Nullable Long timeout;

	private @Nullable Handler handler;

	/** Store send data before handler is initialized. */
	private final Set<DataWithMediaType> earlySendAttempts = new LinkedHashSet<>(8);

	/** Store successful completion before the handler is initialized. */
	private boolean complete;

	/** Store an error before the handler is initialized. */
	private @Nullable Throwable failure;

	private final DefaultCallback timeoutCallback = new DefaultCallback();

	private final ErrorCallback errorCallback = new ErrorCallback();

	private final DefaultCallback completionCallback = new DefaultCallback();

	/** Guards access to write operations on the response. */
	protected final Lock writeLock = new ReentrantLock();

	/**
	 * Create a new ResponseBodyEmitter instance.
	 */
	public ResponseBodyEmitter() {
		this.timeout = null;
	}

	/**
	 * Create a ResponseBodyEmitter with a custom timeout value.
	 * <p>By default not set in which case the default configured in the MVC
	 * Java Config or the MVC namespace is used, or if that's not set, then the
	 * timeout depends on the default of the underlying server.
	 * @param timeout the timeout value in milliseconds
	 */
	public ResponseBodyEmitter(Long timeout) {
		this.timeout = timeout;
	}


	/**
	 * Return the configured timeout value, if any.
	 */
	public @Nullable Long getTimeout() {
		return this.timeout;
	}


	void initialize(Handler handler) throws IOException {
		this.writeLock.lock();
		try {
			this.handler = handler;

			try {
				sendInternal(this.earlySendAttempts);
			}
			finally {
				this.earlySendAttempts.clear();
			}

			if (this.complete) {
				if (this.failure != null) {
					this.handler.completeWithError(this.failure);
				}
				else {
					this.handler.complete();
				}
			}
			else {
				this.handler.onTimeout(this.timeoutCallback);
				this.handler.onError(this.errorCallback);
				this.handler.onCompletion(this.completionCallback);
			}
		}
		finally {
			this.writeLock.unlock();
		}
	}

	void initializeWithError(Throwable ex) {
		this.writeLock.lock();
		try {
			this.complete = true;
			this.failure = ex;
			this.earlySendAttempts.clear();
			this.errorCallback.accept(ex);
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Invoked after the response is updated with the status code and headers,
	 * if the ResponseBodyEmitter is wrapped in a ResponseEntity, but before the
	 * response is committed, i.e. before the response body has been written to.
	 * <p>The default implementation is empty.
	 */
	protected void extendResponse(ServerHttpResponse outputMessage) {
	}

	/**
	 * Write the given object to the response.
	 * <p>If any exception occurs a dispatch is made back to the app server where
	 * Spring MVC will pass the exception through its exception handling mechanism.
	 * <p><strong>Note:</strong> if the send fails with an IOException, you do
	 * not need to call {@link #completeWithError(Throwable)} in order to clean
	 * up. Instead the Servlet container creates a notification that results in a
	 * dispatch where Spring MVC invokes exception resolvers and completes
	 * processing.
	 * @param object the object to write
	 * @throws IOException raised when an I/O error occurs
	 * @throws java.lang.IllegalStateException wraps any other errors
	 */
	public void send(Object object) throws IOException {
		send(object, null);
	}

	/**
	 * Overloaded variant of {@link #send(Object)} that also accepts a MediaType
	 * hint for how to serialize the given Object.
	 * @param object the object to write
	 * @param mediaType a MediaType hint for selecting an HttpMessageConverter
	 * @throws IOException raised when an I/O error occurs
	 * @throws java.lang.IllegalStateException wraps any other errors
	 */
	public void send(Object object, @Nullable MediaType mediaType) throws IOException {
		Assert.state(!this.complete, () -> ""ResponseBodyEmitter has already completed"" +
				(this.failure != null ? "" with error: "" + this.failure : """"));
		this.writeLock.lock();
		try {
			if (this.handler != null) {
				try {
					this.handler.send(object, mediaType);
				}
				catch (IOException ex) {
					throw ex;
				}
				catch (Throwable ex) {
					throw new IllegalStateException(""Failed to send "" + object, ex);
				}
			}
			else {
				this.earlySendAttempts.add(new DataWithMediaType(object, mediaType));
			}
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Write a set of data and MediaType pairs in a batch.
	 * <p>Compared to {@link #send(Object, MediaType)}, this batches the write operations
	 * and flushes to the network at the end.
	 * @param items the object and media type pairs to write
	 * @throws IOException raised when an I/O error occurs
	 * @throws java.lang.IllegalStateException wraps any other errors
	 * @since 6.0.12
	 */
	public void send(Set<DataWithMediaType> items) throws IOException {
		Assert.state(!this.complete, () -> ""ResponseBodyEmitter has already completed"" +
				(this.failure != null ? "" with error: "" + this.failure : """"));
		this.writeLock.lock();
		try {
			sendInternal(items);
		}
		finally {
			this.writeLock.unlock();
		}
	}

	private void sendInternal(Set<DataWithMediaType> items) throws IOException {
		if (items.isEmpty()) {
			return;
		}
		if (this.handler != null) {
			try {
				this.handler.send(items);
			}
			catch (IOException ex) {
				throw ex;
			}
			catch (Throwable ex) {
				throw new IllegalStateException(""Failed to send "" + items, ex);
			}
		}
		else {
			this.earlySendAttempts.addAll(items);
		}
	}

	/**
	 * Complete request processing by performing a dispatch into the servlet
	 * container, where Spring MVC is invoked once more, and completes the
	 * request processing lifecycle.
	 * <p><strong>Note:</strong> this method should be called by the application
	 * to complete request processing. It should not be used after container
	 * related events such as an error while {@link #send(Object) sending}.
	 */
	public void complete() {
		this.writeLock.lock();
		try {
			this.complete = true;
			if (this.handler != null) {
				this.handler.complete();
			}
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Complete request processing with an error.
	 * <p>A dispatch is made into the app server where Spring MVC will pass the
	 * exception through its exception handling mechanism. Note however that
	 * at this stage of request processing, the response is committed and the
	 * response status can no longer be changed.
	 * <p><strong>Note:</strong> this method should be called by the application
	 * to complete request processing with an error. It should not be used after
	 * container related events such as an error while
	 * {@link #send(Object) sending}.
	 */
	public void completeWithError(Throwable ex) {
		this.writeLock.lock();
		try {
			this.complete = true;
			this.failure = ex;
			if (this.handler != null) {
				this.handler.completeWithError(ex);
			}
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Register code to invoke when the async request times out. This method is
	 * called from a container thread when an async request times out.
	 * <p>As of 6.2, one can register multiple callbacks for this event.
	 */
	public void onTimeout(Runnable callback) {
		this.writeLock.lock();
		try {
			this.timeoutCallback.addDelegate(callback);
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Register code to invoke for an error during async request processing.
	 * This method is called from a container thread when an error occurred
	 * while processing an async request.
	 * <p>As of 6.2, one can register multiple callbacks for this event.
	 * @since 5.0
	 */
	public void onError(Consumer<Throwable> callback) {
		this.writeLock.lock();
		try {
			this.errorCallback.addDelegate(callback);
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Register code to invoke when the async request completes. This method is
	 * called from a container thread when an async request completed for any
	 * reason including timeout and network error. This method is useful for
	 * detecting that a {@code ResponseBodyEmitter} instance is no longer usable.
	 * <p>As of 6.2, one can register multiple callbacks for this event.
	 */
	public void onCompletion(Runnable callback) {
		this.writeLock.lock();
		try {
			this.completionCallback.addDelegate(callback);
		}
		finally {
			this.writeLock.unlock();
		}
	}


	@Override
	public String toString() {
		return ""ResponseBodyEmitter@"" + ObjectUtils.getIdentityHexString(this);
	}


	/**
	 * Contract to handle the sending of event data, the completion of event
	 * sending, and the registration of callbacks to be invoked in case of
	 * timeout, error, and completion for any reason (including from the
	 * container side).
	 */
	interface Handler {

		/**
		 * Immediately write and flush the given data to the network.
		 */
		void send(Object data, @Nullable MediaType mediaType) throws IOException;

		/**
		 * Immediately write all data items then flush to the network.
		 * @since 6.0.12
		 */
		void send(Set<DataWithMediaType> items) throws IOException;

		void complete();

		void completeWithError(Throwable failure);

		void onTimeout(Runnable callback);

		void onError(Consumer<Throwable> callback);

		void onCompletion(Runnable callback);
	}


	/**
	 * A simple holder of data to be written along with a MediaType hint for
	 * selecting a message converter to write with.
	 */
	public static class DataWithMediaType {

		private final Object data;

		private final @Nullable MediaType mediaType;

		public DataWithMediaType(Object data, @Nullable MediaType mediaType) {
			this.data = data;
			this.mediaType = mediaType;
		}

		public Object getData() {
			return this.data;
		}

		public @Nullable MediaType getMediaType() {
			return this.mediaType;
		}
	}


	private class DefaultCallback implements Runnable {

		private List<Runnable> delegates = new ArrayList<>(1);

		public void addDelegate(Runnable delegate) {
			this.delegates.add(delegate);
		}

		@Override
		public void run() {
			ResponseBodyEmitter.this.complete = true;
			for (Runnable delegate : this.delegates) {
				delegate.run();
			}
		}
	}


	private class ErrorCallback implements Consumer<Throwable> {

		private List<Consumer<Throwable>> delegates = new ArrayList<>(1);

		public void addDelegate(Consumer<Throwable> callback) {
			this.delegates.add(callback);
		}

		@Override
		public void accept(Throwable t) {
			ResponseBodyEmitter.this.complete = true;
			for(Consumer<Throwable> delegate : this.delegates) {
				delegate.accept(t);
			}
		}
	}

}
","/*
 * Copyright 2002-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.servlet.mvc.method.annotation;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;

import org.jspecify.annotations.Nullable;

import org.springframework.http.MediaType;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;

/**
 * A controller method return value type for asynchronous request processing
 * where one or more objects are written to the response.
 *
 * <p>While {@link org.springframework.web.context.request.async.DeferredResult}
 * is used to produce a single result, a {@code ResponseBodyEmitter} can be used
 * to send multiple objects where each object is written with a compatible
 * {@link org.springframework.http.converter.HttpMessageConverter}.
 *
 * <p>Supported as a return type on its own as well as within a
 * {@link org.springframework.http.ResponseEntity}.
 *
 * <pre>
 * &#064;RequestMapping(value=""/stream"", method=RequestMethod.GET)
 * public ResponseBodyEmitter handle() {
 * 	   ResponseBodyEmitter emitter = new ResponseBodyEmitter();
 * 	   // Pass the emitter to another component...
 * 	   return emitter;
 * }
 *
 * // in another thread
 * emitter.send(foo1);
 *
 * // and again
 * emitter.send(foo2);
 *
 * // and done
 * emitter.complete();
 * </pre>
 *
 * @author Rossen Stoyanchev
 * @author Juergen Hoeller
 * @author Brian Clozel
 * @author Taeik Lim
 * @since 4.2
 */
public class ResponseBodyEmitter {

	private final @Nullable Long timeout;

	private @Nullable Handler handler;

	/** Store send data before handler is initialized. */
	private final Set<DataWithMediaType> earlySendAttempts = new LinkedHashSet<>(8);

	/** Store successful completion before the handler is initialized. */
	private boolean complete;

	/** Store an error before the handler is initialized. */
	private @Nullable Throwable failure;

	private final DefaultCallback timeoutCallback = new DefaultCallback();

	private final ErrorCallback errorCallback = new ErrorCallback();

	private final DefaultCallback completionCallback = new DefaultCallback();

	/** Guards access to write operations on the response. */
	protected final Lock writeLock = new ReentrantLock();

	/**
	 * Create a new ResponseBodyEmitter instance.
	 */
	public ResponseBodyEmitter() {
		this.timeout = null;
	}

	/**
	 * Create a ResponseBodyEmitter with a custom timeout value.
	 * <p>By default not set in which case the default configured in the MVC
	 * Java Config or the MVC namespace is used, or if that's not set, then the
	 * timeout depends on the default of the underlying server.
	 * @param timeout the timeout value in milliseconds
	 */
	public ResponseBodyEmitter(Long timeout) {
		this.timeout = timeout;
	}


	/**
	 * Return the configured timeout value, if any.
	 */
	public @Nullable Long getTimeout() {
		return this.timeout;
	}


	void initialize(Handler handler) throws IOException {
		this.writeLock.lock();
		try {
			this.handler = handler;

			try {
				sendInternal(this.earlySendAttempts);
			}
			finally {
				this.earlySendAttempts.clear();
			}

			if (this.complete) {
				if (this.failure != null) {
					this.handler.completeWithError(this.failure);
				}
				else {
					this.handler.complete();
				}
			}
			else {
				this.handler.onTimeout(this.timeoutCallback);
				this.handler.onError(this.errorCallback);
				this.handler.onCompletion(this.completionCallback);
			}
		}
		finally {
			this.writeLock.unlock();
		}
	}

	void initializeWithError(Throwable ex) {
		this.writeLock.lock();
		try {
			this.complete = true;
			this.failure = ex;
			this.earlySendAttempts.clear();
			this.errorCallback.accept(ex);
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Invoked after the response is updated with the status code and headers,
	 * if the ResponseBodyEmitter is wrapped in a ResponseEntity, but before the
	 * response is committed, i.e. before the response body has been written to.
	 * <p>The default implementation is empty.
	 */
	protected void extendResponse(ServerHttpResponse outputMessage) {
	}

	/**
	 * Write the given object to the response.
	 * <p>If any exception occurs a dispatch is made back to the app server where
	 * Spring MVC will pass the exception through its exception handling mechanism.
	 * <p><strong>Note:</strong> if the send fails with an IOException, you do
	 * not need to call {@link #completeWithError(Throwable)} in order to clean
	 * up. Instead the Servlet container creates a notification that results in a
	 * dispatch where Spring MVC invokes exception resolvers and completes
	 * processing.
	 * @param object the object to write
	 * @throws IOException raised when an I/O error occurs
	 * @throws java.lang.IllegalStateException wraps any other errors
	 */
	public void send(Object object) throws IOException {
		send(object, null);
	}

	/**
	 * Overloaded variant of {@link #send(Object)} that also accepts a MediaType
	 * hint for how to serialize the given Object.
	 * @param object the object to write
	 * @param mediaType a MediaType hint for selecting an HttpMessageConverter
	 * @throws IOException raised when an I/O error occurs
	 * @throws java.lang.IllegalStateException wraps any other errors
	 */
	public void send(Object object, @Nullable MediaType mediaType) throws IOException {
		this.writeLock.lock();
		try {
			Assert.state(!this.complete, () -> ""ResponseBodyEmitter has already completed"" +
					(this.failure != null ? "" with error: "" + this.failure : """"));
			if (this.handler != null) {
				try {
					this.handler.send(object, mediaType);
				}
				catch (IOException ex) {
					throw ex;
				}
				catch (Throwable ex) {
					throw new IllegalStateException(""Failed to send "" + object, ex);
				}
			}
			else {
				this.earlySendAttempts.add(new DataWithMediaType(object, mediaType));
			}
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Write a set of data and MediaType pairs in a batch.
	 * <p>Compared to {@link #send(Object, MediaType)}, this batches the write operations
	 * and flushes to the network at the end.
	 * @param items the object and media type pairs to write
	 * @throws IOException raised when an I/O error occurs
	 * @throws java.lang.IllegalStateException wraps any other errors
	 * @since 6.0.12
	 */
	public void send(Set<DataWithMediaType> items) throws IOException {
		this.writeLock.lock();
		try {
			Assert.state(!this.complete, () -> ""ResponseBodyEmitter has already completed"" +
					(this.failure != null ? "" with error: "" + this.failure : """"));
			sendInternal(items);
		}
		finally {
			this.writeLock.unlock();
		}
	}

	private void sendInternal(Set<DataWithMediaType> items) throws IOException {
		if (items.isEmpty()) {
			return;
		}
		if (this.handler != null) {
			try {
				this.handler.send(items);
			}
			catch (IOException ex) {
				throw ex;
			}
			catch (Throwable ex) {
				throw new IllegalStateException(""Failed to send "" + items, ex);
			}
		}
		else {
			this.earlySendAttempts.addAll(items);
		}
	}

	/**
	 * Complete request processing by performing a dispatch into the servlet
	 * container, where Spring MVC is invoked once more, and completes the
	 * request processing lifecycle.
	 * <p><strong>Note:</strong> this method should be called by the application
	 * to complete request processing. It should not be used after container
	 * related events such as an error while {@link #send(Object) sending}.
	 */
	public void complete() {
		this.writeLock.lock();
		try {
			this.complete = true;
			if (this.handler != null) {
				this.handler.complete();
			}
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Complete request processing with an error.
	 * <p>A dispatch is made into the app server where Spring MVC will pass the
	 * exception through its exception handling mechanism. Note however that
	 * at this stage of request processing, the response is committed and the
	 * response status can no longer be changed.
	 * <p><strong>Note:</strong> this method should be called by the application
	 * to complete request processing with an error. It should not be used after
	 * container related events such as an error while
	 * {@link #send(Object) sending}.
	 */
	public void completeWithError(Throwable ex) {
		this.writeLock.lock();
		try {
			this.complete = true;
			this.failure = ex;
			if (this.handler != null) {
				this.handler.completeWithError(ex);
			}
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Register code to invoke when the async request times out. This method is
	 * called from a container thread when an async request times out.
	 * <p>As of 6.2, one can register multiple callbacks for this event.
	 */
	public void onTimeout(Runnable callback) {
		this.writeLock.lock();
		try {
			this.timeoutCallback.addDelegate(callback);
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Register code to invoke for an error during async request processing.
	 * This method is called from a container thread when an error occurred
	 * while processing an async request.
	 * <p>As of 6.2, one can register multiple callbacks for this event.
	 * @since 5.0
	 */
	public void onError(Consumer<Throwable> callback) {
		this.writeLock.lock();
		try {
			this.errorCallback.addDelegate(callback);
		}
		finally {
			this.writeLock.unlock();
		}
	}

	/**
	 * Register code to invoke when the async request completes. This method is
	 * called from a container thread when an async request completed for any
	 * reason including timeout and network error. This method is useful for
	 * detecting that a {@code ResponseBodyEmitter} instance is no longer usable.
	 * <p>As of 6.2, one can register multiple callbacks for this event.
	 */
	public void onCompletion(Runnable callback) {
		this.writeLock.lock();
		try {
			this.completionCallback.addDelegate(callback);
		}
		finally {
			this.writeLock.unlock();
		}
	}


	@Override
	public String toString() {
		return ""ResponseBodyEmitter@"" + ObjectUtils.getIdentityHexString(this);
	}


	/**
	 * Contract to handle the sending of event data, the completion of event
	 * sending, and the registration of callbacks to be invoked in case of
	 * timeout, error, and completion for any reason (including from the
	 * container side).
	 */
	interface Handler {

		/**
		 * Immediately write and flush the given data to the network.
		 */
		void send(Object data, @Nullable MediaType mediaType) throws IOException;

		/**
		 * Immediately write all data items then flush to the network.
		 * @since 6.0.12
		 */
		void send(Set<DataWithMediaType> items) throws IOException;

		void complete();

		void completeWithError(Throwable failure);

		void onTimeout(Runnable callback);

		void onError(Consumer<Throwable> callback);

		void onCompletion(Runnable callback);
	}


	/**
	 * A simple holder of data to be written along with a MediaType hint for
	 * selecting a message converter to write with.
	 */
	public static class DataWithMediaType {

		private final Object data;

		private final @Nullable MediaType mediaType;

		public DataWithMediaType(Object data, @Nullable MediaType mediaType) {
			this.data = data;
			this.mediaType = mediaType;
		}

		public Object getData() {
			return this.data;
		}

		public @Nullable MediaType getMediaType() {
			return this.mediaType;
		}
	}


	private class DefaultCallback implements Runnable {

		private List<Runnable> delegates = new ArrayList<>(1);

		public void addDelegate(Runnable delegate) {
			this.delegates.add(delegate);
		}

		@Override
		public void run() {
			ResponseBodyEmitter.this.complete = true;
			for (Runnable delegate : this.delegates) {
				delegate.run();
			}
		}
	}


	private class ErrorCallback implements Consumer<Throwable> {

		private List<Consumer<Throwable>> delegates = new ArrayList<>(1);

		public void addDelegate(Consumer<Throwable> callback) {
			this.delegates.add(callback);
		}

		@Override
		public void accept(Throwable t) {
			ResponseBodyEmitter.this.complete = true;
			for(Consumer<Throwable> delegate : this.delegates) {
				delegate.accept(t);
			}
		}
	}

}
"
8830c99effac591d19be25de2f185928dd73ba08,"Merge bug mining into master (#135)

* slight modifications for build script

* fix a few little things making them work a little better

* adjust some of these variables

* might not even use this bugmine.stanity.check after all, it seeps to have a problem getting the major classpath but that shouldnt be too much of an issue really

* clean that up

* document that and remove dummy param, it was silly anyway

* update some basic project lib stuff

* update paths on that and remove trailing spaces and backslashes

* be a little more verbose when skipping existing entries

* its acutally just trigger not triggering

* all ant tasks return boolean for success not a return status code

* adapt this a little

* fix issues that cause obvious failure, still failing now but just not getting the right results

* fix get class list and update readme to reflect any changes to bug mining that I forgot about

* move depenency module list into main readme, add glossary to main readme

* update paths one last time

* minimize patch and promote to directory scripts updated

* copy notice about new build file location

* update method fingerpring

* remind myself to remove this

* remove framework/build-scripts

* copy overview to main readme

* dont need to just diff the src directory

* do the same in the lang project module

* bugmine.sanity.check was just for testing, it isnt even used now, can be removed

* update comment

* Revert change in string interpolation syntax

* In project.pm checkout_id update variable name and comment

* Updated a comment in Project module.

* Removed a delegation method: checkout_vid is already implemented and checkout_id is never called by the bug-mining scripts.

* Some simplifications and consistency changes.

* Consistently use the work directory, if provided.

* Infer commit-db and build file location from work_dir; expect work_dir to be provided in each Project constructor.

* Let ant report that error

* Remove outdated comment

* Fixed broken Project module.

* Added another variable for the projects directory.

* Started removing the work_dir attribute, which is replaced by a global PROJECTS_DIR attribute.

* Remove failing, flaky, and random tests in Project module.

* More fixes in core Modules; dynamically determine the directory layout.

* Added the adapted build.xml template.

* Updated Project template.

* Updated create-project.pl.

* Renamed directory mapping for Math.

* Updated Math and Lang project modules.

* Made template consistent with Lang and Math project modules.

* Updated the documentation.

* Updated two more scripts, which still require some fine tuning.

* Updated the core framework to support bootstrapping in the bug-mining scripts.

* Don't hard-code the location of the project build file.

* Fixed init script; create all necessary dirs in the create-project script.

* Pass over documentation.

* Fixed a layout issue.

* Skip invalid candidates.

* Fixed a typo.

* Improved script documentation; consistently use -b for bug ids.

* Tweaked the README.

* Minor fixes and output tweaks.

* Clone the repo when creating the project.

* More documentation improvements.

* Updated the get-trigger script; tweaked perldoc of analyze-project script.

* More documentation updates.

* Removed PatchReader from get-class-list script and updated documentation.

* Pass over main README.

* Create all directories when setting up a project; properly set D4J core variables in get-class script.

* PatchReader is no longer required.

* Update the project_repos README after cloning the repo.

* Updated the minimize-patch script.

* Updated file headers.

* Minimize changes in the PR since we eliminated the confusing use of prog_root and work_dir -- we should rename the prog_root attribute in Project.pm to work_dir, though.

* More prog_root -> work_dir changes.

* Updated Chart project module.

* Added the init subroutine, which is called by the bug-mining scripts, to the template.

* Updated documentation.

* prog_root -> work_dir.

* Fixed Chart project module.

* Don't apply co_hook in Vcs module.

* Reverted changes that are no longer required.

* Added the cached directory layout map for Chart.

* More information about locales (addresses #129).

* Don't hard-code paths to meta data in util scripts.

* Properly set environment variables in get-class-list script.

* Run fewer bugs for Math to avoid travis timeouts.

* Added a todo in the Project module.

* Updated Time module.

* Use revision IDs to identify broken builds in Time.

* Temporarily disable a couple tests.

* Some build files in Time are broken; added the functionality back in to fix these.

* Added the generated directory layout map.

* Renamed Mockito files.

* Added a todo.

* Renamed a subroutine.

* Updated Mockito module.

* Improved project module template.

* Updated Closure module.

* More descriptive names for build stages.

* Fixed a typo in travis config; allocate more time for Closure defects.

* Fixed a regex typo.

* Added the directory layout for Closure.

* Final dir-layout for Closure.

* Added one more test that fails non-deterministically on Travis.

* Moved glossary of D4J terms to bug-mining README.

* Some clarifications in README.

* Fewer jobs for Mockito.

* Split a batch of 10 Closure bugs that always time out on Travis into two batches.

* Renamed promote script and update the documentation; still need to update the code.

* Updated the README.

* Fixed a typo in project module template.

* In download issues script add new param into documentation and require it for github

* In download issues script append org to uri unless its part of project already

* Updated README and added TODOs.

* Correct download issues script to require a org for github (through project or through new org arg)

* Update readme and download issues script to be more obvious about difference between project id and tracker id

* Renamed and updated get-metadata script.

* Fixed minimize-patch script.

* Smaller change in README.

* Fixed a typo in the main build file.

* Fleshing out bug mining README

* Added more information on bug-mining README

Analyzer-related information will be added later.

* Fixed typos in formatter.

* Added build-file-analyzer to lib, and updated gitignore.

* Updated initialize-revision to call analyzer.

* Updated initialize-revision to download dependencies.

* Updated Formatter to handle special cases where test names passed in are missing package names.

* Require tracker_id in merge-commit-db

* Ignore any other special params on commit db when looking for revs

* Updated template.build.xml to use analyzer produced test patterns.

* Updated README.

* All new bugs entered will get tracker id

* Small change in Formatter and removed unneccessary files.

* Use OS-specific path separater to find build file.

* Changed project directory to relative path template.build.xml.

* Fix call to create_project in promot to db

* Fix missing variable declaration in DB.pm

* Add tracker id at the rev list database

* Adding in tracker name but it isnt working for whatever reason

* Using n is not permitted for arguments with getopts who would have guessed that

* Allow case-insensitive user input.

* Modified README.

* Reorganize test directories and add new test cases for analyzer.

* Add one more test case.

* Update analyzer build file.

* Add one more edge case, and refactored code.

* Changed error message to print with debugger.

* Add one more test case.

* Moved subtask helper method to util.

* Move method to util.

* Analyze src,test,src_output,and test_output directories.

* Update test cases to support new functions, and update analyzer.jar.

* Fix wrong target input and hot fix on getting src.test.dir.

* Update README and analyzer.jar.

* Can supply src directory to the merge-commit-db script for projects with a non-standard src directory

* Clarified a few bits and added a few TODOs.

* Clarified 'project name' format.

* Attempt to normalize documentation, options, and code.

* Pass over scripts that initialize revisions.

* Removed invalid instruction.

* All bug-mining scripts are executable and don't require an explicit call of perl.

* Fixed broken merge.

* Improved the bug-mining README.

* Restored meta data for Time.

* Removed a file that should not be under version control

* Minor tweak in README.

* Moved build-analyzer utility program to another repository.

* Avoid keeping data of a failure bid.

* Revert a previous commit and export variables.

* Added info messages.

* Fail if the build system is not ant or maven.

* Fixed variables.

* Augmented the list of generic files that should be copied over.

* Re-use existing function to copy files.

* Augmented list of revision specific files.

* Copy over 'lib' directory.

* Copy over the repository directory.

* Fixed regex to identify the directory name.

* Update project_repos README file.

* Copy project submodule.

* Collect issues urls.
Fixed collection of issues from Google Code.

* Populate 'commit-db' with issue-tracker ID and URL.

* Promote a commit-db with issue-tracker ids and issue urls.

* Older commits first.

* -r parameter is mandatory.

* Attempt to simplify the step-by-step tutorial.

* Fix.

* Perform a couple sanity checks after minimizing a patch.

* Removed debug messages.

* Override global constant, otherwise checkout command it is not able of finding the project repository.

* Copy over the 'relevant_tests' directory.

* Added test cases for the bug-mining framework.

* Java-7 support.

* ${d4j.home}/framework/projects/ -> ${d4j.dir.projects}/

* Added test_bug_mining to travis configuration file.

* The bug-mining framework might require Apache Maven on the PATH to mine projects/bugs that use Maven as their build system.

* Attempt to debug Travis failure.

* Added module List::Util to the list of required Perl modules as the download-issues.pl script in the bug-mining framework requires two additional functions only available in recent versions: the 'all' function is available since version 1.33 and 'pairmap' function is available since 1.29.

* Relaxed assertions of trigger_tests and failing_tests.

* Attempt to address the ""Can't locate DBI.pm in @INC"" issue.

* Deleted debug message.

* Utility script get_modified_classes.pl requires diffstat to determine the modified files.

* Inform bug-mining users that diffstat must be installed.

* Several command-line options were not enabled. Some are still not used, but I allow them to be set, and have enabled the query option to actually work, as that is needed for projects like GSON that do not label issues as 'bug'

* Extracted issues ids from the commit history.

* Report the oldest bug report id. Commit c7a581e55fc988bd90fa4bb1b0acece5181b7c5f addressed 3 bug reports: #60 (https://sourceforge.net/p/joda-time/bugs/60 created in 2008-10-20), #65 (https://sourceforge.net/p/joda-time/bugs/65 created in 2009-01-31), and #102 (https://sourceforge.net/p/joda-time/bugs/102 created in 2010-11-04).

* Fix: report issues ids and not pull requests ids.

* Use the official google archive URL.

* Added subroutines to extract a bug report ID and a bug report URL.

* Fixed Chart commit-db file: all rows should have commas, even if no ID/URL is available.

* Re-use existing subroutines to extract a bug report id/url.

* Fixed commit-db path.

* Removed unused use.

* Updated version number.",MODIFY,"package edu.washington.cs.mut.testrunner;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import junit.framework.AssertionFailedError;
import junit.framework.Test;
import junit.framework.TestSuite;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.optional.junit.JUnitResultFormatter;
import org.apache.tools.ant.taskdefs.optional.junit.JUnitTest;

public class Formatter implements JUnitResultFormatter {

	private PrintStream ps;
	private PrintStream allTests;

	{
		try {
			this.ps = new PrintStream(new FileOutputStream(System.getProperty(""OUTFILE"", ""failing-tests.txt""), true), true);
			this.allTests = new PrintStream(new FileOutputStream(System.getProperty(""ALLTESTS"", ""all_tests""), true), true);
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	
	@Override
	public void endTestSuite(JUnitTest arg0) throws BuildException {
	}

	@Override
	public void setOutput(OutputStream arg0) {
	}

	@Override
	public void setSystemError(String arg0) {	
	}

	@Override
	public void setSystemOutput(String arg0) {
	}

	String className ;
	boolean alreadyPrinted = true;
	
	@Override
	public void startTestSuite(JUnitTest junitTest) throws BuildException {
		className = junitTest.getName();
		alreadyPrinted = false;
	}
	

	@Override
	public void addError(Test test, Throwable t) {
		handle(test, t);
	}

	@Override
	public void addFailure(Test test, AssertionFailedError t) {
		handle(test,t);
	}
	
	private void handle(Test test, Throwable t) {
		String prefix = ""--- "" ;
		String className = null;
		String methodName = null;

		if (test == null) { // if test is null it indicates an initialization error for the class
			failClass(t, prefix);  
			return;
		}
		
		{
			Pattern regexp = Pattern.compile(""(.*)\\((.*)\\)"");
			Matcher match  = regexp.matcher(test.toString());
			if (match.matches()) {
				className = match.group(2);
				methodName = match.group(1);
			}
		}
		{
			Pattern regexp = Pattern.compile(""(.*):(.*)""); // for some weird reson this format is used for Timeout in Junit4
			Matcher match  = regexp.matcher(test.toString());
			if (match.matches()) {
				className = match.group(1);
				methodName = match.group(2);
			}
		}
		
		if (""warning"".equals(methodName) || ""initializationError"".equals(methodName)) {
			failClass(t, prefix); // there is an issue with the class, not the method.
		} else if (null != methodName && null != className) {
			if (isJunit4InitFail(t)) {
				failClass(t, prefix);
			} else {
				ps.println(prefix + className + ""::"" + methodName); // normal case
				t.printStackTrace(ps);
			}
		} else {
			ps.print(prefix + ""broken test input "" + test.toString());
			t.printStackTrace(ps);
		}
		
	}

	private void failClass(Throwable t, String prefix) {
		if (!this.alreadyPrinted) {
			ps.println(prefix + this.className);
			t.printStackTrace(ps);
			this.alreadyPrinted = true;
		}
	}

	private boolean isJunit4InitFail(Throwable t) {
		for (StackTraceElement ste: t.getStackTrace()) {
			if (""createTest"".equals(ste.getMethodName())) {
				return true;
			}
		}
		return false;
	}

	@Override
	public void endTest(Test test) {
	}

	@Override
	public void startTest(Test test) {
	    allTests.println(test.toString());
	}
}
","package edu.washington.cs.mut.testrunner;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import junit.framework.AssertionFailedError;
import junit.framework.Test;
import junit.framework.TestSuite;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.taskdefs.optional.junit.JUnitResultFormatter;
import org.apache.tools.ant.taskdefs.optional.junit.JUnitTest;

public class Formatter implements JUnitResultFormatter {

	private PrintStream ps;
	private PrintStream allTests;

	{
		try {
			this.ps = new PrintStream(new FileOutputStream(System.getProperty(""OUTFILE"", ""failing-tests.txt""), true), true);
			this.allTests = new PrintStream(new FileOutputStream(System.getProperty(""ALLTESTS"", ""all_tests""), true), true);
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}
	}

	@Override
	public void endTestSuite(JUnitTest arg0) throws BuildException {
	}

	@Override
	public void setOutput(OutputStream arg0) {
	}

	@Override
	public void setSystemError(String arg0) {
	}

	@Override
	public void setSystemOutput(String arg0) {
	}

	String className ;
	boolean alreadyPrinted = true;

	@Override
	public void startTestSuite(JUnitTest junitTest) throws BuildException {
		className = junitTest.getName();
		alreadyPrinted = false;
	}


	@Override
	public void addError(Test test, Throwable t) {
		handle(test, t);
	}

	@Override
	public void addFailure(Test test, AssertionFailedError t) {
		handle(test,t);
	}

	private void handle(Test test, Throwable t) {
		String prefix = ""--- "" ;
		String className = null;
		String methodName = null;

		if (test == null) { // if test is null it indicates an initialization error for the class
			failClass(t, prefix);
			return;
		}

		className = test.getClass().getName();
		{
			Pattern regexp = Pattern.compile(""(.*)\\((.*)\\)\\s*"");
			Matcher match  = regexp.matcher(test.toString());
			if (match.matches()) {
				// Class name will equal to junit.framework.Junit4TestCaseFacade if Junit4
				// style tests are ran with Junit3 style test runner.
				if(className.equals(""junit.framework.JUnit4TestCaseFacade""))
					className = match.group(2);
				methodName = match.group(1);
			}
		}
		{
			Pattern regexp = Pattern.compile(""(.*):(.*)\\s*""); // for some weird reson this format is used for Timeout in Junit4
			Matcher match  = regexp.matcher(test.toString());
			if (match.matches()) {
				className = match.group(1);
				methodName = match.group(2);
			}
		}

		if (""warning"".equals(methodName) || ""initializationError"".equals(methodName)) {
			failClass(t, prefix); // there is an issue with the class, not the method.
		} else if (null != methodName && null != className) {
			if (isJunit4InitFail(t)) {
				failClass(t, prefix);
			} else {
				ps.println(prefix + className + ""::"" + methodName); // normal case
				t.printStackTrace(ps);
			}
		} else {
			ps.print(prefix + ""broken test input "" + test.toString());
			t.printStackTrace(ps);
		}

	}

	private void failClass(Throwable t, String prefix) {
		if (!this.alreadyPrinted) {
			ps.println(prefix + this.className);
			t.printStackTrace(ps);
			this.alreadyPrinted = true;
		}
	}

	private boolean isJunit4InitFail(Throwable t) {
		for (StackTraceElement ste: t.getStackTrace()) {
			if (""createTest"".equals(ste.getMethodName())) {
				return true;
			}
		}
		return false;
	}

	@Override
	public void endTest(Test test) {
	}

	@Override
	public void startTest(Test test) {
	    allTests.println(test.toString());
	}
}
"
a83e47921152721569cb95d6d7b91c4be277d940,"Fix the number of uncompilable tests.
When a `test X` has multiple compilation errors, the [Defects4J fix_test_suite.pl](https://github.com/rjust/defects4j/blob/master/framework/util/fix_test_suite.pl) script tries to fix `test X` as many times as the number of compilation errors.  This leads the script to report an incorrect number of uncompilable tests.  This commit set the maximum number of errors reported by javac to 1 so that each test is fixed once.",ADD,,"/*
 * This file was automatically generated by EvoSuite
 * Fri Mar 31 20:20:01 GMT 2023
 */

package com.google.gson.internal;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Collection;
import java.util.NoSuchElementException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.PrivateAccess;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class $Gson$Types_ESTest extends $Gson$Types_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Class class1 = (Class).Gson.Types.getSupertype(wildcardType0, class0, class0);
      assertNotNull(class1);
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isPrimitive());
      
      boolean boolean0 = .Gson.Types.equals((Type) class1, (Type) genericArrayType0);
      assertFalse(boolean0);
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isPrimitive());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      try { 
        PrivateAccess.callDefaultConstructorOfTheClassUnderTest();
        fail(""Expecting exception: UnsupportedOperationException"");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.google.gson.internal.$Gson$Types"", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      WildcardType wildcardType1 = .Gson.Types.supertypeOf(wildcardType0);
      assertNotNull(wildcardType1);
      assertTrue(wildcardType1.equals((Object)wildcardType0));
      assertNotSame(wildcardType0, wildcardType1);
      assertNotSame(wildcardType1, wildcardType0);
      
      boolean boolean0 = .Gson.Types.equal(wildcardType0, wildcardType1);
      assertTrue(wildcardType0.equals((Object)wildcardType1));
      assertTrue(wildcardType1.equals((Object)wildcardType0));
      assertNotSame(wildcardType0, wildcardType1);
      assertNotSame(wildcardType1, wildcardType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf(class0);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.subtypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Class<?> class1 = .Gson.Types.getRawType(wildcardType0);
      assertNotNull(class1);
      assertFalse(class1.isAnnotation());
      assertEquals(""class [Ljava.lang.reflect.WildcardType;"", class1.toString());
      assertFalse(class1.isInterface());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isArray());
      
      Type[] typeArray0 = new Type[0];
      ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(class1, genericArrayType0, typeArray0);
      assertNotNull(parameterizedType0);
      assertEquals(0, typeArray0.length);
      assertFalse(class1.isAnnotation());
      assertEquals(""class [Ljava.lang.reflect.WildcardType;"", class1.toString());
      assertFalse(class1.isInterface());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isArray());
      
      Type type0 = .Gson.Types.canonicalize(parameterizedType0);
      assertNotNull(type0);
      assertEquals(0, typeArray0.length);
      assertFalse(class1.isAnnotation());
      assertEquals(""class [Ljava.lang.reflect.WildcardType;"", class1.toString());
      assertFalse(class1.isInterface());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isArray());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      Class class1 = (Class).Gson.Types.resolve((Type) null, class0, class0);
      assertNotNull(class1);
      assertTrue(class1.isInterface());
      assertEquals(1537, class1.getModifiers());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isArray());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      
      Type[] typeArray0 = new Type[7];
      typeArray0[0] = (Type) class0;
      typeArray0[1] = (Type) class1;
      typeArray0[2] = (Type) class0;
      typeArray0[3] = (Type) class1;
      typeArray0[4] = (Type) class1;
      typeArray0[5] = (Type) class0;
      typeArray0[6] = (Type) class1;
      ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(class1, class0, typeArray0);
      assertNotNull(parameterizedType0);
      assertEquals(7, typeArray0.length);
      assertTrue(class1.isInterface());
      assertEquals(1537, class1.getModifiers());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isArray());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf(parameterizedType0);
      assertNotNull(genericArrayType0);
      assertEquals(7, typeArray0.length);
      assertTrue(class1.isInterface());
      assertEquals(1537, class1.getModifiers());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isArray());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      
      Class<?> class2 = .Gson.Types.getRawType(genericArrayType0);
      assertNotNull(class2);
      assertEquals(7, typeArray0.length);
      assertTrue(class1.isInterface());
      assertEquals(1537, class1.getModifiers());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isArray());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertFalse(class2.isInterface());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.isPrimitive());
      assertEquals(1041, class2.getModifiers());
      assertEquals(""class [Ljava.lang.reflect.WildcardType;"", class2.toString());
      assertTrue(class2.isArray());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      // Undeclared exception!
      try { 
        .Gson.Types.getRawType(genericArrayType0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Expected a Class, ParameterizedType, or GenericArrayType, but <null> is of type null
         //
         verifyException(""com.google.gson.internal.$Gson$Types"", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Type type0 = mock(Type.class, new ViolatedAssumptionAnswer());
      doReturn(""[e;[<77P,?8)\""3"").when(type0).toString();
      // Undeclared exception!
      try { 
        .Gson.Types.getRawType(type0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // Expected a Class, ParameterizedType, or GenericArrayType, but <[e;[<77P,?8)\""3> is of type org.evosuite.shaded.org.mockito.codegen.Type$MockitoMock$1680078041
         //
         verifyException(""com.google.gson.internal.$Gson$Types"", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      WildcardType wildcardType1 = .Gson.Types.subtypeOf(class0);
      assertNotNull(wildcardType1);
      assertFalse(wildcardType1.equals((Object)wildcardType0));
      assertNotSame(wildcardType1, wildcardType0);
      
      boolean boolean0 = .Gson.Types.equal(wildcardType0, wildcardType1);
      assertFalse(wildcardType0.equals((Object)wildcardType1));
      assertFalse(wildcardType1.equals((Object)wildcardType0));
      assertNotSame(wildcardType0, wildcardType1);
      assertNotSame(wildcardType1, wildcardType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      boolean boolean0 = .Gson.Types.equal((Object) null, wildcardType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      Type type0 = .Gson.Types.getSupertype((Type) null, class0, class0);
      assertNull(type0);
      
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      Type[] typeArray0 = new Type[0];
      ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(genericArrayType0, genericArrayType0, typeArray0);
      assertNotNull(parameterizedType0);
      assertEquals(0, typeArray0.length);
      
      boolean boolean0 = .Gson.Types.equals((Type) parameterizedType0, type0);
      assertEquals(0, typeArray0.length);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      Type type0 = .Gson.Types.getSupertype((Type) null, class0, class0);
      assertNull(type0);
      
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      Type[] typeArray0 = new Type[0];
      ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(type0, genericArrayType0, typeArray0);
      assertNotNull(parameterizedType0);
      assertEquals(0, typeArray0.length);
      
      Type type1 = .Gson.Types.canonicalize(parameterizedType0);
      assertNotNull(type1);
      assertEquals(0, typeArray0.length);
      
      boolean boolean0 = .Gson.Types.equals((Type) parameterizedType0, type1);
      assertEquals(0, typeArray0.length);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Class<?> class1 = .Gson.Types.getRawType(wildcardType0);
      assertNotNull(class1);
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isAnnotation());
      
      Type[] typeArray0 = new Type[0];
      ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner((Type) null, (Type) null, typeArray0);
      assertNotNull(parameterizedType0);
      assertEquals(0, typeArray0.length);
      
      Type[] typeArray1 = new Type[3];
      assertFalse(typeArray1.equals((Object)typeArray0));
      
      typeArray1[0] = (Type) class0;
      typeArray1[1] = (Type) wildcardType0;
      typeArray1[2] = (Type) wildcardType0;
      ParameterizedType parameterizedType1 = .Gson.Types.newParameterizedTypeWithOwner(wildcardType0, class1, typeArray1);
      assertNotNull(parameterizedType1);
      assertFalse(typeArray1.equals((Object)typeArray0));
      assertFalse(parameterizedType1.equals((Object)parameterizedType0));
      assertEquals(3, typeArray1.length);
      assertNotSame(typeArray1, typeArray0);
      assertNotSame(parameterizedType1, parameterizedType0);
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isAnnotation());
      
      boolean boolean0 = .Gson.Types.equals((Type) parameterizedType1, (Type) parameterizedType0);
      assertFalse(typeArray0.equals((Object)typeArray1));
      assertFalse(parameterizedType0.equals((Object)parameterizedType1));
      assertFalse(typeArray1.equals((Object)typeArray0));
      assertFalse(parameterizedType1.equals((Object)parameterizedType0));
      assertEquals(0, typeArray0.length);
      assertEquals(3, typeArray1.length);
      assertNotSame(typeArray0, typeArray1);
      assertNotSame(parameterizedType0, parameterizedType1);
      assertNotSame(typeArray1, typeArray0);
      assertNotSame(parameterizedType1, parameterizedType0);
      assertFalse(boolean0);
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isAnnotation());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      boolean boolean0 = .Gson.Types.equals((Type) genericArrayType0, (Type) wildcardType0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Class<?> class0 = .Gson.Types.getRawType(wildcardType0);
      assertNotNull(class0);
      assertFalse(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertEquals(""class java.lang.Object"", class0.toString());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertEquals(1, class0.getModifiers());
      assertFalse(class0.isArray());
      assertFalse(class0.isAnnotation());
      
      GenericArrayType genericArrayType1 = .Gson.Types.arrayOf(class0);
      assertNotNull(genericArrayType1);
      assertFalse(genericArrayType1.equals((Object)genericArrayType0));
      assertNotSame(genericArrayType0, genericArrayType1);
      assertNotSame(genericArrayType1, genericArrayType0);
      assertFalse(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertEquals(""class java.lang.Object"", class0.toString());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertEquals(1, class0.getModifiers());
      assertFalse(class0.isArray());
      assertFalse(class0.isAnnotation());
      
      WildcardType wildcardType1 = .Gson.Types.supertypeOf(genericArrayType1);
      assertNotNull(wildcardType1);
      assertFalse(genericArrayType0.equals((Object)genericArrayType1));
      assertFalse(genericArrayType1.equals((Object)genericArrayType0));
      assertFalse(wildcardType1.equals((Object)wildcardType0));
      assertNotSame(genericArrayType0, genericArrayType1);
      assertNotSame(wildcardType0, wildcardType1);
      assertNotSame(genericArrayType1, genericArrayType0);
      assertNotSame(wildcardType1, wildcardType0);
      assertFalse(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertEquals(""class java.lang.Object"", class0.toString());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertEquals(1, class0.getModifiers());
      assertFalse(class0.isArray());
      assertFalse(class0.isAnnotation());
      
      boolean boolean0 = .Gson.Types.equal(wildcardType0, wildcardType1);
      assertFalse(genericArrayType0.equals((Object)genericArrayType1));
      assertFalse(wildcardType0.equals((Object)wildcardType1));
      assertFalse(genericArrayType1.equals((Object)genericArrayType0));
      assertFalse(wildcardType1.equals((Object)wildcardType0));
      assertNotSame(genericArrayType0, genericArrayType1);
      assertNotSame(wildcardType0, wildcardType1);
      assertNotSame(genericArrayType1, genericArrayType0);
      assertNotSame(wildcardType1, wildcardType0);
      assertFalse(boolean0);
      assertFalse(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertEquals(""class java.lang.Object"", class0.toString());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertEquals(1, class0.getModifiers());
      assertFalse(class0.isArray());
      assertFalse(class0.isAnnotation());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Class class1 = (Class).Gson.Types.getSupertype(wildcardType0, class0, class0);
      assertNotNull(class1);
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isAnnotation());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isPrimitive());
      
      boolean boolean0 = .Gson.Types.equals((Type) wildcardType0, (Type) class1);
      assertFalse(boolean0);
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isAnnotation());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isPrimitive());
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      int int0 = .Gson.Types.hashCodeOrZero((Object) null);
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      int int0 = .Gson.Types.hashCodeOrZero(wildcardType0);
      assertEquals(3, int0);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      // Undeclared exception!
      try { 
        .Gson.Types.typeToString((Type) null);
        fail(""Expecting exception: NullPointerException"");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""org.evosuite.runtime.System"", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Class<?> class0 = .Gson.Types.getRawType(wildcardType0);
      assertNotNull(class0);
      assertEquals(1, class0.getModifiers());
      assertFalse(class0.isAnnotation());
      assertEquals(""class java.lang.Object"", class0.toString());
      assertFalse(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertFalse(class0.isArray());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      
      String string0 = .Gson.Types.typeToString(class0);
      assertNotNull(string0);
      assertEquals(""java.lang.Object"", string0);
      assertEquals(1, class0.getModifiers());
      assertFalse(class0.isAnnotation());
      assertEquals(""class java.lang.Object"", class0.toString());
      assertFalse(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertFalse(class0.isArray());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Class class1 = (Class).Gson.Types.getSupertype(wildcardType0, class0, class0);
      assertNotNull(class1);
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(1, class1.getModifiers());
      
      Class class2 = (Class).Gson.Types.getGenericSupertype(wildcardType0, class1, class0);
      assertNotNull(class2);
      assertFalse(class2.equals((Object)class1));
      assertNotSame(class1, class2);
      assertNotSame(class2, class1);
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(1, class1.getModifiers());
      assertEquals(""interface java.lang.reflect.WildcardType"", class2.toString());
      assertEquals(1537, class2.getModifiers());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isArray());
      assertTrue(class2.isInterface());
      assertFalse(class2.isPrimitive());
      assertFalse(class2.isAnnotation());
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Class<?> class1 = .Gson.Types.getRawType(wildcardType0);
      assertNotNull(class1);
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      
      Class class2 = (Class).Gson.Types.resolve((Type) null, class1, class1);
      assertNotNull(class2);
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertEquals(1, class2.getModifiers());
      assertEquals(""class java.lang.Object"", class2.toString());
      assertFalse(class2.isInterface());
      assertFalse(class2.isArray());
      assertFalse(class2.isPrimitive());
      assertFalse(class2.isAnnotation());
      
      Class class3 = (Class).Gson.Types.getSupertype(wildcardType0, class0, class2);
      assertNotNull(class3);
      assertSame(class2, class3);
      assertSame(class3, class2);
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertEquals(1, class2.getModifiers());
      assertEquals(""class java.lang.Object"", class2.toString());
      assertFalse(class2.isInterface());
      assertFalse(class2.isArray());
      assertFalse(class2.isPrimitive());
      assertFalse(class2.isAnnotation());
      assertFalse(class3.isAnnotation());
      assertFalse(class3.isInterface());
      assertFalse(class3.isArray());
      assertFalse(class3.isEnum());
      assertEquals(""class java.lang.Object"", class3.toString());
      assertFalse(class3.isSynthetic());
      assertFalse(class3.isPrimitive());
      assertEquals(1, class3.getModifiers());
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      Type type0 = .Gson.Types.getArrayComponentType(class0);
      assertNull(type0);
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      Type type0 = .Gson.Types.getArrayComponentType(genericArrayType0);
      assertNull(type0);
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      // Undeclared exception!
      try { 
        .Gson.Types.getMapKeyAndValueTypes((Type) null, class0);
        fail(""Expecting exception: IllegalArgumentException"");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.google.gson.internal.$Gson$Preconditions"", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Class<?> class1 = .Gson.Types.getRawType(wildcardType0);
      assertNotNull(class1);
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isEnum());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      
      GenericArrayType genericArrayType1 = .Gson.Types.arrayOf(class1);
      assertNotNull(genericArrayType1);
      assertFalse(genericArrayType1.equals((Object)genericArrayType0));
      assertNotSame(genericArrayType0, genericArrayType1);
      assertNotSame(genericArrayType1, genericArrayType0);
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isEnum());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      
      Class<?> class2 = .Gson.Types.getRawType(genericArrayType1);
      assertNotNull(class2);
      assertFalse(genericArrayType0.equals((Object)genericArrayType1));
      assertFalse(genericArrayType1.equals((Object)genericArrayType0));
      assertFalse(class2.equals((Object)class1));
      assertNotSame(genericArrayType0, genericArrayType1);
      assertNotSame(class1, class2);
      assertNotSame(genericArrayType1, genericArrayType0);
      assertNotSame(class2, class1);
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isEnum());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.isPrimitive());
      assertEquals(""class [Ljava.lang.Object;"", class2.toString());
      assertFalse(class2.isInterface());
      assertEquals(1041, class2.getModifiers());
      assertTrue(class2.isArray());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      
      Class class3 = (Class).Gson.Types.resolve((Type) null, class0, class2);
      assertNotNull(class3);
      assertFalse(genericArrayType0.equals((Object)genericArrayType1));
      assertFalse(class1.equals((Object)class2));
      assertFalse(genericArrayType1.equals((Object)genericArrayType0));
      assertFalse(class2.equals((Object)class1));
      assertNotSame(genericArrayType0, genericArrayType1);
      assertNotSame(class1, class2);
      assertNotSame(genericArrayType1, genericArrayType0);
      assertNotSame(class2, class1);
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isEnum());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals(""class java.lang.Object"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.isPrimitive());
      assertEquals(""class [Ljava.lang.Object;"", class2.toString());
      assertFalse(class2.isInterface());
      assertEquals(1041, class2.getModifiers());
      assertTrue(class2.isArray());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class3.isInterface());
      assertEquals(""class [Ljava.lang.Object;"", class3.toString());
      assertFalse(class3.isAnnotation());
      assertFalse(class3.isPrimitive());
      assertEquals(1041, class3.getModifiers());
      assertTrue(class3.isArray());
      assertFalse(class3.isEnum());
      assertFalse(class3.isSynthetic());
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Type[] typeArray0 = new Type[0];
      ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(wildcardType0, genericArrayType0, typeArray0);
      assertNotNull(parameterizedType0);
      assertEquals(0, typeArray0.length);
      
      Type type0 = .Gson.Types.getSupertype(parameterizedType0, class0, class0);
      assertNotNull(type0);
      assertEquals(0, typeArray0.length);
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Class<WildcardType> class0 = WildcardType.class;
      Class class1 = (Class).Gson.Types.canonicalize(class0);
      assertNotNull(class1);
      assertFalse(class1.isArray());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertEquals(1537, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isInterface());
      assertFalse(class1.isEnum());
      assertFalse(class1.isAnnotation());
      
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf(class1);
      assertNotNull(genericArrayType0);
      assertFalse(class1.isArray());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertEquals(1537, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isInterface());
      assertFalse(class1.isEnum());
      assertFalse(class1.isAnnotation());
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      assertFalse(class1.isArray());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertEquals(1537, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isInterface());
      assertFalse(class1.isEnum());
      assertFalse(class1.isAnnotation());
      
      Type[] typeArray0 = new Type[0];
      WildcardType wildcardType1 = .Gson.Types.subtypeOf(wildcardType0);
      assertNotNull(wildcardType1);
      assertFalse(wildcardType1.equals((Object)wildcardType0));
      assertNotSame(wildcardType0, wildcardType1);
      assertNotSame(wildcardType1, wildcardType0);
      assertFalse(class1.isArray());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertEquals(1537, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isInterface());
      assertFalse(class1.isEnum());
      assertFalse(class1.isAnnotation());
      
      ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(wildcardType1, class0, typeArray0);
      assertNotNull(parameterizedType0);
      assertFalse(wildcardType0.equals((Object)wildcardType1));
      assertFalse(wildcardType1.equals((Object)wildcardType0));
      assertEquals(0, typeArray0.length);
      assertNotSame(wildcardType0, wildcardType1);
      assertNotSame(wildcardType1, wildcardType0);
      assertFalse(class1.isArray());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertEquals(1537, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isInterface());
      assertFalse(class1.isEnum());
      assertFalse(class1.isAnnotation());
      
      Type type0 = .Gson.Types.getSupertype(parameterizedType0, class0, class0);
      assertNotNull(type0);
      assertFalse(wildcardType0.equals((Object)wildcardType1));
      assertFalse(wildcardType1.equals((Object)wildcardType0));
      assertEquals(0, typeArray0.length);
      assertNotSame(wildcardType0, wildcardType1);
      assertNotSame(wildcardType1, wildcardType0);
      assertFalse(class1.isArray());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      assertEquals(1537, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isInterface());
      assertFalse(class1.isEnum());
      assertFalse(class1.isAnnotation());
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
      assertNotNull(genericArrayType0);
      
      WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
      assertNotNull(wildcardType0);
      
      Type[] typeArray0 = new Type[3];
      try { 
        PrivateAccess.callMethod((Class<.Gson.Types>) .Gson.Types.class, (.Gson.Types) null, ""indexOf"", (Object) typeArray0, (Class<?>) Object[].class, (Object) wildcardType0, (Class<?>) Object.class);
        fail(""Expecting exception: NoSuchElementException"");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.google.gson.internal.$Gson$Types"", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Type type0 = mock(Type.class, new ViolatedAssumptionAnswer());
      Class<WildcardType> class0 = WildcardType.class;
      Collection<TypeVariable> collection0 = (Collection<TypeVariable>) mock(Collection.class, new ViolatedAssumptionAnswer());
      Class class1 = (Class)PrivateAccess.callMethod((Class<.Gson.Types>) .Gson.Types.class, (.Gson.Types) null, ""resolve"", (Object) type0, (Class<?>) Type.class, (Object) class0, (Class<?>) Class.class, (Object) class0, (Class<?>) Type.class, (Object) collection0, (Class<?>) Collection.class);
      assertNotNull(class1);
      assertFalse(class1.isArray());
      assertFalse(class1.isAnnotation());
      assertTrue(class1.isInterface());
      assertEquals(1537, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
      
      Object[] objectArray0 = new Object[2];
      objectArray0[0] = (Object) class0;
      Integer integer0 = (Integer)PrivateAccess.callMethod((Class<.Gson.Types>) .Gson.Types.class, (.Gson.Types) null, ""indexOf"", (Object) objectArray0, (Class<?>) Object[].class, (Object) class1, (Class<?>) Object.class);
      assertNotNull(integer0);
      assertEquals(2, objectArray0.length);
      assertEquals(0, (int)integer0);
      assertFalse(class1.isArray());
      assertFalse(class1.isAnnotation());
      assertTrue(class1.isInterface());
      assertEquals(1537, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
      assertFalse(class1.isPrimitive());
  }
}
"
a83e47921152721569cb95d6d7b91c4be277d940,"Fix the number of uncompilable tests.
When a `test X` has multiple compilation errors, the [Defects4J fix_test_suite.pl](https://github.com/rjust/defects4j/blob/master/framework/util/fix_test_suite.pl) script tries to fix `test X` as many times as the number of compilation errors.  This leads the script to report an incorrect number of uncompilable tests.  This commit set the maximum number of errors reported by javac to 1 so that each test is fixed once.",ADD,,"/**
 * Scaffolding file used to store all the setups needed to run 
 * tests automatically generated by EvoSuite
 * Fri Mar 31 20:20:01 GMT 2023
 */

package com.google.gson.internal;

import org.evosuite.runtime.annotation.EvoSuiteClassExclude;
import org.junit.BeforeClass;
import org.junit.Before;
import org.junit.After;
import org.junit.AfterClass;
import org.evosuite.runtime.sandbox.Sandbox;
import org.evosuite.runtime.sandbox.Sandbox.SandboxMode;

import static org.evosuite.shaded.org.mockito.Mockito.*;
@EvoSuiteClassExclude
public class $Gson$Types_ESTest_scaffolding {

  @org.junit.Rule
  public org.evosuite.runtime.vnet.NonFunctionalRequirementRule nfr = new org.evosuite.runtime.vnet.NonFunctionalRequirementRule();

  private static final java.util.Properties defaultProperties = (java.util.Properties) java.lang.System.getProperties().clone(); 

  private org.evosuite.runtime.thread.ThreadStopper threadStopper =  new org.evosuite.runtime.thread.ThreadStopper (org.evosuite.runtime.thread.KillSwitchHandler.getInstance(), 3000);


  @BeforeClass
  public static void initEvoSuiteFramework() { 
    org.evosuite.runtime.RuntimeSettings.className = ""com.google.gson.internal.$Gson$Types""; 
    org.evosuite.runtime.GuiSupport.initialize(); 
    org.evosuite.runtime.RuntimeSettings.maxNumberOfThreads = 100; 
    org.evosuite.runtime.RuntimeSettings.maxNumberOfIterationsPerLoop = 10000; 
    org.evosuite.runtime.RuntimeSettings.mockSystemIn = true; 
    org.evosuite.runtime.RuntimeSettings.sandboxMode = org.evosuite.runtime.sandbox.Sandbox.SandboxMode.RECOMMENDED; 
    org.evosuite.runtime.sandbox.Sandbox.initializeSecurityManagerForSUT(); 
    org.evosuite.runtime.classhandling.JDKClassResetter.init();
    setSystemProperties();
    initializeClasses();
    org.evosuite.runtime.Runtime.getInstance().resetRuntime(); 
    try { initMocksToAvoidTimeoutsInTheTests(); } catch(ClassNotFoundException e) {} 
  } 

  @AfterClass
  public static void clearEvoSuiteFramework(){ 
    Sandbox.resetDefaultSecurityManager(); 
    java.lang.System.setProperties((java.util.Properties) defaultProperties.clone()); 
  } 

  @Before
  public void initTestCase(){ 
    threadStopper.storeCurrentThreads();
    threadStopper.startRecordingTime();
    org.evosuite.runtime.jvm.ShutdownHookHandler.getInstance().initHandler(); 
    org.evosuite.runtime.sandbox.Sandbox.goingToExecuteSUTCode(); 
    setSystemProperties(); 
    org.evosuite.runtime.GuiSupport.setHeadless(); 
    org.evosuite.runtime.Runtime.getInstance().resetRuntime(); 
    org.evosuite.runtime.agent.InstrumentingAgent.activate(); 
  } 

  @After
  public void doneWithTestCase(){ 
    threadStopper.killAndJoinClientThreads();
    org.evosuite.runtime.jvm.ShutdownHookHandler.getInstance().safeExecuteAddedHooks(); 
    org.evosuite.runtime.classhandling.JDKClassResetter.reset(); 
    resetClasses(); 
    org.evosuite.runtime.sandbox.Sandbox.doneWithExecutingSUTCode(); 
    org.evosuite.runtime.agent.InstrumentingAgent.deactivate(); 
    org.evosuite.runtime.GuiSupport.restoreHeadlessMode(); 
  } 

  public static void setSystemProperties() {
 
    java.lang.System.setProperties((java.util.Properties) defaultProperties.clone()); 
    java.lang.System.setProperty(""user.dir"", ""/tmp/slurm_344957/jcampos-15550-aeaba38a4c25ae6a274a0cd3fb1cd825-Gson-18""); 
    java.lang.System.setProperty(""java.io.tmpdir"", ""/tmp""); 
  }

  private static void initializeClasses() {
    org.evosuite.runtime.classhandling.ClassStateSupport.initializeClasses($Gson$Types_ESTest_scaffolding.class.getClassLoader() ,
      ""com.google.gson.internal.$Gson$Types"",
      ""com.google.gson.internal.$Gson$Preconditions"",
      ""com.google.gson.internal.$Gson$Types$WildcardTypeImpl"",
      ""com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl"",
      ""com.google.gson.internal.$Gson$Types$GenericArrayTypeImpl""
    );
  } 
  private static void initMocksToAvoidTimeoutsInTheTests() throws ClassNotFoundException { 
    mock(Class.forName(""java.lang.reflect.Type"", false, $Gson$Types_ESTest_scaffolding.class.getClassLoader()));
    mock(Class.forName(""java.util.Collection"", false, $Gson$Types_ESTest_scaffolding.class.getClassLoader()));
  }

  private static void resetClasses() {
    org.evosuite.runtime.classhandling.ClassResetter.getInstance().setClassLoader($Gson$Types_ESTest_scaffolding.class.getClassLoader()); 

    org.evosuite.runtime.classhandling.ClassStateSupport.resetClasses(
      ""com.google.gson.internal.$Gson$Types"",
      ""com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl"",
      ""com.google.gson.internal.$Gson$Types$GenericArrayTypeImpl"",
      ""com.google.gson.internal.$Gson$Types$WildcardTypeImpl"",
      ""com.google.gson.internal.$Gson$Preconditions""
    );
  }
}
"
a83e47921152721569cb95d6d7b91c4be277d940,"Fix the number of uncompilable tests.
When a `test X` has multiple compilation errors, the [Defects4J fix_test_suite.pl](https://github.com/rjust/defects4j/blob/master/framework/util/fix_test_suite.pl) script tries to fix `test X` as many times as the number of compilation errors.  This leads the script to report an incorrect number of uncompilable tests.  This commit set the maximum number of errors reported by javac to 1 so that each test is fixed once.",ADD,,"/*
 * This file was automatically generated by EvoSuite
 * Fri Mar 31 20:20:01 GMT 2023
 */

package com.google.gson.internal;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Collection;
import java.util.NoSuchElementException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.PrivateAccess;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class $Gson$Types_ESTest extends $Gson$Types_ESTest_scaffolding {

  @Test
  public void test00() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test00()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Class class1 = (Class).Gson.Types.getSupertype(wildcardType0, class0, class0);
//       assertNotNull(class1);
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertFalse(class1.isAnnotation());
//       assertFalse(class1.isPrimitive());
//       
//       boolean boolean0 = .Gson.Types.equals((Type) class1, (Type) genericArrayType0);
//       assertFalse(boolean0);
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertFalse(class1.isAnnotation());
//       assertFalse(class1.isPrimitive());
//   }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      try { 
        PrivateAccess.callDefaultConstructorOfTheClassUnderTest();
        fail(""Expecting exception: UnsupportedOperationException"");
      
      } catch(UnsupportedOperationException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException(""com.google.gson.internal.$Gson$Types"", e);
      }
  }

  @Test
  public void test02() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test02()  throws Throwable  {
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       WildcardType wildcardType1 = .Gson.Types.supertypeOf(wildcardType0);
//       assertNotNull(wildcardType1);
//       assertTrue(wildcardType1.equals((Object)wildcardType0));
//       assertNotSame(wildcardType0, wildcardType1);
//       assertNotSame(wildcardType1, wildcardType0);
//       
//       boolean boolean0 = .Gson.Types.equal(wildcardType0, wildcardType1);
//       assertTrue(wildcardType0.equals((Object)wildcardType1));
//       assertTrue(wildcardType1.equals((Object)wildcardType0));
//       assertNotSame(wildcardType0, wildcardType1);
//       assertNotSame(wildcardType1, wildcardType0);
//       assertTrue(boolean0);
//   }

  @Test
  public void test03() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test03()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf(class0);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.subtypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Class<?> class1 = .Gson.Types.getRawType(wildcardType0);
//       assertNotNull(class1);
//       assertFalse(class1.isAnnotation());
//       assertEquals(""class [Ljava.lang.reflect.WildcardType;"", class1.toString());
//       assertFalse(class1.isInterface());
//       assertEquals(1041, class1.getModifiers());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertTrue(class1.isArray());
//       
//       Type[] typeArray0 = new Type[0];
//       ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(class1, genericArrayType0, typeArray0);
//       assertNotNull(parameterizedType0);
//       assertEquals(0, typeArray0.length);
//       assertFalse(class1.isAnnotation());
//       assertEquals(""class [Ljava.lang.reflect.WildcardType;"", class1.toString());
//       assertFalse(class1.isInterface());
//       assertEquals(1041, class1.getModifiers());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertTrue(class1.isArray());
//       
//       Type type0 = .Gson.Types.canonicalize(parameterizedType0);
//       assertNotNull(type0);
//       assertEquals(0, typeArray0.length);
//       assertFalse(class1.isAnnotation());
//       assertEquals(""class [Ljava.lang.reflect.WildcardType;"", class1.toString());
//       assertFalse(class1.isInterface());
//       assertEquals(1041, class1.getModifiers());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertTrue(class1.isArray());
//   }

  @Test
  public void test04() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test04()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       Class class1 = (Class).Gson.Types.resolve((Type) null, class0, class0);
//       assertNotNull(class1);
//       assertTrue(class1.isInterface());
//       assertEquals(1537, class1.getModifiers());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isAnnotation());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       
//       Type[] typeArray0 = new Type[7];
//       typeArray0[0] = (Type) class0;
//       typeArray0[1] = (Type) class1;
//       typeArray0[2] = (Type) class0;
//       typeArray0[3] = (Type) class1;
//       typeArray0[4] = (Type) class1;
//       typeArray0[5] = (Type) class0;
//       typeArray0[6] = (Type) class1;
//       ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(class1, class0, typeArray0);
//       assertNotNull(parameterizedType0);
//       assertEquals(7, typeArray0.length);
//       assertTrue(class1.isInterface());
//       assertEquals(1537, class1.getModifiers());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isAnnotation());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf(parameterizedType0);
//       assertNotNull(genericArrayType0);
//       assertEquals(7, typeArray0.length);
//       assertTrue(class1.isInterface());
//       assertEquals(1537, class1.getModifiers());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isAnnotation());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       
//       Class<?> class2 = .Gson.Types.getRawType(genericArrayType0);
//       assertNotNull(class2);
//       assertEquals(7, typeArray0.length);
//       assertTrue(class1.isInterface());
//       assertEquals(1537, class1.getModifiers());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isAnnotation());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertFalse(class2.isInterface());
//       assertFalse(class2.isAnnotation());
//       assertFalse(class2.isPrimitive());
//       assertEquals(1041, class2.getModifiers());
//       assertEquals(""class [Ljava.lang.reflect.WildcardType;"", class2.toString());
//       assertTrue(class2.isArray());
//       assertFalse(class2.isEnum());
//       assertFalse(class2.isSynthetic());
//   }

  @Test
  public void test05() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test05()  throws Throwable  {
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       // Undeclared exception!
//       try { 
//         .Gson.Types.getRawType(genericArrayType0);
//         fail(""Expecting exception: IllegalArgumentException"");
//       
//       } catch(IllegalArgumentException e) {
//          //
//          // Expected a Class, ParameterizedType, or GenericArrayType, but <null> is of type null
//          //
//          verifyException(""com.google.gson.internal.$Gson$Types"", e);
//       }
//   }

  @Test
  public void test06() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test06()  throws Throwable  {
//       Type type0 = mock(Type.class, new ViolatedAssumptionAnswer());
//       doReturn(""[e;[<77P,?8)\""3"").when(type0).toString();
//       // Undeclared exception!
//       try { 
//         .Gson.Types.getRawType(type0);
//         fail(""Expecting exception: IllegalArgumentException"");
//       
//       } catch(IllegalArgumentException e) {
//          //
//          // Expected a Class, ParameterizedType, or GenericArrayType, but <[e;[<77P,?8)\""3> is of type org.evosuite.shaded.org.mockito.codegen.Type$MockitoMock$1680078041
//          //
//          verifyException(""com.google.gson.internal.$Gson$Types"", e);
//       }
//   }

  @Test
  public void test07() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test07()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       WildcardType wildcardType1 = .Gson.Types.subtypeOf(class0);
//       assertNotNull(wildcardType1);
//       assertFalse(wildcardType1.equals((Object)wildcardType0));
//       assertNotSame(wildcardType1, wildcardType0);
//       
//       boolean boolean0 = .Gson.Types.equal(wildcardType0, wildcardType1);
//       assertFalse(wildcardType0.equals((Object)wildcardType1));
//       assertFalse(wildcardType1.equals((Object)wildcardType0));
//       assertNotSame(wildcardType0, wildcardType1);
//       assertNotSame(wildcardType1, wildcardType0);
//       assertFalse(boolean0);
//   }

  @Test
  public void test08() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test08()  throws Throwable  {
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       boolean boolean0 = .Gson.Types.equal((Object) null, wildcardType0);
//       assertFalse(boolean0);
//   }

  @Test
  public void test09() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test09()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       Type type0 = .Gson.Types.getSupertype((Type) null, class0, class0);
//       assertNull(type0);
//       
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       Type[] typeArray0 = new Type[0];
//       ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(genericArrayType0, genericArrayType0, typeArray0);
//       assertNotNull(parameterizedType0);
//       assertEquals(0, typeArray0.length);
//       
//       boolean boolean0 = .Gson.Types.equals((Type) parameterizedType0, type0);
//       assertEquals(0, typeArray0.length);
//       assertFalse(boolean0);
//   }

  @Test
  public void test10() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test10()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       Type type0 = .Gson.Types.getSupertype((Type) null, class0, class0);
//       assertNull(type0);
//       
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       Type[] typeArray0 = new Type[0];
//       ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(type0, genericArrayType0, typeArray0);
//       assertNotNull(parameterizedType0);
//       assertEquals(0, typeArray0.length);
//       
//       Type type1 = .Gson.Types.canonicalize(parameterizedType0);
//       assertNotNull(type1);
//       assertEquals(0, typeArray0.length);
//       
//       boolean boolean0 = .Gson.Types.equals((Type) parameterizedType0, type1);
//       assertEquals(0, typeArray0.length);
//       assertTrue(boolean0);
//   }

  @Test
  public void test11() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test11()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Class<?> class1 = .Gson.Types.getRawType(wildcardType0);
//       assertNotNull(class1);
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isAnnotation());
//       
//       Type[] typeArray0 = new Type[0];
//       ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner((Type) null, (Type) null, typeArray0);
//       assertNotNull(parameterizedType0);
//       assertEquals(0, typeArray0.length);
//       
//       Type[] typeArray1 = new Type[3];
//       assertFalse(typeArray1.equals((Object)typeArray0));
//       
//       typeArray1[0] = (Type) class0;
//       typeArray1[1] = (Type) wildcardType0;
//       typeArray1[2] = (Type) wildcardType0;
//       ParameterizedType parameterizedType1 = .Gson.Types.newParameterizedTypeWithOwner(wildcardType0, class1, typeArray1);
//       assertNotNull(parameterizedType1);
//       assertFalse(typeArray1.equals((Object)typeArray0));
//       assertFalse(parameterizedType1.equals((Object)parameterizedType0));
//       assertEquals(3, typeArray1.length);
//       assertNotSame(typeArray1, typeArray0);
//       assertNotSame(parameterizedType1, parameterizedType0);
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isAnnotation());
//       
//       boolean boolean0 = .Gson.Types.equals((Type) parameterizedType1, (Type) parameterizedType0);
//       assertFalse(typeArray0.equals((Object)typeArray1));
//       assertFalse(parameterizedType0.equals((Object)parameterizedType1));
//       assertFalse(typeArray1.equals((Object)typeArray0));
//       assertFalse(parameterizedType1.equals((Object)parameterizedType0));
//       assertEquals(0, typeArray0.length);
//       assertEquals(3, typeArray1.length);
//       assertNotSame(typeArray0, typeArray1);
//       assertNotSame(parameterizedType0, parameterizedType1);
//       assertNotSame(typeArray1, typeArray0);
//       assertNotSame(parameterizedType1, parameterizedType0);
//       assertFalse(boolean0);
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isAnnotation());
//   }

  @Test
  public void test12() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test12()  throws Throwable  {
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       boolean boolean0 = .Gson.Types.equals((Type) genericArrayType0, (Type) wildcardType0);
//       assertFalse(boolean0);
//   }

  @Test
  public void test13() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test13()  throws Throwable  {
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Class<?> class0 = .Gson.Types.getRawType(wildcardType0);
//       assertNotNull(class0);
//       assertFalse(class0.isPrimitive());
//       assertFalse(class0.isInterface());
//       assertEquals(""class java.lang.Object"", class0.toString());
//       assertFalse(class0.isEnum());
//       assertFalse(class0.isSynthetic());
//       assertEquals(1, class0.getModifiers());
//       assertFalse(class0.isArray());
//       assertFalse(class0.isAnnotation());
//       
//       GenericArrayType genericArrayType1 = .Gson.Types.arrayOf(class0);
//       assertNotNull(genericArrayType1);
//       assertFalse(genericArrayType1.equals((Object)genericArrayType0));
//       assertNotSame(genericArrayType0, genericArrayType1);
//       assertNotSame(genericArrayType1, genericArrayType0);
//       assertFalse(class0.isPrimitive());
//       assertFalse(class0.isInterface());
//       assertEquals(""class java.lang.Object"", class0.toString());
//       assertFalse(class0.isEnum());
//       assertFalse(class0.isSynthetic());
//       assertEquals(1, class0.getModifiers());
//       assertFalse(class0.isArray());
//       assertFalse(class0.isAnnotation());
//       
//       WildcardType wildcardType1 = .Gson.Types.supertypeOf(genericArrayType1);
//       assertNotNull(wildcardType1);
//       assertFalse(genericArrayType0.equals((Object)genericArrayType1));
//       assertFalse(genericArrayType1.equals((Object)genericArrayType0));
//       assertFalse(wildcardType1.equals((Object)wildcardType0));
//       assertNotSame(genericArrayType0, genericArrayType1);
//       assertNotSame(wildcardType0, wildcardType1);
//       assertNotSame(genericArrayType1, genericArrayType0);
//       assertNotSame(wildcardType1, wildcardType0);
//       assertFalse(class0.isPrimitive());
//       assertFalse(class0.isInterface());
//       assertEquals(""class java.lang.Object"", class0.toString());
//       assertFalse(class0.isEnum());
//       assertFalse(class0.isSynthetic());
//       assertEquals(1, class0.getModifiers());
//       assertFalse(class0.isArray());
//       assertFalse(class0.isAnnotation());
//       
//       boolean boolean0 = .Gson.Types.equal(wildcardType0, wildcardType1);
//       assertFalse(genericArrayType0.equals((Object)genericArrayType1));
//       assertFalse(wildcardType0.equals((Object)wildcardType1));
//       assertFalse(genericArrayType1.equals((Object)genericArrayType0));
//       assertFalse(wildcardType1.equals((Object)wildcardType0));
//       assertNotSame(genericArrayType0, genericArrayType1);
//       assertNotSame(wildcardType0, wildcardType1);
//       assertNotSame(genericArrayType1, genericArrayType0);
//       assertNotSame(wildcardType1, wildcardType0);
//       assertFalse(boolean0);
//       assertFalse(class0.isPrimitive());
//       assertFalse(class0.isInterface());
//       assertEquals(""class java.lang.Object"", class0.toString());
//       assertFalse(class0.isEnum());
//       assertFalse(class0.isSynthetic());
//       assertEquals(1, class0.getModifiers());
//       assertFalse(class0.isArray());
//       assertFalse(class0.isAnnotation());
//   }

  @Test
  public void test14() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test14()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Class class1 = (Class).Gson.Types.getSupertype(wildcardType0, class0, class0);
//       assertNotNull(class1);
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isAnnotation());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       
//       boolean boolean0 = .Gson.Types.equals((Type) wildcardType0, (Type) class1);
//       assertFalse(boolean0);
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isAnnotation());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isPrimitive());
//   }

  @Test
  public void test15() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test15()  throws Throwable  {
//       int int0 = .Gson.Types.hashCodeOrZero((Object) null);
//       assertEquals(0, int0);
//   }

  @Test
  public void test16() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test16()  throws Throwable  {
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       int int0 = .Gson.Types.hashCodeOrZero(wildcardType0);
//       assertEquals(3, int0);
//   }

  @Test
  public void test17() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test17()  throws Throwable  {
//       // Undeclared exception!
//       try { 
//         .Gson.Types.typeToString((Type) null);
//         fail(""Expecting exception: NullPointerException"");
//       
//       } catch(NullPointerException e) {
//          //
//          // no message in exception (getMessage() returned null)
//          //
//          verifyException(""org.evosuite.runtime.System"", e);
//       }
//   }

  @Test
  public void test18() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test18()  throws Throwable  {
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Class<?> class0 = .Gson.Types.getRawType(wildcardType0);
//       assertNotNull(class0);
//       assertEquals(1, class0.getModifiers());
//       assertFalse(class0.isAnnotation());
//       assertEquals(""class java.lang.Object"", class0.toString());
//       assertFalse(class0.isPrimitive());
//       assertFalse(class0.isInterface());
//       assertFalse(class0.isArray());
//       assertFalse(class0.isEnum());
//       assertFalse(class0.isSynthetic());
//       
//       String string0 = .Gson.Types.typeToString(class0);
//       assertNotNull(string0);
//       assertEquals(""java.lang.Object"", string0);
//       assertEquals(1, class0.getModifiers());
//       assertFalse(class0.isAnnotation());
//       assertEquals(""class java.lang.Object"", class0.toString());
//       assertFalse(class0.isPrimitive());
//       assertFalse(class0.isInterface());
//       assertFalse(class0.isArray());
//       assertFalse(class0.isEnum());
//       assertFalse(class0.isSynthetic());
//   }

  @Test
  public void test19() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test19()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Class class1 = (Class).Gson.Types.getSupertype(wildcardType0, class0, class0);
//       assertNotNull(class1);
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isAnnotation());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(1, class1.getModifiers());
//       
//       Class class2 = (Class).Gson.Types.getGenericSupertype(wildcardType0, class1, class0);
//       assertNotNull(class2);
//       assertFalse(class2.equals((Object)class1));
//       assertNotSame(class1, class2);
//       assertNotSame(class2, class1);
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isAnnotation());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(1, class1.getModifiers());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class2.toString());
//       assertEquals(1537, class2.getModifiers());
//       assertFalse(class2.isEnum());
//       assertFalse(class2.isSynthetic());
//       assertFalse(class2.isArray());
//       assertTrue(class2.isInterface());
//       assertFalse(class2.isPrimitive());
//       assertFalse(class2.isAnnotation());
//   }

  @Test
  public void test20() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test20()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Class<?> class1 = .Gson.Types.getRawType(wildcardType0);
//       assertNotNull(class1);
//       assertFalse(class1.isAnnotation());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       
//       Class class2 = (Class).Gson.Types.resolve((Type) null, class1, class1);
//       assertNotNull(class2);
//       assertFalse(class1.isAnnotation());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertFalse(class2.isEnum());
//       assertFalse(class2.isSynthetic());
//       assertEquals(1, class2.getModifiers());
//       assertEquals(""class java.lang.Object"", class2.toString());
//       assertFalse(class2.isInterface());
//       assertFalse(class2.isArray());
//       assertFalse(class2.isPrimitive());
//       assertFalse(class2.isAnnotation());
//       
//       Class class3 = (Class).Gson.Types.getSupertype(wildcardType0, class0, class2);
//       assertNotNull(class3);
//       assertSame(class2, class3);
//       assertSame(class3, class2);
//       assertFalse(class1.isAnnotation());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertFalse(class2.isEnum());
//       assertFalse(class2.isSynthetic());
//       assertEquals(1, class2.getModifiers());
//       assertEquals(""class java.lang.Object"", class2.toString());
//       assertFalse(class2.isInterface());
//       assertFalse(class2.isArray());
//       assertFalse(class2.isPrimitive());
//       assertFalse(class2.isAnnotation());
//       assertFalse(class3.isAnnotation());
//       assertFalse(class3.isInterface());
//       assertFalse(class3.isArray());
//       assertFalse(class3.isEnum());
//       assertEquals(""class java.lang.Object"", class3.toString());
//       assertFalse(class3.isSynthetic());
//       assertFalse(class3.isPrimitive());
//       assertEquals(1, class3.getModifiers());
//   }

  @Test
  public void test21() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test21()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       Type type0 = .Gson.Types.getArrayComponentType(class0);
//       assertNull(type0);
//   }

  @Test
  public void test22() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test22()  throws Throwable  {
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       Type type0 = .Gson.Types.getArrayComponentType(genericArrayType0);
//       assertNull(type0);
//   }

  @Test
  public void test23() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test23()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       // Undeclared exception!
//       try { 
//         .Gson.Types.getMapKeyAndValueTypes((Type) null, class0);
//         fail(""Expecting exception: IllegalArgumentException"");
//       
//       } catch(IllegalArgumentException e) {
//          //
//          // no message in exception (getMessage() returned null)
//          //
//          verifyException(""com.google.gson.internal.$Gson$Preconditions"", e);
//       }
//   }

  @Test
  public void test24() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test24()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Class<?> class1 = .Gson.Types.getRawType(wildcardType0);
//       assertNotNull(class1);
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isAnnotation());
//       
//       GenericArrayType genericArrayType1 = .Gson.Types.arrayOf(class1);
//       assertNotNull(genericArrayType1);
//       assertFalse(genericArrayType1.equals((Object)genericArrayType0));
//       assertNotSame(genericArrayType0, genericArrayType1);
//       assertNotSame(genericArrayType1, genericArrayType0);
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isAnnotation());
//       
//       Class<?> class2 = .Gson.Types.getRawType(genericArrayType1);
//       assertNotNull(class2);
//       assertFalse(genericArrayType0.equals((Object)genericArrayType1));
//       assertFalse(genericArrayType1.equals((Object)genericArrayType0));
//       assertFalse(class2.equals((Object)class1));
//       assertNotSame(genericArrayType0, genericArrayType1);
//       assertNotSame(class1, class2);
//       assertNotSame(genericArrayType1, genericArrayType0);
//       assertNotSame(class2, class1);
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isAnnotation());
//       assertFalse(class2.isAnnotation());
//       assertFalse(class2.isPrimitive());
//       assertEquals(""class [Ljava.lang.Object;"", class2.toString());
//       assertFalse(class2.isInterface());
//       assertEquals(1041, class2.getModifiers());
//       assertTrue(class2.isArray());
//       assertFalse(class2.isEnum());
//       assertFalse(class2.isSynthetic());
//       
//       Class class3 = (Class).Gson.Types.resolve((Type) null, class0, class2);
//       assertNotNull(class3);
//       assertFalse(genericArrayType0.equals((Object)genericArrayType1));
//       assertFalse(class1.equals((Object)class2));
//       assertFalse(genericArrayType1.equals((Object)genericArrayType0));
//       assertFalse(class2.equals((Object)class1));
//       assertNotSame(genericArrayType0, genericArrayType1);
//       assertNotSame(class1, class2);
//       assertNotSame(genericArrayType1, genericArrayType0);
//       assertNotSame(class2, class1);
//       assertEquals(1, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isInterface());
//       assertFalse(class1.isArray());
//       assertEquals(""class java.lang.Object"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertFalse(class1.isAnnotation());
//       assertFalse(class2.isAnnotation());
//       assertFalse(class2.isPrimitive());
//       assertEquals(""class [Ljava.lang.Object;"", class2.toString());
//       assertFalse(class2.isInterface());
//       assertEquals(1041, class2.getModifiers());
//       assertTrue(class2.isArray());
//       assertFalse(class2.isEnum());
//       assertFalse(class2.isSynthetic());
//       assertFalse(class3.isInterface());
//       assertEquals(""class [Ljava.lang.Object;"", class3.toString());
//       assertFalse(class3.isAnnotation());
//       assertFalse(class3.isPrimitive());
//       assertEquals(1041, class3.getModifiers());
//       assertTrue(class3.isArray());
//       assertFalse(class3.isEnum());
//       assertFalse(class3.isSynthetic());
//   }

  @Test
  public void test25() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test25()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Type[] typeArray0 = new Type[0];
//       ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(wildcardType0, genericArrayType0, typeArray0);
//       assertNotNull(parameterizedType0);
//       assertEquals(0, typeArray0.length);
//       
//       Type type0 = .Gson.Types.getSupertype(parameterizedType0, class0, class0);
//       assertNotNull(type0);
//       assertEquals(0, typeArray0.length);
//   }

  @Test
  public void test26() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test26()  throws Throwable  {
//       Class<WildcardType> class0 = WildcardType.class;
//       Class class1 = (Class).Gson.Types.canonicalize(class0);
//       assertNotNull(class1);
//       assertFalse(class1.isArray());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertEquals(1537, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertTrue(class1.isInterface());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isAnnotation());
//       
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf(class1);
//       assertNotNull(genericArrayType0);
//       assertFalse(class1.isArray());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertEquals(1537, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertTrue(class1.isInterface());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isAnnotation());
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       assertFalse(class1.isArray());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertEquals(1537, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertTrue(class1.isInterface());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isAnnotation());
//       
//       Type[] typeArray0 = new Type[0];
//       WildcardType wildcardType1 = .Gson.Types.subtypeOf(wildcardType0);
//       assertNotNull(wildcardType1);
//       assertFalse(wildcardType1.equals((Object)wildcardType0));
//       assertNotSame(wildcardType0, wildcardType1);
//       assertNotSame(wildcardType1, wildcardType0);
//       assertFalse(class1.isArray());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertEquals(1537, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertTrue(class1.isInterface());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isAnnotation());
//       
//       ParameterizedType parameterizedType0 = .Gson.Types.newParameterizedTypeWithOwner(wildcardType1, class0, typeArray0);
//       assertNotNull(parameterizedType0);
//       assertFalse(wildcardType0.equals((Object)wildcardType1));
//       assertFalse(wildcardType1.equals((Object)wildcardType0));
//       assertEquals(0, typeArray0.length);
//       assertNotSame(wildcardType0, wildcardType1);
//       assertNotSame(wildcardType1, wildcardType0);
//       assertFalse(class1.isArray());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertEquals(1537, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertTrue(class1.isInterface());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isAnnotation());
//       
//       Type type0 = .Gson.Types.getSupertype(parameterizedType0, class0, class0);
//       assertNotNull(type0);
//       assertFalse(wildcardType0.equals((Object)wildcardType1));
//       assertFalse(wildcardType1.equals((Object)wildcardType0));
//       assertEquals(0, typeArray0.length);
//       assertNotSame(wildcardType0, wildcardType1);
//       assertNotSame(wildcardType1, wildcardType0);
//       assertFalse(class1.isArray());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       assertEquals(1537, class1.getModifiers());
//       assertFalse(class1.isSynthetic());
//       assertTrue(class1.isInterface());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isAnnotation());
//   }

  @Test
  public void test27() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test27()  throws Throwable  {
//       GenericArrayType genericArrayType0 = .Gson.Types.arrayOf((Type) null);
//       assertNotNull(genericArrayType0);
//       
//       WildcardType wildcardType0 = .Gson.Types.supertypeOf(genericArrayType0);
//       assertNotNull(wildcardType0);
//       
//       Type[] typeArray0 = new Type[3];
//       try { 
//         PrivateAccess.callMethod((Class<.Gson.Types>) .Gson.Types.class, (.Gson.Types) null, ""indexOf"", (Object) typeArray0, (Class<?>) Object[].class, (Object) wildcardType0, (Class<?>) Object.class);
//         fail(""Expecting exception: NoSuchElementException"");
//       
//       } catch(NoSuchElementException e) {
//          //
//          // no message in exception (getMessage() returned null)
//          //
//          verifyException(""com.google.gson.internal.$Gson$Types"", e);
//       }
//   }

  @Test
  public void test28() {}
// Defects4J: flaky method
//   @Test(timeout = 4000)
//   public void test28()  throws Throwable  {
//       Type type0 = mock(Type.class, new ViolatedAssumptionAnswer());
//       Class<WildcardType> class0 = WildcardType.class;
//       Collection<TypeVariable> collection0 = (Collection<TypeVariable>) mock(Collection.class, new ViolatedAssumptionAnswer());
//       Class class1 = (Class)PrivateAccess.callMethod((Class<.Gson.Types>) .Gson.Types.class, (.Gson.Types) null, ""resolve"", (Object) type0, (Class<?>) Type.class, (Object) class0, (Class<?>) Class.class, (Object) class0, (Class<?>) Type.class, (Object) collection0, (Class<?>) Collection.class);
//       assertNotNull(class1);
//       assertFalse(class1.isArray());
//       assertFalse(class1.isAnnotation());
//       assertTrue(class1.isInterface());
//       assertEquals(1537, class1.getModifiers());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//       
//       Object[] objectArray0 = new Object[2];
//       objectArray0[0] = (Object) class0;
//       Integer integer0 = (Integer)PrivateAccess.callMethod((Class<.Gson.Types>) .Gson.Types.class, (.Gson.Types) null, ""indexOf"", (Object) objectArray0, (Class<?>) Object[].class, (Object) class1, (Class<?>) Object.class);
//       assertNotNull(integer0);
//       assertEquals(2, objectArray0.length);
//       assertEquals(0, (int)integer0);
//       assertFalse(class1.isArray());
//       assertFalse(class1.isAnnotation());
//       assertTrue(class1.isInterface());
//       assertEquals(1537, class1.getModifiers());
//       assertFalse(class1.isEnum());
//       assertFalse(class1.isSynthetic());
//       assertEquals(""interface java.lang.reflect.WildcardType"", class1.toString());
//       assertFalse(class1.isPrimitive());
//   }
}
"
a83e47921152721569cb95d6d7b91c4be277d940,"Fix the number of uncompilable tests.
When a `test X` has multiple compilation errors, the [Defects4J fix_test_suite.pl](https://github.com/rjust/defects4j/blob/master/framework/util/fix_test_suite.pl) script tries to fix `test X` as many times as the number of compilation errors.  This leads the script to report an incorrect number of uncompilable tests.  This commit set the maximum number of errors reported by javac to 1 so that each test is fixed once.",ADD,,"/**
 * Scaffolding file used to store all the setups needed to run 
 * tests automatically generated by EvoSuite
 * Fri Mar 31 20:20:01 GMT 2023
 */

package com.google.gson.internal;

import org.evosuite.runtime.annotation.EvoSuiteClassExclude;
import org.junit.BeforeClass;
import org.junit.Before;
import org.junit.After;
import org.junit.AfterClass;
import org.evosuite.runtime.sandbox.Sandbox;
import org.evosuite.runtime.sandbox.Sandbox.SandboxMode;

import static org.evosuite.shaded.org.mockito.Mockito.*;
@EvoSuiteClassExclude
public class $Gson$Types_ESTest_scaffolding {

  @org.junit.Rule
  public org.evosuite.runtime.vnet.NonFunctionalRequirementRule nfr = new org.evosuite.runtime.vnet.NonFunctionalRequirementRule();

  private static final java.util.Properties defaultProperties = (java.util.Properties) java.lang.System.getProperties().clone(); 

  private org.evosuite.runtime.thread.ThreadStopper threadStopper =  new org.evosuite.runtime.thread.ThreadStopper (org.evosuite.runtime.thread.KillSwitchHandler.getInstance(), 3000);


  @BeforeClass
  public static void initEvoSuiteFramework() { 
    org.evosuite.runtime.RuntimeSettings.className = ""com.google.gson.internal.$Gson$Types""; 
    org.evosuite.runtime.GuiSupport.initialize(); 
    org.evosuite.runtime.RuntimeSettings.maxNumberOfThreads = 100; 
    org.evosuite.runtime.RuntimeSettings.maxNumberOfIterationsPerLoop = 10000; 
    org.evosuite.runtime.RuntimeSettings.mockSystemIn = true; 
    org.evosuite.runtime.RuntimeSettings.sandboxMode = org.evosuite.runtime.sandbox.Sandbox.SandboxMode.RECOMMENDED; 
    org.evosuite.runtime.sandbox.Sandbox.initializeSecurityManagerForSUT(); 
    org.evosuite.runtime.classhandling.JDKClassResetter.init();
    setSystemProperties();
    initializeClasses();
    org.evosuite.runtime.Runtime.getInstance().resetRuntime(); 
    try { initMocksToAvoidTimeoutsInTheTests(); } catch(ClassNotFoundException e) {} 
  } 

  @AfterClass
  public static void clearEvoSuiteFramework(){ 
    Sandbox.resetDefaultSecurityManager(); 
    java.lang.System.setProperties((java.util.Properties) defaultProperties.clone()); 
  } 

  @Before
  public void initTestCase(){ 
    threadStopper.storeCurrentThreads();
    threadStopper.startRecordingTime();
    org.evosuite.runtime.jvm.ShutdownHookHandler.getInstance().initHandler(); 
    org.evosuite.runtime.sandbox.Sandbox.goingToExecuteSUTCode(); 
    setSystemProperties(); 
    org.evosuite.runtime.GuiSupport.setHeadless(); 
    org.evosuite.runtime.Runtime.getInstance().resetRuntime(); 
    org.evosuite.runtime.agent.InstrumentingAgent.activate(); 
  } 

  @After
  public void doneWithTestCase(){ 
    threadStopper.killAndJoinClientThreads();
    org.evosuite.runtime.jvm.ShutdownHookHandler.getInstance().safeExecuteAddedHooks(); 
    org.evosuite.runtime.classhandling.JDKClassResetter.reset(); 
    resetClasses(); 
    org.evosuite.runtime.sandbox.Sandbox.doneWithExecutingSUTCode(); 
    org.evosuite.runtime.agent.InstrumentingAgent.deactivate(); 
    org.evosuite.runtime.GuiSupport.restoreHeadlessMode(); 
  } 

  public static void setSystemProperties() {
 
    java.lang.System.setProperties((java.util.Properties) defaultProperties.clone()); 
    java.lang.System.setProperty(""user.dir"", ""/tmp/slurm_344957/jcampos-15550-aeaba38a4c25ae6a274a0cd3fb1cd825-Gson-18""); 
    java.lang.System.setProperty(""java.io.tmpdir"", ""/tmp""); 
  }

  private static void initializeClasses() {
    org.evosuite.runtime.classhandling.ClassStateSupport.initializeClasses($Gson$Types_ESTest_scaffolding.class.getClassLoader() ,
      ""com.google.gson.internal.$Gson$Types"",
      ""com.google.gson.internal.$Gson$Preconditions"",
      ""com.google.gson.internal.$Gson$Types$WildcardTypeImpl"",
      ""com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl"",
      ""com.google.gson.internal.$Gson$Types$GenericArrayTypeImpl""
    );
  } 
  private static void initMocksToAvoidTimeoutsInTheTests() throws ClassNotFoundException { 
    mock(Class.forName(""java.lang.reflect.Type"", false, $Gson$Types_ESTest_scaffolding.class.getClassLoader()));
    mock(Class.forName(""java.util.Collection"", false, $Gson$Types_ESTest_scaffolding.class.getClassLoader()));
  }

  private static void resetClasses() {
    org.evosuite.runtime.classhandling.ClassResetter.getInstance().setClassLoader($Gson$Types_ESTest_scaffolding.class.getClassLoader()); 

    org.evosuite.runtime.classhandling.ClassStateSupport.resetClasses(
      ""com.google.gson.internal.$Gson$Types"",
      ""com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl"",
      ""com.google.gson.internal.$Gson$Types$GenericArrayTypeImpl"",
      ""com.google.gson.internal.$Gson$Types$WildcardTypeImpl"",
      ""com.google.gson.internal.$Gson$Preconditions""
    );
  }
}
"
